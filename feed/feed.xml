<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet href="pretty-atom-feed.xsl" type="text/xsl"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
  <title>Blog Title</title>
  <subtitle>This is a longer description about your blog.</subtitle>
  <link href="https://example.com/eleventy-base-blog/feed/feed.xml" rel="self" />
  <link href="https://example.com/eleventy-base-blog/" />
  <updated>2025-02-26T00:00:00Z</updated>
  <id>https://example.com/eleventy-base-blog/</id>
  <author>
    <name>Your Name</name>
  </author>
  <entry>
    <title>complete categories</title>
    <link href="https://example.com/eleventy-base-blog/blog/alllimits/" />
    <updated>2025-02-26T00:00:00Z</updated>
    <id>https://example.com/eleventy-base-blog/blog/alllimits/</id>
    <content type="html">&lt;script type=&quot;text/x-mathjax-config&quot;&gt;
    MathJax.Hub.Config({
      jax: [&quot;input/TeX&quot;, &quot;output/HTML-CSS&quot;],
      extensions: [&quot;tex2jax.js&quot;],
      &quot;HTML-CSS&quot;: { preferredFont: &quot;TeX&quot;, availableFonts: [&quot;STIX&quot;,&quot;TeX&quot;] },
      tex2jax: { inlineMath: [ [&quot;$&quot;, &quot;$&quot;], [&quot;&#92;&#92;(&quot;,&quot;&#92;&#92;)&quot;] ], displayMath: [ [&quot;$$&quot;,&quot;$$&quot;], [&quot;&#92;&#92;[&quot;, &quot;&#92;&#92;]&quot;] ], processEscapes: true, ignoreClass: &quot;tex2jax_ignore|dno&quot; },
      TeX: { noUndefined: { attributes: { mathcolor: &quot;red&quot;, mathbackground: &quot;#FFEEEE&quot;, mathsize: &quot;90%&quot; } } },
      messageStyle: &quot;none&quot;
    });
    &lt;/script&gt;    
    &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;To prove that the forgetful functor &#92;( U: &#92;text{Vect}_k &#92;to &#92;text{Set} &#92;) is monadic, we need to show that it satisfies the conditions of monadicity, as given by Beck&#39;s Monadicity Theorem. The forgetful functor &#92;( U &#92;) maps a vector space over a field &#92;( k &#92;) to its underlying set and maps linear transformations to their underlying functions. 
&lt;/p&gt;
&lt;p&gt; 
The forgetful functor &#92;( U: &#92;text{Vect}_k &#92;to &#92;text{Set} &#92;) has a left adjoint &#92;( F: &#92;text{Set} &#92;to &#92;text{Vect}_k &#92;), which is the free vector space functor. For a set &#92;( X &#92;), &#92;( F(X) &#92;) is the vector space whose basis is &#92;( X &#92;). The adjunction is given by the natural isomorphism:
&#92;[
&#92;text{Hom}_{&#92;text{Vect}_k}(F(X), V) &#92;simeq &#92;text{Hom}_{&#92;text{Set}}(X, U(V)),
&#92;]
where &#92;( V &#92;) is a vector space and &#92;( X &#92;) is a set. This shows that &#92;( U &#92;) is a right adjoint.
&lt;/p&gt;


&lt;p&gt; The adjunction &#92;( F &#92;dashv U &#92;) induces a monad &#92;( T = UF &#92;) on &#92;( &#92;text{Set} &#92;).
First, for a set &#92;( X &#92;), &#92;( T(X) = U(F(X)) &#92;) is the underlying set of the free vector space generated by &#92;( X &#92;). This is the set of formal linear combinations of elements of &#92;( X &#92;) with coefficients in &#92;( k &#92;).
Second, the unit &#92;( &#92;eta_X: X &#92;to T(X) &#92;) maps an element &#92;( x &#92;in X &#92;) to the corresponding basis vector in &#92;( F(X) &#92;).
Third, the multiplication &#92;( &#92;mu_X: T(T(X)) &#92;to T(X) &#92;) is the linear map that &quot;flattens&quot; formal linear combinations of formal linear combinations into formal linear combinations.
&lt;/p&gt;


&lt;p&gt; 
Beck&#39;s Monadicity Theorem states that a functor &#92;( U &#92;) is monadic if:
&#92;((1.)&#92;) &#92;( U &#92;) has a left adjoint, 
&#92;((2.)&#92;) &#92;( U &#92;) reflects isomorphisms, and 
&#92;((3.)&#92;) &#92;( U &#92;) preserves and reflects coequalizers of &#92;( U &#92;)-split pairs.
&lt;/p&gt;
&lt;p&gt; 
This third condition might be least familiar. Wikipedia&#39;s descriptions for this are not as subpar as they often are. First, (&#92;( U &#92;)-split pairs are those parallel pairs of morphisms in $&#92;text{Vect}_k$, which $U$ sends to pairs having a split coequalizer in $&#92;text{Set} $). Second, in the category of sets, the coequalizer of two functions &#92;( f, g: X &#92;to Y &#92;) is the quotient of &#92;( Y &#92;) by the smallest equivalence relation &#92;( &#92;sim &#92;) satisfying &#92;( f(x) &#92;sim g(x) &#92;) for every &#92;( x &#92;in X &#92;). For example, if &#92;( R &#92;) is an equivalence relation on a set &#92;( Y &#92;), and &#92;( r_1, r_2: R &#92;to Y &#92;) are the natural projections (where &#92;( R &#92;subseteq Y &#92;times Y &#92;)), then the coequalizer of &#92;( r_1 &#92;) and &#92;( r_2 &#92;) is the quotient set &#92;( Y / R &#92;). 
&lt;/p&gt;
&lt;p&gt; 
Before looking at &#92;( U &#92;)-split pair in &#92;( &#92;text{Vect}_k &#92;), let&#39;s verify the first two conditions.
&lt;/p&gt;
&lt;p&gt; 
For $(1)$, we already showed &#92;( U &#92;) has a left adjoint.
&lt;/p&gt;
&lt;p&gt; 
For $(2)$, a linear transformation &#92;( f: V &#92;to W &#92;) is an isomorphism in &#92;( &#92;text{Vect}_k &#92;) if and only if it is bijective. Since &#92;( U &#92;) maps &#92;( f &#92;) to its underlying function, &#92;( U(f) &#92;) is an isomorphism in &#92;( &#92;text{Set} &#92;) (i.e., a bijection) if and only if &#92;( f &#92;) is an isomorphism in &#92;( &#92;text{Vect}_k &#92;). Thus, &#92;( U &#92;) reflects isomorphisms.
&lt;/p&gt;
&lt;p&gt; 
For $(3)$, a &#92;( U &#92;)-split pair in &#92;( &#92;text{Vect}_k &#92;) consists of linear maps &#92;( f, g: V &#92;to W &#92;) such that there exist set-theoretic maps &#92;( h: U(W) &#92;to U(V) &#92;) and &#92;( k: U(W) &#92;to U(W) &#92;) making &#92;( U(f), U(g) &#92;) a split pair in &#92;( &#92;text{Set} &#92;). The coequalizer of &#92;( f, g &#92;) in &#92;( &#92;text{Vect}_k &#92;) is the quotient space &#92;( W / &#92;text{Im}(f - g) &#92;), and &#92;( U &#92;) maps this to the set-theoretic coequalizer of &#92;( U(f), U(g) &#92;) in &#92;( &#92;text{Set} &#92;). Since &#92;( U &#92;) is a right adjoint, it preserves coequalizers of &#92;( U &#92;)-split pairs. Moreover, because &#92;( U &#92;) reflects isomorphisms and the splitting conditions ensure that the coequalizer in &#92;( &#92;text{Set} &#92;) lifts uniquely to &#92;( &#92;text{Vect}_k &#92;), &#92;( U &#92;) also reflects coequalizers of &#92;( U &#92;)-split pairs. Thus, &#92;( U &#92;) preserves and reflects such coequalizers.
&lt;/p&gt;

&lt;!-- https://q.uiver.app/#q=WzAsNCxbMCwwLCJWIl0sWzEsMCwiVyJdLFsyLDAsIlcgLyBcXHRleHR7SW19KGYgLSBnKSJdLFsyLDEsIloiXSxbMCwxLCJmIiwwLHsib2Zmc2V0IjotMX1dLFsxLDIsIlxccGkiXSxbMSwzLCJcXHBpJyIsMl0sWzIsMywiXFxleGlzdHMgISBcXCwgaCIsMCx7InN0eWxlIjp7ImJvZHkiOnsibmFtZSI6ImRhc2hlZCJ9fX1dLFswLDEsImciLDIseyJvZmZzZXQiOjF9XV0= --&gt;
&lt;iframe class=&quot;quiver-embed&quot; src=&quot;https://q.uiver.app/#q=WzAsNCxbMCwwLCJWIl0sWzEsMCwiVyJdLFsyLDAsIlcgLyBcXHRleHR7SW19KGYgLSBnKSJdLFsyLDEsIloiXSxbMCwxLCJmIiwwLHsib2Zmc2V0IjotMX1dLFsxLDIsIlxccGkiXSxbMSwzLCJcXHBpJyIsMl0sWzIsMywiXFxleGlzdHMgISBcXCwgaCIsMCx7InN0eWxlIjp7ImJvZHkiOnsibmFtZSI6ImRhc2hlZCJ9fX1dLFswLDEsImciLDIseyJvZmZzZXQiOjF9XV0=&amp;embed&quot; width=&quot;553&quot; height=&quot;304&quot; style=&quot;border-radius: 8px; border: none;&quot;&gt;&lt;/iframe&gt;
&lt;p&gt; 
In particular, in &#92;(&#92;text{Vect}_k&#92;), let &#92;(V&#92;) and &#92;(W&#92;) be vector spaces, and let &#92;(f, g: V &#92;to W&#92;) be linear maps. The coequalizer of &#92;(f&#92;) and &#92;(g&#92;) is the quotient space &#92;(W / &#92;text{Im}(f - g)&#92;), equipped with the canonical projection map &#92;(&#92;pi: W &#92;to W / &#92;text{Im}(f - g)&#92;). For any vector space &#92;(Z&#92;) and linear map &#92;(&#92;pi&#39;: W &#92;to Z&#92;) satisfying &#92;(&#92;pi&#39; &#92;circ f = &#92;pi&#39; &#92;circ g&#92;), there exists a unique linear map &#92;(h: W / &#92;text{Im}(f - g) &#92;to Z&#92;) induced by the universal property of the coequalizer, such that &#92;(&#92;pi&#39; = h &#92;circ &#92;pi&#92;). This universal property characterizes the coequalizer in &#92;(&#92;text{Vect}_k&#92;). 
&lt;/p&gt;
&lt;p&gt; 
As the forgetful functor &#92;( U: &#92;text{Vect}_k &#92;to &#92;text{Set} &#92;) satisfies all the conditions of Beck&#39;s Monadicity Theorem, it is monadic. This particularly means that &#92;( &#92;text{Vect}_k &#92;) is equivalent to the category of algebras over the monad &#92;( T = UF &#92;) on &#92;( &#92;text{Set} &#92;).
&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Now, the nice thing is that $&#92;text{Set}$ has all limits by design. Since the canoncial forgetful functor from $&#92;text{Vect}_k$ is monadic, we see $&#92;text{Vect}_k$ also has all limits.

  It remains to show that the category of chain complexes $ &#92;text{CH}(k) $ has all limits. We can do this analogously to how we showed $&#92;text{Vect}_k$ has all limits given $&#92;text{Set}$ has all limits.
  
  &lt;/p&gt;
  
  &lt;p&gt;To prove that the category of chain complexes $ &#92;text{CH}(k) $ is a reflective subcategory of a category of functors into $ &#92;text{Vect}_k $, we need to show that the inclusion functor $ i: &#92;text{CH}(k) &#92;to &#92;text{Fun}(&#92;mathcal{C}, &#92;text{Vect}_k) $ has a left adjoint. This left adjoint is called the reflector, and it provides a way to &quot;reflect&quot; objects from the larger category (functors into $ &#92;text{Vect}_k $) back into the subcategory $ &#92;text{CH}(k) $.&lt;/p&gt;&lt;p&gt;  Let $ &#92;text{Vect}_k $ be the category of vector spaces over a field $ k $.&lt;/p&gt;&lt;p&gt;  Let $ &#92;text{CH}(k) $ be the category of chain complexes of $ k $-vector spaces. Objects are sequences of vector spaces $ (C_n)_{n &#92;in &#92;mathbb{Z}} $ with differentials $ d_n: C_n &#92;to C_{n-1} $ such that $ d_{n-1} &#92;circ d_n = 0 $, and morphisms are chain maps.&lt;/p&gt;&lt;p&gt;  Let $ &#92;mathcal{C} $ be a small category, and let $ &#92;text{Fun}(&#92;mathcal{C}, &#92;text{Vect}_k) $ be the category of functors from $ &#92;mathcal{C} $ to $ &#92;text{Vect}_k $. Objects are functors $ F: &#92;mathcal{C} &#92;to &#92;text{Vect}_k $, and morphisms are natural transformations.&lt;/p&gt;&lt;p&gt;  Consider the category $ &#92;mathcal{C} = &#92;mathbb{Z} $, where $ &#92;mathbb{Z} $ is viewed as a poset category (with objects integers and a unique morphism $ n &#92;to m $ iff $ n &#92;geq m $).&lt;/p&gt;&lt;p&gt;  A functor $ F: &#92;mathbb{Z} &#92;to &#92;text{Vect}_k $ assigns a vector space $ F(n) $ to each integer $ n $ and a linear map $ F(n &#92;to m): F(n) &#92;to F(m) $ for each $ n &#92;geq m $.&lt;/p&gt;&lt;p&gt;  A chain complex $ (C_n, d_n) $ can be viewed as a functor $ F: &#92;mathbb{Z} &#92;to &#92;text{Vect}_k $, where $ F(n) = C_n $ and $ F(n &#92;to n-1) = d_n $, with the condition $ d_{n-1} &#92;circ d_n = 0 $.&lt;/p&gt;&lt;p&gt;   Thus, $ &#92;text{CH}(k) $ is a subcategory of $ &#92;text{Fun}(&#92;mathbb{Z}, &#92;text{Vect}_k) $.&lt;/p&gt;&lt;p&gt;  To show that $ &#92;text{CH}(k) $ is a reflective subcategory, we need to construct a left adjoint $ L: &#92;text{Fun}(&#92;mathbb{Z}, &#92;text{Vect}_k) &#92;to &#92;text{CH}(k) $ to the inclusion functor $ i: &#92;text{CH}(k) &#92;to &#92;text{Fun}(&#92;mathbb{Z}, &#92;text{Vect}_k) $.&lt;/p&gt;&lt;p&gt;  For a functor $ F &#92;in &#92;text{Fun}(&#92;mathbb{Z}, &#92;text{Vect}_k) $, define $ L(F) $ as the chain complex obtained by &quot;forcing&quot; the condition $ d_{n-1} &#92;circ d_n = 0 $.&lt;/p&gt;&lt;p&gt;To construct the chain complex $ L(F) $ from a functor $ F: &#92;mathbb{Z} &#92;to &#92;text{Vect}_k $, we start by defining $ L(F)_n = F(n) $ and the differential $ d_n = F(n &#92;to n-1) $. However, this does not automatically satisfy the chain complex condition $ d_{n-1} &#92;circ d_n = 0 $. To enforce this condition, we modify $ L(F)_n $ by taking the quotient of $ F(n) $ by the image of $ d_{n+1}: F(n+1) &#92;to F(n) $, particularly submodule generated by this image. This quotient ensures that the composition $ d_{n-1} &#92;circ d_n $ becomes zero, as the image of $ d_{n+1} $ is factored out. The resulting object $ L(F) $ is now a chain complex, as the differentials satisfy the required condition $ d_{n-1} &#92;circ d_n = 0 $. This process of quotienting effectively &quot;reflects&quot; the functor $ F $ into the subcategory of chain complexes.&lt;/p&gt;&lt;p&gt;  The reflector $ L $ is left adjoint to the inclusion functor $ i $. We see there is a natural isomorphism:&lt;/p&gt;&lt;p&gt;     $$&#92;text{Hom}_{&#92;text{CH}(k)}(L(F), C) &#92;simeq &#92;text{Hom}_{&#92;text{Fun}(&#92;mathbb{Z}, &#92;text{Vect}_k)}(F, i(C))$$&lt;/p&gt;&lt;p&gt;     for all $ F &#92;in &#92;text{Fun}(&#92;mathbb{Z}, &#92;text{Vect}_k) $ and $ C &#92;in &#92;text{CH}(k) $.&lt;/p&gt;&lt;p&gt;  This adjunction arises because $ L(F) $ is the &quot;best approximation&quot; of $ F $ as a chain complex, and morphisms from $ L(F) $ to $ C $ correspond naturally to morphisms from $ F $ to $ i(C) $.&lt;/p&gt;&lt;p&gt;  Since the inclusion functor $ i: &#92;text{CH}(k) &#92;to &#92;text{Fun}(&#92;mathbb{Z}, &#92;text{Vect}_k) $ has a left adjoint $ L $, the category $ &#92;text{CH}(k) $ is a reflective subcategory of $ &#92;text{Fun}(&#92;mathbb{Z}, &#92;text{Vect}_k) $.&lt;/p&gt;
  &lt;p&gt;A category where all limits exist is called a &quot;complete category&quot;.&lt;/p&gt;
  &lt;hr&gt;

  These notes were inspired by a remark in &lt;a href=&quot;https://youtu.be/5uI0uJpsEhI?si=f8G1Y0ylOOewxhhG&quot;&gt;this&lt;/a&gt; video.</content>
  </entry>
  <entry>
    <title>widget: matrix product</title>
    <link href="https://example.com/eleventy-base-blog/blog/matrixprod/" />
    <updated>2025-02-08T00:00:00Z</updated>
    <id>https://example.com/eleventy-base-blog/blog/matrixprod/</id>
    <content type="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;&lt;/head&gt;
&lt;body&gt;
  &lt;form onsubmit=&quot;return false;&quot;&gt;
    &lt;label for=&quot;matrix&quot;&gt;Enter matrix of any dimension to multiply with its transpose:&lt;/label&gt;
    &lt;input type=&quot;text&quot; name=&quot;matrix&quot; id=&quot;matrix&quot; placeholder=&quot;[[1,2],[3,4]]&quot;&gt;
    &lt;button type=&quot;button&quot; onclick=&quot;processMatrix()&quot;&gt;Submit&lt;/button&gt;
  &lt;/form&gt;
  
  &lt;div id=&quot;out&quot;&gt;&lt;/div&gt;
  
  &lt;script&gt;
    async function processMatrix() {
        try {
            let mat = JSON.parse(document.getElementById(&quot;matrix&quot;).value);

            let trans = mat[0].map((_, colIndex) =&gt;
                mat.map(row =&gt; row[colIndex])
            );

            let prod = await multiplyMatrices(mat, trans);

            let div = document.getElementById(&quot;out&quot;);
            div.innerHTML = JSON.stringify(prod);
        } catch (error) {
            console.error(&quot;Error processing the matrix:&quot;, error);
            document.getElementById(&quot;out&quot;).innerHTML = &quot;Error: &quot; + error.message;
        }
    }

    async function multiplyMatrices(A, B) {
      return new Promise((resolve, reject) =&gt; {
          setTimeout(() =&gt; {
              try {
                  const rowsA = A.length;
                  const colsA = A[0].length;
                  const rowsB = B.length;
                  const colsB = B[0].length;

                  if (colsA !== rowsB) {
                      throw new Error(&quot;Matrices cannot be multiplied: Incompatible dimensions.&quot;);
                  }

                  const resultMatrix = Array(rowsA).fill(null).map(() =&gt; Array(colsB).fill(0));

                  for (let i = 0; i &lt; rowsA; i++) {
                      for (let j = 0; j &lt; colsB; j++) {
                          for (let k = 0; k &lt; colsA; k++) {
                              resultMatrix[i][j] += A[i][k] * B[k][j];
                          }
                      }
                  }

                  resolve(resultMatrix);
              } catch (err) {
                  reject(err);
              }
          }, 0);
      });
    }
  &lt;/script&gt;
  &lt;hr&gt;
  &lt;script src=&quot;https://gist.github.com/ischmidls/f2897600ee3cb7ad4650eb9442f5bac6.js&quot;&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</content>
  </entry>
  <entry>
    <title>textcraft</title>
    <link href="https://example.com/eleventy-base-blog/blog/textcraft/" />
    <updated>2025-01-22T00:00:00Z</updated>
    <id>https://example.com/eleventy-base-blog/blog/textcraft/</id>
    <content type="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Minecraft Text Adventure&lt;/title&gt;
    &lt;style&gt;
        body {
            font-family: monospace;
            background-color: white;
            color: black;
            margin: 0;
            padding: 20px;
        }
        #output {
            white-space: pre-line;
            margin-bottom: 20px;
            max-height: 400px;
            overflow-y: auto;
        }
        #input {
            width: 100%;
            padding: 10px;
            font-family: monospace;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;output&quot;&gt;Welcome to text-based Minecraft! Type a command (or help) to begin...&lt;/div&gt;
    &lt;input id=&quot;input&quot; type=&quot;text&quot; placeholder=&quot;Enter your command here...&quot; autofocus=&quot;&quot;&gt;
    
     &lt;script&gt;
const output = document.getElementById(&quot;output&quot;);
const input = document.getElementById(&quot;input&quot;);

const biomes = [&#39;Forest Biome&#39;, &#39;Grasslands Biome&#39;, &#39;Desert Biome&#39;]; // Sample biomes
let inventory = [];
// add coordinates
let coordinates = [0,64,0];
const blocks = [&#39;Dirt&#39;, &#39;Cobblestone&#39;, &#39;Coal&#39;, &#39;Diamond&#39;];
const ores = [&#39;Iron Ore&#39;, &#39;Gold Ore&#39;];
const ingots = [&#39;Iron Ingot&#39;, &#39;Gold Ingot&#39;];
const monsters = [&#39;Zombie&#39;, &#39;Creeper&#39;, &#39;Enderman&#39;, &#39;Skeleton&#39;, &#39;Spider&#39;, &#39;Drowned&#39;, &#39;Stray&#39;];
const caves = [&#39;Dripstone Cavern&#39;, &#39;Lush Cave&#39;, &#39;Ravine&#39;, &#39;Cave&#39;, &#39;Abandoned Mineshaft&#39;, &#39;Dungeon&#39;];
let gameState = &quot;idle&quot;; // Track the current state of the game
let currentBiome = &quot;&quot;; // Store the biome during exploration
let experience = 0;
let monster_health = 20;
let player_attack_damage = 1;
let player_health = 20;
let monster_attack_damage = 5;
let void_fall = false;
let slain_by_monster = false;
let mining_strength = 0
const items = {
    &quot;Wooden Sword&quot;: {
        recipe: new Array(2).fill(&quot;Plank&quot;).concat(new Array(1).fill(&quot;Stick&quot;)),
        damage: 1,
        miningStrength: 0,
    },
    &quot;Wooden Pickaxe&quot;: {
        recipe: new Array(3).fill(&quot;Plank&quot;).concat(new Array(2).fill(&quot;Stick&quot;)),
        damage: 1,
        miningStrength: 1,
    },
    &quot;Cobblestone Sword&quot;: {
        recipe: new Array(2).fill(&quot;Cobblestone&quot;).concat(new Array(1).fill(&quot;Stick&quot;)),
        damage: 2,
        miningStrength: 0,
    },
    &quot;Cobblestone Pickaxe&quot;: {
        recipe: new Array(3).fill(&quot;Cobblestone&quot;).concat(new Array(2).fill(&quot;Stick&quot;)),
        damage: 2,
        miningStrength: 2,
    },
    &quot;Iron Sword&quot;: {
        recipe: new Array(2).fill(&quot;Iron&quot;).concat(new Array(1).fill(&quot;Stick&quot;)),
        damage: 3,
        miningStrength: 0,
    },
    &quot;Iron Pickaxe&quot;: {
        recipe: new Array(3).fill(&quot;Iron&quot;).concat(new Array(2).fill(&quot;Stick&quot;)),
        damage: 3,
        miningStrength: 3,
    },
    &quot;Gold Sword&quot;: {
        recipe: new Array(2).fill(&quot;Gold&quot;).concat(new Array(1).fill(&quot;Stick&quot;)),
        damage: 3,
        miningStrength: 0,
    },
    &quot;Gold Pickaxe&quot;: {
        recipe: new Array(3).fill(&quot;Gold&quot;).concat(new Array(2).fill(&quot;Stick&quot;)),
        damage: 3,
        miningStrength: 3,
    },
    &quot;Diamond Sword&quot;: {
        recipe: new Array(2).fill(&quot;Diamond&quot;).concat(new Array(1).fill(&quot;Stick&quot;)),
        damage: 3,
        miningStrength: 0,
    },
    &quot;Diamond Pickaxe&quot;: {
        recipe: new Array(3).fill(&quot;Diamond&quot;).concat(new Array(2).fill(&quot;Stick&quot;)),
        damage: 4,
        miningStrength: 4,
    },
};


const toTitleCase = (str) =&gt; {
    return str.replace(
        /&#92;w&#92;S*/g,
        text =&gt; text.charAt(0).toUpperCase() + text.substring(1).toLowerCase()
    );
}

const appendOutput = (text) =&gt; {
    output.textContent += `&#92;n${text}`;
    output.scrollTop = output.scrollHeight; // Scroll to bottom
};

const startEquip = () =&gt; {
    gameState = &quot;equip&quot;
    appendOutput(&quot;What would you like to equip? (or exit)&quot;)
}

const handleEquip = (command) =&gt; {
    const item = items[toTitleCase(command)];

    if (item) {
        // Update global variables based on the item&#39;s properties
        player_attack_damage = item.damage;
        mining_strength = item.miningStrength;
        appendOutput(
            `Equipped ${command}. Attack damage is now ${player_attack_damage}, and mining strength is ${mining_strength}.`
        );
    } else if (command.toLowerCase() === &quot;exit&quot;) {
        gameState = &quot;idle&quot;
        appendOutput(&quot;Exiting equip&quot;)
    } else {
        appendOutput(`Item &quot;${command}&quot; not found.`);
    }
            &quot;That&#39;s not an item?&quot;
    }


const startExplore = () =&gt; {
    currentBiome = biomes[Math.floor(Math.random() * biomes.length)];
    gameState = &quot;explore&quot;; // Transition to the explore state
    coordinates[0] += Math.floor(Math.random() * 64)
    coordinates[1] += Math.floor(Math.random() * 64)
    appendOutput(`You are now exploring the ${currentBiome}. What resource would you like to collect?`);
    appendOutput(&quot;You can collect seeds or wood from compatible biomes.&quot;);
    appendOutput(&quot;Type &#39;exit&#39; to leave or &#39;explore&#39; to keep exploring&#39;.&quot;);
};

const handleExplore = (command) =&gt; {
    switch (command.toLowerCase()) {
        case &quot;wood&quot;:
            if (currentBiome === &quot;Forest Biome&quot;) {
                appendOutput(&quot;You collected three wood and two sticks!&quot;);
                inventory.push(&quot;Wood&quot;, &quot;Wood&quot;, &quot;Wood&quot;, &quot;Stick&quot;, &quot;Stick&quot;);
            } else {
                appendOutput(&quot;You cannot collect wood here.&quot;);
            }
            break;
        case &quot;seeds&quot;:
            if (currentBiome === &quot;Grasslands Biome&quot;) {
                appendOutput(&quot;You collected five seeds!&quot;);
                inventory.push(&quot;seed&quot;, &quot;seed&quot;, &quot;seed&quot;, &quot;seed&quot;, &quot;seed&quot;);
            } else {
                appendOutput(&quot;You cannot collect seeds here.&quot;);
            }
            break;
        case &quot;exit&quot;:
            appendOutput(&quot;Exiting exploration...&quot;);
            gameState = &quot;idle&quot;; // Return to the idle state
            break;
        case &quot;explore&quot;:
            appendOutput(&quot;You continue to explore...&quot;)
            startExplore()
            break;
        default:
            appendOutput(&quot;Invalid resource. Please specify &#39;wood&#39; or &#39;seeds&#39;, or type &#39;exit&#39; to leave.&quot;);
    }
};

const startMine = () =&gt; {
    currentCave = caves[Math.floor(Math.random() * caves.length)];
    gameState = &quot;mine&quot;; // Transition to the explore state
    appendOutput(`You are now exploring the ${currentCave}. What resource would you like to collect?`);
    appendOutput(&quot;Type &#39;cobblestone&#39; or &#39;dirt&#39; to collect. Type &#39;exit&#39; to leave or &#39;mine&#39; to continue.&quot;);
    appendOutput(&quot;Greater treasures appear at lower depths.&quot;)
};

// function mine() {
//     const move = Math.floor(Math.random() * 5) + 1
//     if (coordinates[2] &lt;= -50 &amp;&amp; move === 1 &amp;&amp; mining_strength &gt;= 3) {
//         appendOutput(&quot;You mined a Diamond&quot;);
//         inventory.push(&quot;Diamond&quot;);
//     } else if (coordinates[2] &lt;= -50 &amp;&amp; move === 1) {
//         appendOutput(&quot;You found a Diamond but need at least an Iron Pickaxe&quot;);
//     } else if (coordinates[2] &lt;= -30 &amp;&amp; [2,3].includes(move) &amp;&amp; mining_strength &gt;= 3) {
//         appendOutput(&quot;You mined three Gold Ore&quot;);
//         inventory.concat(new Array(3).fill(&quot;Gold Ore&quot;));
//     } else if (coordinates[2] &lt;= -30 &amp;&amp; [2,3].includes(move)) {
//         appendOutput(&quot;You found Gold but need at least an Iron Pickaxe&quot;);
//     } else if (coordinates[2] &lt;= -20 &amp;&amp; [2,3,4].includes(move) &amp;&amp; mining_strength &gt;= 2) {
//         appendOutput(&quot;You mined three Iron Ore&quot;);
//         inventory.concat(new Array(3).fill(&quot;Iron Ore&quot;));
//     } else if (coordinates[2] &lt;= -20 &amp;&amp; [2,3,4].includes(move)) {
//         appendOutput(&quot;You found Iron but need at least a Cobblestone Pickaxe&quot;);
//     } else if (coordinates[2] &lt;= -10 &amp;&amp; [2,3,4,5].includes(move) &amp;&amp; mining_strength &gt;= 1) {
//         appendOutput(&quot;You mined three Coal&quot;)
//         inventory.concat(new Array(3).fill(&quot;Coal&quot;))
//     }  else if (coordinates[2] &lt;= -20 &amp;&amp; [2,3,4].includes(move)) {
//         appendOutput(&quot;You found Coal but need at least a Wooden Pickaxe&quot;);
//     }
// }

function mine() {
    const miningRules = [
        {
            depth: -50,
            moves: [1],
            requiredStrength: 3,
            reward: { item: &quot;Diamond&quot;, amount: 1 },
            failureMessage: &quot;You found a Diamond but need at least an Iron Pickaxe&quot;,
        },
        {
            depth: -30,
            moves: [2, 3],
            requiredStrength: 3,
            reward: { item: &quot;Gold Ore&quot;, amount: 3 },
            failureMessage: &quot;You found Gold but need at least an Iron Pickaxe&quot;,
        },
        {
            depth: -20,
            moves: [2, 3, 4],
            requiredStrength: 2,
            reward: { item: &quot;Iron Ore&quot;, amount: 3 },
            failureMessage: &quot;You found Iron but need at least a Cobblestone Pickaxe&quot;,
        },
        {
            depth: -10,
            moves: [2, 3, 4, 5],
            requiredStrength: 1,
            reward: { item: &quot;Coal&quot;, amount: 3 },
            failureMessage: &quot;You found Coal but need at least a Wooden Pickaxe&quot;,
        },
    ];

    const move = Math.floor(Math.random() * 5) + 1;

    for (const rule of miningRules) {
        if (coordinates[2] &lt;= rule.depth &amp;&amp; rule.moves.includes(move)) {
            if (mining_strength &gt;= rule.requiredStrength) {
                appendOutput(`You mined ${rule.reward.amount} ${rule.reward.item}(s)`);
                inventory.push(...new Array(rule.reward.amount).fill(rule.reward.item));
            } else {
                appendOutput(rule.failureMessage);
            }
            return; // Exit after the first match
        }
    }
}


const handleCoordinates = () =&gt; {
    if (coordinates[2] &lt;= -64) {
        appendOutput(&quot;You hit bedrock!&quot;)
    } else if (mining_strength &lt; 1 &amp;&amp; coordinates[2] &lt;= -10) { 
        appendOutput(&quot;You need a pickaxe to go deeper.&quot;)
    } else {
        coordinates[2] -= Math.floor(Math.random() * 16)
    }
}

const handleMine = (command) =&gt; {
    handleCoordinates()
    mine()
    switch (command.toLowerCase()) {
        case &quot;cobblestone&quot;:
            if (mining_strength === 0) {
                appendOutput(&quot;You need at least a wooden pickaxe for cobblestone.&quot;)
                break;
            }
            appendOutput(&quot;You collected three Cobblestone!&quot;);
            inventory.concat(new Array(3).fill(&quot;Cobblestone&quot;));
            break;
        case &quot;dirt&quot;:
            appendOutput(&quot;You collected three Dirt!&quot;);
            inventory.concat(new Array(3).fill(&quot;Dirt&quot;));
            break;
        case &quot;mine&quot;:
            appendOutput(&quot;You delve deeper&quot;)
            startMine()
            break;
        case &quot;exit&quot;:
            appendOutput(&quot;Leaving mine...&quot;);
            gameState = &quot;idle&quot;; // Return to the idle state
            coordinates[2] = 0
            break;
        default:
            appendOutput(&quot;Please specify Dirt or Cobblestone, or type &#39;exit&#39; to leave.&quot;);
    };
};

const startAttack = () =&gt; {
    currentMonster = monsters[Math.floor(Math.random() * monsters.length)];
    gameState = &quot;attack&quot;; // Transition to the explore state
    appendOutput(`You are now attacking the ${monster}. What do you do?`);
    appendOutput(&quot;You can attack, dodge, or flee.&quot;);
    appendOutput(`It has ${monster_health} HP.`);
};

const handleAttack = (command) =&gt; {
    const move = Math.floor(Math.random() * 3) + 1;
    switch (command.toLowerCase()) {
        case &quot;attack&quot;:
            switch (move){
                case 1:
                    appendOutput(`You attack, but the ${monster} dodges`);
                    appendOutput(&#39;and attacks first!&#39;);
                    player_health -= monster_attack_damage;
                    appendOutput(`You now have ${player_health} HP.`);
                    break;
                case 2:
                    appendOutput(`You attack the ${monster}, and your aim is true!`);
                    monster_health -= player_attack_damage;
                    appendOutput(`The ${monster} now has ${monster_health} HP.`);
                    break;
                case 3:
                    appendOutput(`You attack, but the ${monster} dodges!`);
                    break;
                default:
                    appendOutput(&quot;Something went wrong&quot;)
                };

    case &quot;dodge&quot;:
        switch (move){
            case 1:
                appendOutput(`You try dodging the ${monster}&#39;s attack,`);
                appendOutput(&#39;but it catches you anyway!&#39;);
                player_health -= monster_attack_damage;
                appendOutput(`You now have ${player_health} HP.`);
                break;
            case 2:
                appendOutput(`You dodge the ${monster}&#39;s attack!`);
                break;
            case 3:
                appendOutput(`You dodge the ${monster}&#39;s attack!`);
                break;
            default:
                appendOutput(&quot;Something went wrong&quot;)
            };
    case &quot;flee&quot;:  
        appendOutput(`You run away from the ${monster},`);
        gamestate=&quot;idle&quot;
        break;
    default:
        if (monster_health &lt;= 0) {
            console.clear();
            appendOutput(`You have defeated the ${monster}!`);
            appendOutput(&#39;You have earned 5 XP.&#39;);
            experience += 5;
            gamestate=&quot;idle&quot;
        };
        if (player_health &lt;= 0) {
            slain_by_monster = true;
            gameOver();
        };
    };
};

function gameOver() {
    appendOutput(&#39;Game over.&#39;)
    if (slain_by_monster) {
        appendOutput(`player_01 was slain by a ${monster}.`);
    };
    if (void_fall) {
        appendOutput(&#39;player_01 fell in the Void&#39;);
    };
    // Helper function to simulate sleep
    while (new Date().getTime() &lt; new Date().getTime() + 15000);
    location.reload();
};

function drop(array, stringToRemove) {
    const index = array.indexOf(stringToRemove);
    if (index !== -1) {
        array.splice(index, 1); // Remove the first occurrence of the string
    }
    return array;
    }

const startSmelt = () =&gt; {
    if (!inventory.includes(&#39;Planks&#39;) &amp;&amp; !inventory.includes(&#39;Coal&#39;)) {
        appendOutput(&#39;You need Planks or Coal.&#39;);
        return;
    };
    gameState = &quot;smelt&quot;; // Transition to the explore state
    appendOutput(`Would you like to smelt Iron Ore or Gold Ore? (or exit)`);
};

const handleSmelt = (command) =&gt; {
    switch (command.toLowerCase()) {
        case &quot;gold&quot;:
        case &quot;gold ore&quot;:
            inventory  = drop(inventory, &#39;Gold Ore&#39;);
            if (inventory.includes(&#39;Planks&#39;)) {
                inventory  = drop(inventory, &#39;Planks&#39;);
            } else if (inventory.includes(&#39;Coal&#39;)) {
                inventory  = drop(inventory, &#39;Coal&#39;);
            } else {
                appendOutput(&#39;You cannot smelt that.&#39;);
                return;
            }
            inventory.push(&#39;Gold Ingot&#39;);
            appendOutput(&#39;You smelted Gold!&#39;);
            break;
        case &quot;iron&quot;:
        case &quot;iron ore&quot;:
            inventory  = drop(inventory, &#39;Iron Ore&#39;);
            if (inventory.includes(&#39;Planks&#39;)) {
                inventory  = drop(inventory, &#39;Planks&#39;);
            } else if (inventory.includes(&#39;Coal&#39;)) {
                inventory  = drop(inventory, &#39;Coal&#39;);
            } else {
                appendOutput(&#39;You cannot smelt that.&#39;);
                return;
            }
            inventory.push(&#39;Iron Ingot&#39;);
            appendOutput(&#39;You smelted Iron!&#39;);
            break;
        case &quot;exit&quot;:
            gameState = &quot;idle&quot;
            appendOutput(&quot;You exited smelting&quot;)
            break;
        defualt:
            appendOutput(&quot;Something went wrong&quot;)
            gameState = &quot;idle&quot;
        };
    };

const startCraft  = () =&gt; {
    appendOutput(&quot;Would you like to craft a(n) wooden/cobblestone/iron/gold pickaxe/sword? (or exit)&quot;)
    gameState = &quot;craft&quot;
}

function craft(recipe) {
    if (!recipe.every(item =&gt; inventory.includes(item))) {
        appendOutput(&quot;You need materials.&quot;)
        return;
    } else {
        for (let item of recipe) {
            inventory = drop(inventory, item)
        }
    }
}


const handleCraft = (command) =&gt; {
    item = toTitleCase(command)
    if (item === &quot;Exit&quot;) {
        appendOutput(&quot;You left the crafting.&quot;)
        gameState = &quot;idle&quot;
        return;
    } else if (!Object.keys(items).includes(item)) {
        appendOutput(&quot;That&#39;s not an item&quot;)
        return;
    } else {
        recipe = items[item][&quot;recipe&quot;]
        craft(recipe)
        inventory.push(item)
        appendOutput(`You crafted ${item}`)
        return;
    }
}

const handleCommand = (command) =&gt; {
    appendOutput(`&#92;n&#92;n&#92;nCoordinates: ${coordinates}`)
    appendOutput(`HP: ${player_health}`)
    switch (gameState) {
        case &quot;explore&quot;:
            handleExplore(command); // Handle commands specific to the explore state
            return;
        case &quot;mine&quot;:
            handleMine(command);
            return;
        case &quot;attack&quot;:
            handleAttack(command);
            return;
        case &quot;smelt&quot;:
            handleSmelt(command);
            return;
        case &quot;craft&quot;:
            handleCraft(command);
            return;
        case &quot;equip&quot;:
            handleEquip(command)
            return;
        default:
            break;
            // appendOutput(&quot;Would you like to explore, mine, or attack?&quot;);
    }

    switch (command.toLowerCase()) {
        case &quot;explore&quot;:
            startExplore();
            break;
        case &quot;mine&quot;:
            startMine();
            break;
        case &quot;attack&quot;:
            startAttack();
            break;
        case &quot;inventory&quot;:
            appendOutput(inventory.toString());
            break;
        case &quot;smelt&quot;:
            startSmelt();
            break;
        case &quot;craft&quot;:
            startCraft();
            break;
        case &quot;equip&quot;:
            startEquip();
            break;
        case &quot;help&quot;:
            appendOutput(&quot;Commands: explore, mine, attack, smelt, inventory, craft, equip, &amp; help.&quot;);
            break;
        default:
            appendOutput(&quot;I don&#39;t understand that command.&quot;);
    }
};

input.addEventListener(&quot;keydown&quot;, (event) =&gt; {
    if (event.key === &quot;Enter&quot;) {
        const command = input.value.trim();
        if (command) {
            appendOutput(`&gt; ${command}`);
            handleCommand(command);
            input.value = &quot;&quot;; // Clear the input field
        }
    }
});
     &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</content>
  </entry>
  <entry>
    <title>khovanov homology talk</title>
    <link href="https://example.com/eleventy-base-blog/blog/khovanov/" />
    <updated>2024-06-14T00:00:00Z</updated>
    <id>https://example.com/eleventy-base-blog/blog/khovanov/</id>
    <content type="html">&lt;p&gt;This is an 8-minute presentation I gave. It was my final project for an undergraduate &quot;writing intensive&quot; course on knot theory.
&lt;/p&gt;

&lt;iframe src=&quot;https://drive.google.com/file/d/1Oh1c7XfyRXWoFpEQD2pp1W3oxp1tf_C9/preview&quot; width=&quot;640&quot; height=&quot;480&quot; allow=&quot;autoplay&quot;&gt;&lt;/iframe&gt;</content>
  </entry>
  <entry>
    <title>cohomology ring of n-sphere</title>
    <link href="https://example.com/eleventy-base-blog/blog/cohomologysphere/" />
    <updated>2024-05-30T00:00:00Z</updated>
    <id>https://example.com/eleventy-base-blog/blog/cohomologysphere/</id>
    <content type="html">&lt;script type=&quot;text/x-mathjax-config&quot;&gt;
    MathJax.Hub.Config({
      jax: [&quot;input/TeX&quot;, &quot;output/HTML-CSS&quot;],
      extensions: [&quot;tex2jax.js&quot;],
      &quot;HTML-CSS&quot;: { preferredFont: &quot;TeX&quot;, availableFonts: [&quot;STIX&quot;,&quot;TeX&quot;] },
      tex2jax: { inlineMath: [ [&quot;$&quot;, &quot;$&quot;], [&quot;&#92;&#92;(&quot;,&quot;&#92;&#92;)&quot;] ], displayMath: [ [&quot;$$&quot;,&quot;$$&quot;], [&quot;&#92;&#92;[&quot;, &quot;&#92;&#92;]&quot;] ], processEscapes: true, ignoreClass: &quot;tex2jax_ignore|dno&quot; },
      TeX: { noUndefined: { attributes: { mathcolor: &quot;red&quot;, mathbackground: &quot;#FFEEEE&quot;, mathsize: &quot;90%&quot; } } },
      messageStyle: &quot;none&quot;
    });
    &lt;/script&gt;    
    &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js&quot;&gt;&lt;/script&gt;
    &lt;p&gt;
        Differential forms and holes in a space are related through cohomology, but the direct measure of holes is homology. In simplicial homology, a space is decomposed into simplices, and chain groups &#92;(C_k(X)&#92;) are formal linear combinations of &#92;(k&#92;)-simplices. The boundary operator &#92;(&#92;partial&#92;) maps a simplex to its boundary, an alternating sum of its faces, satisfying &#92;(&#92;partial^2 = 0&#92;) due to sign cancellations. Cycles (elements killed by &#92;(&#92;partial&#92;)) represent loops or higher-dimensional analogs, while boundaries (images of &#92;(&#92;partial&#92;)) are loops that bound filled regions. Homology &#92;(H_k(X)&#92;) measures holes by quotienting cycles by boundaries, capturing loops that aren’t filled in.

Cohomology, on the other hand, dualizes this construction. Instead of chains, cohomology uses cochains &#92;(C^k = &#92;text{Hom}(C_k, &#92;mathbb{Z})&#92;), with a coboundary operator increasing dimension. Intuitively, cohomology measures how forms can detect holes. For instance, a closed form (cocycle) that isn’t exact (coboundary) corresponds to a hole. This duality is formalized in theorems like Poincaré duality, which relates &#92;(k&#92;)-chains to &#92;((n-k)&#92;)-cochains via intersection pairing, and the Universal Coefficient Theorem, which connects homology and cohomology over different coefficient rings.

In de Rham cohomology, differential forms are used as cochains, with closed forms representing cocycles and exact forms representing coboundaries. This theory detects holes similarly to simplicial cohomology but uses smooth structures. For example, the space &#92;(&#92;Omega_n(X)&#92;) of differential &#92;(n&#92;)-forms on &#92;(X&#92;) has that closed forms in &#92;(&#92;Omega_n(X)&#92;) detect holes via Stokes&#39; theorem, which ensures that integrals of closed forms over cycles are invariant under homotopy. If two paths yield different integrals for a closed form, they cannot be deformed into each other, indicating a &quot;hole.&quot; This idea is formalized by the de Rham map, &#92;(&#92;Omega_n(X) &#92;to &#92;text{Hom}(C_n(X), &#92;mathbb{R})&#92;), sending a form &#92;(&#92;omega&#92;) to the functional &#92;(&#92;sigma &#92;mapsto &#92;int_&#92;sigma &#92;omega&#92;). Stokes&#39; theorem ensures this is a chain map, and the de Rham theorem shows it induces an isomorphism between de Rham cohomology and singular cohomology, linking differential forms to the intuitive notion of holes. However, coefficients matter: de Rham cohomology with &#92;(&#92;mathbb{R}&#92;) coefficients misses torsion phenomena, like in &#92;(&#92;mathbb{R}P^2&#92;), where a loop traversed twice bounds a disk, but not once. Thus, while differential forms and holes are linked through cohomology, the choice of coefficients and theory determines what geometric or topological features are visible, giving the need for the Universal Coefficient Theorem.
    &lt;/p&gt;
    &lt;p&gt;The above is based on &lt;a href=&quot;https://math.stackexchange.com/a/3635358/1098426&quot;&gt;this&lt;/a&gt; MSE post&lt;/p&gt;
    
    &lt;p&gt;Every continuous map &#92;(f: X &#92;to Y&#92;) induces a homomorphism from the cohomology ring of &#92;(Y&#92;) to that of &#92;(X&#92;), limiting the possible maps between spaces. Unlike more complex invariants like homotopy groups, singular cohomology is often computable for spaces of interest. The construction begins with the singular chain complex, a sequence of free abelian groups &#92;(C_i&#92;) generated by continuous maps from the standard &#92;(i&#92;)-simplex to &#92;(X&#92;), connected by boundary homomorphisms &#92;(&#92;partial_i&#92;). The singular homology of &#92;(X&#92;) is the homology of this complex. To define cohomology, one fixes an abelian group &#92;(A&#92;) and &quot;dualizes the chain complex, replacing &#92;(C_i&#92;) with &#92;(C_i^* = &#92;text{Hom}(C_i, A)&#92;)&quot;...&lt;/p&gt;
    
    &lt;p&gt;... e.g. consider the chain complex &#92;(C_*&#92;) with &#92;(C_0 = &#92;mathbb{Z}&#92;), &#92;(C_1 = &#92;mathbb{Z}&#92;), and &#92;(C_i = 0&#92;) for &#92;(i &#92;neq 0, 1&#92;), connected by the boundary map &#92;(&#92;partial_1: C_1 &#92;to C_0&#92;) defined by &#92;(&#92;partial_1(n) = 2n&#92;). To dualize this complex, replace each &#92;(C_i&#92;) with &#92;(C_i^* = &#92;text{Hom}(C_i, A)&#92;), where &#92;(A&#92;) is an abelian group, say &#92;(A = &#92;mathbb{Z}&#92;). Here, &#92;(C_0^* = &#92;text{Hom}(&#92;mathbb{Z}, &#92;mathbb{Z}) &#92;simeq &#92;mathbb{Z}&#92;) and &#92;(C_1^* = &#92;text{Hom}(&#92;mathbb{Z}, &#92;mathbb{Z}) &#92;simeq &#92;mathbb{Z}&#92;), with the dual map &#92;(d_0: C_0^* &#92;to C_1^*&#92;) defined by &#92;(d_0(f)(m) = f(&#92;partial_1(m)) = f(2m)&#92;). This dual map &#92;(d_0&#92;) effectively &quot;reverses the arrows&quot; of the original boundary map...&lt;/p&gt;
    
    &lt;p&gt;...and replacing &#92;(&#92;partial_i&#92;) with its dual &#92;(d_{i-1}: C_{i-1}^* &#92;to C_i^*&#92;). This reversal of arrows yields a cochain complex, and the &#92;(i&#92;)-th cohomology group &#92;(H^i(X, A)&#92;) is defined as &#92;(&#92;text{ker}(d_i) / &#92;text{im}(d_{i-1})&#92;). Elements of &#92;(C_i^*&#92;) are called &#92;(i&#92;)-cochains, while those in &#92;(&#92;text{ker}(d_i)&#92;) and &#92;(&#92;text{im}(d_{i-1})&#92;) are cocycles and coboundaries, respectively. The cohomology classes, represented by equivalence classes of cocycles, form the cohomology groups, which vanish for negative &#92;(i&#92;).&lt;/p&gt;



    &lt;p&gt;
        In singular cohomology, the cup product defines a multiplication on the cohomology ring &#92;(H^*(X)&#92;) of a topological space &#92;(X&#92;). It is constructed by defining a product on cochains: if &#92;(&#92;alpha^p&#92;) is a &#92;(p&#92;)-cochain and &#92;(&#92;beta^q&#92;) is a &#92;(q&#92;)-cochain, their cup product &#92;(&#92;alpha^p &#92;smile &#92;beta^q&#92;) is a &#92;((p+q)&#92;)-cochain given by &#92;((&#92;alpha^p &#92;smile &#92;beta^q)(&#92;sigma) = &#92;alpha^p(&#92;sigma &#92;circ &#92;iota_{0,1,...,p}) &#92;cdot &#92;beta^q(&#92;sigma &#92;circ &#92;iota_{p,p+1,...,p+q})&#92;), where &#92;(&#92;sigma&#92;) is a singular &#92;((p+q)&#92;)-simplex and &#92;(&#92;iota_S&#92;) embeds the simplex spanned by &#92;(S&#92;) into the &#92;((p+q)&#92;)-simplex. Informally, &#92;(&#92;sigma &#92;circ &#92;iota_{0,1,...,p}&#92;) represents the front &#92;(p&#92;)-face of &#92;(&#92;sigma&#92;), while &#92;(&#92;sigma &#92;circ &#92;iota_{p,p+1,...,p+q}&#92;) represents the back &#92;(q&#92;)-face. The coboundary of the cup product satisfies &#92;(&#92;delta(&#92;alpha^p &#92;smile &#92;beta^q) = &#92;delta&#92;alpha^p &#92;smile &#92;beta^q + (-1)^p (&#92;alpha^p &#92;smile &#92;delta&#92;beta^q)&#92;). This ensures that the cup product of two cocycles is a cocycle, and the product of a coboundary with a cocycle is a coboundary. The cup product thus induces a bilinear operation on cohomology, &#92;(H^p(X) &#92;times H^q(X) &#92;to H^{p+q}(X)&#92;), making &#92;(H^*(X)&#92;) a graded ring.
    &lt;/p&gt;
    &lt;p&gt;For how the cup product is dual to intersection for oriented minfolds, I recommend &lt;a href=&quot;https://math.berkeley.edu/~hutching/teach/215b-2011/cup.pdf&quot;&gt;this paper&lt;/a&gt; by Michael Hutchings
    &lt;/p&gt;
&lt;p&gt;For the &#92;(n&#92;)-sphere &#92;(S^n&#92;), we know that the only non-zero cohomology groups are &#92;(H^0(S^n, &#92;mathbb{Z}) &#92;simeq &#92;mathbb{Z}&#92;) and &#92;(H^n(S^n, &#92;mathbb{Z}) &#92;simeq &#92;mathbb{Z}&#92;)...&lt;/p&gt;

&lt;p&gt;...For the &#92;(n&#92;)-sphere &#92;(S^n&#92;), the only non-zero cohomology groups are &#92;(H^0(S^n, &#92;mathbb{Z}) &#92;simeq &#92;mathbb{Z}&#92;) and &#92;(H^n(S^n, &#92;mathbb{Z}) &#92;simeq &#92;mathbb{Z}&#92;) because &#92;(S^n&#92;) is a connected (it is NOT the union of two disjoint non-empty open sets), compact (every open cover has a finite subcover), orientable manifold. Now, the $n$-sphere is a closed oriented manifold so that we can use the Poincaré duality saying the $k$-cohomology group is isomorphic to the $n-k$-th homology group: $H^k (&#92;mathbb T^2) &#92;cong H_{n-k} (&#92;mathbb T^2)$. The group &#92;(H^0(S^n, &#92;mathbb{Z})&#92;) corresponds to the constant functions on &#92;(S^n&#92;), reflecting its connectedness as there is only one such function up to scaling,. And &#92;(H^n(S^n, &#92;mathbb{Z})&#92;) captures the top-dimensional cohomology, representing the orientation class of &#92;(S^n&#92;), e.g. (thanks to &lt;a href=&quot;https://math.stackexchange.com/a/1706944/1098426&quot;&gt;this&lt;/a&gt; and &lt;a href=&quot;https://math.stackexchange.com/a/1276703/1098426&quot;&gt;that&lt;/a&gt; MSE) for de Rham $H^n_{dR}(S^n)&#92;simeq &#92;mathbb{R}$ by the map $[&#92;omega]&#92;mapsto &#92;int_{S^n} &#92;omega$ where there is $&#92;eta$ a nowhere zero $n$-form on $S$ and we can say $C = &#92;int_S &#92;eta &#92;in &#92;mathbb R$. So for any $[&#92;omega] &#92;in H^n(S)$, see $D:= &#92;int_S &#92;omega$. This is nonzero. Then $[&#92;frac{D}{C} &#92;eta] = [&#92;omega]$ as 
    
    $$&#92;int_S &#92;frac DC &#92;eta = D = &#92;int_S &#92;omega . $$
    
And $&#92;frac DC &#92;eta$ is nowhere vanishing (thus an orientation). All other cohomology groups vanish because &#92;(S^n&#92;) has no &quot;holes&quot; in intermediate dimensions.

...&lt;/p&gt;

&lt;p&gt; ... The generator of &#92;(H^0&#92;) corresponds to the unit element of the ring, denoted as &#92;(1&#92;), since the cup product with &#92;(H^0&#92;) acts as the identity map on &#92;(H^k(X; &#92;mathbb{Z})&#92;). The generator of &#92;(H^n&#92;) is denoted as &#92;(x&#92;). The cup product structure is determined by the relations &#92;(1 &#92;smile 1 = 1&#92;), &#92;(1 &#92;smile x = x&#92;), &#92;(x &#92;smile 1 = x&#92;), and &#92;(x &#92;smile x = 0&#92;), where the last relation arises because &#92;(H^{2n}(S^n, &#92;mathbb{Z}) = 0&#92;). The cohomology ring &#92;(H^*(S^n; &#92;mathbb{Z})&#92;) is therefore the direct sum &#92;(H^0(S^n, &#92;mathbb{Z}) &#92;oplus H^n(S^n, &#92;mathbb{Z})&#92;), which can be expressed as &#92;(&#92;alpha_1 &#92;cdot 1 &#92;oplus &#92;alpha_2 &#92;cdot x&#92;) for integers &#92;(&#92;alpha_1, &#92;alpha_2&#92;). This ring is abstractly isomorphic to the polynomial ring &#92;(&#92;mathbb{Z}[x]/(x^2)&#92;), where &#92;(x&#92;) represents the generator of &#92;(H^n(S^n, &#92;mathbb{Z})&#92;). A similar analysis applies to the real projective plane &#92;(&#92;mathbb{R} P^2&#92;), whose cohomology ring is &#92;(&#92;mathbb{Z}[x]/(2x, x^2)&#92;), with &#92;(x&#92;) being the generator of &#92;(H^2(&#92;mathbb{R} P^2, &#92;mathbb{Z})&#92;). Here, the relations &#92;(2x = 0&#92;) and &#92;(x^2 = 0&#92;) reflect the torsion in the cohomology groups and the vanishing of the cup product in higher degrees, respectively.&lt;/p&gt;

&lt;p&gt;The above note expands on &lt;a href=&quot;https://math.stackexchange.com/a/38618/1098426&quot;&gt;this&lt;/a&gt; MSE post.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>field extension practice</title>
    <link href="https://example.com/eleventy-base-blog/blog/field-extension-practice/" />
    <updated>2024-05-24T00:00:00Z</updated>
    <id>https://example.com/eleventy-base-blog/blog/field-extension-practice/</id>
    <content type="html">&lt;script src=&quot;https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
  &lt;h4 id=&quot;1-lecture-exercise-for-reader&quot;&gt;(1) Lecture Exercise for Reader&lt;/h4&gt;
&lt;p&gt;To show that &lt;span class=&quot;math inline&quot;&gt;&#92;(F / &#92;{0&#92;} &#92;cong F&#92;)&lt;/span&gt;,
    we need to establish an isomorphism between the quotient ring &lt;span class=&quot;math inline&quot;&gt;&#92;(F / &#92;{0&#92;}&#92;)&lt;/span&gt; and the field &lt;span class=&quot;math inline&quot;&gt;&#92;(F&#92;)&lt;/span&gt;.&lt;/p&gt;
    &lt;p&gt;Let &lt;span class=&quot;math inline&quot;&gt;&#92;(F&#92;)&lt;/span&gt; be a field. &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;{0&#92;}&#92;)&lt;/span&gt; is the zero ideal in &lt;span class=&quot;math inline&quot;&gt;&#92;(F&#92;)&lt;/span&gt;.&lt;/p&gt;
    &lt;p&gt;The quotient ring &lt;span class=&quot;math inline&quot;&gt;&#92;(F / &#92;{0&#92;}&#92;)&lt;/span&gt; is
    constructed by partitioning &lt;span class=&quot;math inline&quot;&gt;&#92;(F&#92;)&lt;/span&gt; into
    cosets of the ideal &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;{0&#92;}&#92;)&lt;/span&gt;. Since
    &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;{0&#92;}&#92;)&lt;/span&gt; contains only the zero
    element, every element &lt;span class=&quot;math inline&quot;&gt;&#92;(a &#92;in F&#92;)&lt;/span&gt;
    forms a distinct coset &lt;span class=&quot;math inline&quot;&gt;&#92;(a +
    &#92;{0&#92;}&#92;)&lt;/span&gt;.&lt;/p&gt;
    &lt;p&gt;Each coset &lt;span class=&quot;math inline&quot;&gt;&#92;(a + &#92;{0&#92;}&#92;)&lt;/span&gt; is simply
    &lt;span class=&quot;math inline&quot;&gt;&#92;(a&#92;)&lt;/span&gt;. Hence, the set of cosets is just
    the set of elements of &lt;span class=&quot;math inline&quot;&gt;&#92;(F&#92;)&lt;/span&gt;.&lt;/p&gt;
    &lt;p&gt;The addition and multiplication operations on the cosets are defined
    as follows: &lt;span class=&quot;math display&quot;&gt;&#92;[(a + &#92;{0&#92;}) + (b + &#92;{0&#92;}) = (a
    + b) + &#92;{0&#92;}&#92;]&lt;/span&gt; &lt;span class=&quot;math display&quot;&gt;&#92;[(a + &#92;{0&#92;}) &#92;cdot (b
    + &#92;{0&#92;}) = (a &#92;cdot b) + &#92;{0&#92;}&#92;]&lt;/span&gt; Since &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;{0&#92;}&#92;)&lt;/span&gt; is the zero ideal, these operations
    reduce to: &lt;span class=&quot;math display&quot;&gt;&#92;[a + b + &#92;{0&#92;} = a + b&#92;]&lt;/span&gt;
    &lt;span class=&quot;math display&quot;&gt;&#92;[a &#92;cdot b + &#92;{0&#92;} = a &#92;cdot b&#92;]&lt;/span&gt;&lt;/p&gt;
    &lt;p&gt;Define the map &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;varphi: F / &#92;{0&#92;} &#92;to
    F&#92;)&lt;/span&gt; by &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;varphi(a + &#92;{0&#92;}) =
    a&#92;)&lt;/span&gt;. This map is well-defined because each coset &lt;span class=&quot;math inline&quot;&gt;&#92;(a + &#92;{0&#92;}&#92;)&lt;/span&gt; corresponds uniquely to &lt;span class=&quot;math inline&quot;&gt;&#92;(a&#92;)&lt;/span&gt;.&lt;/p&gt;
    &lt;p&gt;Check that &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;varphi&#92;)&lt;/span&gt; is a ring
    homomorphism: &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;varphi&#92;)&lt;/span&gt; is injective:
    If &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;varphi(a + &#92;{0&#92;}) = &#92;varphi(b +
    &#92;{0&#92;})&#92;)&lt;/span&gt;, then &lt;span class=&quot;math inline&quot;&gt;&#92;(a = b&#92;)&lt;/span&gt;. &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;varphi&#92;)&lt;/span&gt; is surjective: For any &lt;span class=&quot;math inline&quot;&gt;&#92;(a &#92;in F&#92;)&lt;/span&gt;, &lt;span class=&quot;math inline&quot;&gt;&#92;(a =
    &#92;varphi(a + &#92;{0&#92;})&#92;)&lt;/span&gt;.&lt;/p&gt;
    &lt;p&gt;Since &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;varphi&#92;)&lt;/span&gt; is a bijective
    homomorphism, it is an isomorphism. Therefore, &lt;span class=&quot;math inline&quot;&gt;&#92;(F / &#92;{0&#92;} &#92;cong F&#92;)&lt;/span&gt;.&lt;/p&gt;
    &lt;p&gt;Thus, we have shown that &lt;span class=&quot;math inline&quot;&gt;&#92;(F /
    &#92;{0&#92;}&#92;)&lt;/span&gt; is isomorphic to &lt;span class=&quot;math inline&quot;&gt;&#92;(F&#92;)&lt;/span&gt;.
    &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;square&#92;)&lt;/span&gt;&lt;/p&gt;
    &lt;h4 id=&quot;2-lecture-exercise-for-reader&quot;&gt;(2) Lecture Exercise for Reader&lt;/h4&gt;
    &lt;p&gt;(a) Want to show that &lt;span class=&quot;math inline&quot;&gt;&#92;(f = x^3 + 2x +
    1&#92;)&lt;/span&gt; is irreducible over &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;mathbb{Z}_3&#92;)&lt;/span&gt; and that &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;mathbb{Z}_3[x] / I&#92;)&lt;/span&gt; is a field of order
    27 containing a subfield isomorphic to &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;mathbb{Z}_3&#92;)&lt;/span&gt;. A polynomial of degree 3 is
    irreducible over &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;mathbb{Z}_3&#92;)&lt;/span&gt; if it
    has no roots in &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;mathbb{Z}_3&#92;)&lt;/span&gt; and
    cannot be factored into polynomials of lower degrees. To check for
    roots, evaluate &lt;span class=&quot;math inline&quot;&gt;&#92;(f(x) = x^3 + 2x + 1&#92;)&lt;/span&gt;
    at &lt;span class=&quot;math inline&quot;&gt;&#92;(x = 0, 1, 2&#92;)&lt;/span&gt; in &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;mathbb{Z}_3&#92;)&lt;/span&gt;. For &lt;span class=&quot;math inline&quot;&gt;&#92;(f(0) = 0^3 + 2 &#92;cdot 0 + 1 = 1&#92;)&lt;/span&gt;, &lt;span class=&quot;math inline&quot;&gt;&#92;(f(1) = 1^3 + 2 &#92;cdot 1 + 1 = 1 + 2 + 1 = 4 &#92;equiv
    1 &#92;pmod{3}&#92;)&lt;/span&gt;, and &lt;span class=&quot;math inline&quot;&gt;&#92;(f(2) = 2^3 + 2
    &#92;cdot 2 + 1 = 8 + 4 + 1 = 13 &#92;equiv 1 &#92;pmod{3}&#92;)&lt;/span&gt;, none of these
    are zero, so &lt;span class=&quot;math inline&quot;&gt;&#92;(f(x)&#92;)&lt;/span&gt; has no roots in
    &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;mathbb{Z}_3&#92;)&lt;/span&gt;. Since &lt;span class=&quot;math inline&quot;&gt;&#92;(f(x)&#92;)&lt;/span&gt; has no roots, it cannot be factored
    into a product of a linear polynomial and a quadratic polynomial in
    &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;mathbb{Z}_3[x]&#92;)&lt;/span&gt;. Thus, &lt;span class=&quot;math inline&quot;&gt;&#92;(f(x)&#92;)&lt;/span&gt; is irreducible over &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;mathbb{Z}_3&#92;)&lt;/span&gt;. Since &lt;span class=&quot;math inline&quot;&gt;&#92;(f&#92;)&lt;/span&gt; is irreducible, the ideal &lt;span class=&quot;math inline&quot;&gt;&#92;((f)&#92;)&lt;/span&gt; is maximal, and the quotient ring
    &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;mathbb{Z}_3[x] / (f)&#92;)&lt;/span&gt; is a field.
    The polynomial &lt;span class=&quot;math inline&quot;&gt;&#92;(f(x)&#92;)&lt;/span&gt; is of degree 3,
    and the quotient ring &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;mathbb{Z}_3[x] /
    (f)&#92;)&lt;/span&gt; consists of equivalence classes of polynomials of degree
    less than 3: &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;mathbb{Z}_3[x] / (f) = &#92;{ a +
    bx + cx^2 + (f) &#92;mid a, b, c &#92;in &#92;mathbb{Z}_3 &#92;}&#92;)&lt;/span&gt;. There are
    &lt;span class=&quot;math inline&quot;&gt;&#92;(3^3 = 27&#92;)&lt;/span&gt; such equivalence classes,
    so &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;mathbb{Z}_3[x] / (f)&#92;)&lt;/span&gt; is a field
    of order 27. The field &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;mathbb{Z}_3&#92;)&lt;/span&gt;
    is naturally embedded in &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;mathbb{Z}_3[x] /
    (f)&#92;)&lt;/span&gt; as &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;{ a + (f) &#92;mid a &#92;in
    &#92;mathbb{Z}_3 &#92;}&#92;)&lt;/span&gt;, forming a subfield isomorphic to &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;mathbb{Z}_3&#92;)&lt;/span&gt;. &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;square&#92;)&lt;/span&gt;&lt;/p&gt;
    &lt;p&gt;(b) Want to show that &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;mathbb{Z}_3[x] /
    (f)&#92;)&lt;/span&gt; is a field extension of &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;overline{&#92;mathbb{Z}}_3&#92;)&lt;/span&gt; and is a
    3-dimensional vector space over &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;overline{&#92;mathbb{Z}}_3&#92;)&lt;/span&gt; with basis &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;{1 + (f), x + (f), x^2 + (f)&#92;}&#92;)&lt;/span&gt;. Let
    &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;overline{&#92;mathbb{Z}}_3 = &#92;{ 0 + (f), 1 +
    (f), 2 + (f) &#92;}&#92;)&lt;/span&gt;, which is isomorphic to &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;mathbb{Z}_3&#92;)&lt;/span&gt;. The field &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;mathbb{Z}_3[x] / (f)&#92;)&lt;/span&gt; contains &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;overline{&#92;mathbb{Z}}_3&#92;)&lt;/span&gt; as its subfield,
    making it a field extension. Any element of &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;mathbb{Z}_3[x] / (f)&#92;)&lt;/span&gt; can be written as
    &lt;span class=&quot;math inline&quot;&gt;&#92;(a + bx + cx^2 + (f)&#92;)&lt;/span&gt; where &lt;span class=&quot;math inline&quot;&gt;&#92;(a, b, c &#92;in &#92;mathbb{Z}_3&#92;)&lt;/span&gt;, and the
    elements &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;{1 + (f), x + (f), x^2 +
    (f)&#92;}&#92;)&lt;/span&gt; span &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;mathbb{Z}_3[x] /
    (f)&#92;)&lt;/span&gt;. To show that &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;{1 + (f), x +
    (f), x^2 + (f)&#92;}&#92;)&lt;/span&gt; is a basis, we need to establish linear
    independence and spanning. For linear independence, suppose &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;alpha (1 + (f)) + &#92;beta (x + (f)) + &#92;gamma (x^2 +
    (f)) = 0 + (f)&#92;)&lt;/span&gt;, which implies &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;alpha + &#92;beta x + &#92;gamma x^2 &#92;equiv 0
    &#92;pmod{f}&#92;)&lt;/span&gt;. Since &lt;span class=&quot;math inline&quot;&gt;&#92;(1, x, x^2&#92;)&lt;/span&gt;
    are linearly independent in &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;mathbb{Z}_3[x]&#92;)&lt;/span&gt; modulo &lt;span class=&quot;math inline&quot;&gt;&#92;(f(x)&#92;)&lt;/span&gt;, it follows that &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;alpha = &#92;beta = &#92;gamma = 0&#92;)&lt;/span&gt;. For
    spanning, any element in &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;mathbb{Z}_3[x] /
    (f)&#92;)&lt;/span&gt; can be expressed as a linear combination of &lt;span class=&quot;math inline&quot;&gt;&#92;(1, x, x^2&#92;)&lt;/span&gt; over &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;overline{&#92;mathbb{Z}}_3&#92;)&lt;/span&gt;. Thus, &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;mathbb{Z}_3[x] / (f)&#92;)&lt;/span&gt; is a 3-dimensional
    vector space over &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;overline{&#92;mathbb{Z}}_3&#92;)&lt;/span&gt; with basis &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;{1 + (f), x + (f), x^2 + (f)&#92;}&#92;)&lt;/span&gt;. &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;square&#92;)&lt;/span&gt;&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>widget: divisors and totient</title>
    <link href="https://example.com/eleventy-base-blog/blog/divisors-and-totient/" />
    <updated>2024-05-15T00:00:00Z</updated>
    <id>https://example.com/eleventy-base-blog/blog/divisors-and-totient/</id>
    <content type="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Divisors and Primes Finder&lt;/title&gt;
    &lt;script&gt;
        function findDivisorsAndPrimes() {
            // Get the user input value
            let inputValue = document.getElementById(&quot;numberInput&quot;).value;
            let number = parseInt(inputValue);

            // Validate if the input is a positive integer
            if (isNaN(number) || number &lt;= 0) {
                alert(&quot;Please enter a positive integer.&quot;);
                return;
            }

            // Function to find all divisors of a number
            function findDivisors(n) {
                let divisors = [];
                for (let i = 1; i &lt;= n; i++) {
                    if (n % i === 0) {
                        divisors.push(i);
                    }
                }
                return divisors;
            }

            // Function to check if a number is prime
            function isPrime(n) {
                if (n &lt;= 1) {
                    return false;
                }
                for (let i = 2; i &lt;= Math.sqrt(n); i++) {
                    if (n % i === 0) {
                        return false;
                    }
                }
                return true;
            }

            // Find divisors and primes less than the input number
            let divisors = findDivisors(number);
            let primes = [];
            for (let i = 2; i &lt; number; i++) {
                if (isPrime(i)) {
                    primes.push(i);
                }
            }

            // Display the results including length of lists
            let divisorsLength = divisors.length;
            let primesLength = primes.length;

            document.getElementById(&quot;divisors&quot;).textContent = `Divisors (${divisorsLength}): ` + divisors.join(&quot;, &quot;);
            document.getElementById(&quot;primes&quot;).textContent = `Primes less than ${number} (${primesLength}): ` + primes.join(&quot;, &quot;);
        }
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;p&gt;Find Divisors and Primes&lt;/p&gt;
    &lt;label for=&quot;numberInput&quot;&gt;Enter a positive integer:&lt;/label&gt;
    &lt;input type=&quot;text&quot; id=&quot;numberInput&quot;&gt;
    &lt;button onclick=&quot;findDivisorsAndPrimes()&quot;&gt;Find&lt;/button&gt;
    &lt;p id=&quot;divisors&quot;&gt;&lt;/p&gt;
    &lt;p id=&quot;primes&quot;&gt;&lt;/p&gt;
    &lt;script src=&quot;https://gist.github.com/ischmidls/0c3e254f052768d0df8d49e283478a56.js&quot;&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</content>
  </entry>
  <entry>
    <title>widget: quaternion template</title>
    <link href="https://example.com/eleventy-base-blog/blog/quaternion-multiplication/" />
    <updated>2024-05-10T00:00:00Z</updated>
    <id>https://example.com/eleventy-base-blog/blog/quaternion-multiplication/</id>
    <content type="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Quaternion Multiplication Formula&lt;/title&gt;
    &lt;script src=&quot;https://polyfill.io/v3/polyfill.min.js?features=es6&quot;&gt;&lt;/script&gt;
    &lt;script id=&quot;MathJax-script&quot; async=&quot;&quot; src=&quot;https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js&quot;&gt;&lt;/script&gt;
    &lt;script&gt;
        // Function to update the LaTeX formula based on input values
        function updateFormula() {
            // Get input values from the form
            let a1 = document.getElementById(&#39;a1&#39;).value;
            let b1 = document.getElementById(&#39;b1&#39;).value;
            let c1 = document.getElementById(&#39;c1&#39;).value;
            let d1 = document.getElementById(&#39;d1&#39;).value;
            let a2 = document.getElementById(&#39;a2&#39;).value;
            let b2 = document.getElementById(&#39;b2&#39;).value;
            let c2 = document.getElementById(&#39;c2&#39;).value;
            let d2 = document.getElementById(&#39;d2&#39;).value;

            // Construct the LaTeX formula with the input values
            let formula = `&#92;&#92;( &#92;&#92;begin{align*}`;
            formula += `(${a1}+${b1}i+${c1}j+${d1}k)&#92;&#92;odot (${a2}+${b2}i+${c2}j+${d2}k)`;
            formula += `&amp;= (${a1} &#92;&#92;cdot ${a2} - ${b1} &#92;&#92;cdot ${b2} - ${c1} &#92;&#92;cdot ${c2} - ${d1} &#92;&#92;cdot ${d2}) &#92;&#92;&#92;&#92;[8pt]`;
            formula += `&amp;&#92;&#92;quad + (${a1} &#92;&#92;cdot ${b2} + ${b1} &#92;&#92;cdot ${a2} + ${c1} &#92;&#92;cdot ${d2} - ${d1} &#92;&#92;cdot ${c2})i &#92;&#92;&#92;&#92;[8pt]`;
            formula += `&amp;&#92;&#92;quad + (${a1} &#92;&#92;cdot ${c2} + ${c1} &#92;&#92;cdot ${a2} + ${d1} &#92;&#92;cdot ${b2} - ${b1} &#92;&#92;cdot ${d2})j &#92;&#92;&#92;&#92;[8pt]`;
            formula += `&amp;&#92;&#92;quad + (${a1} &#92;&#92;cdot ${d2} + ${d1} &#92;&#92;cdot ${a2} + ${b1} &#92;&#92;cdot ${c2} - ${c1} &#92;&#92;cdot ${b2})k.`;
            formula += `&#92;&#92;end{align*} &#92;&#92;)`;

            // Set the content of the formula div
            document.getElementById(&#39;formula&#39;).innerHTML = formula;

            // Use MathJax to typeset the updated formula
            MathJax.typesetPromise().catch((err) =&gt; console.log(err));
        }
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h2 id=&quot;quaternion-multiplication-formula&quot;&gt;Quaternion Multiplication Formula&lt;/h2&gt;
  &lt;p&gt;&#92;begin{align*}
  (a_1+b_1i+c_1j+d_1k)&#92;odot (a_2+b_2i+c_2j+d_2k) &amp;= (a_1a_2 - b_1b_2 - c_1c_2 - d_1d_2)&#92;&#92;
  &amp;&#92;quad + (a_1b_2 + b_1a_2 + c_1d_2 - d_1c_2)i&#92;&#92;
  &amp;&#92;quad +  (a_1c_2 + c_1a_2 + d_1b_2 - b_1d_2)j &#92;&#92;
  &amp;&#92;quad+ (a_1d_2 + d_1a_2 + b_1c_2 - c_1b_2)k.
  &#92;end{align*}&lt;/p&gt;
    &lt;p&gt;Enter values for quaternion components to display the quaternion multiplication formula:&lt;/p&gt;
    &lt;form&gt;
        Quaternion 1 (a1, b1, c1, d1):&lt;br&gt;
        a1: &lt;input type=&quot;number&quot; id=&quot;a1&quot; value=&quot;1&quot;&gt;&lt;br&gt;
        b1: &lt;input type=&quot;number&quot; id=&quot;b1&quot; value=&quot;0&quot;&gt;&lt;br&gt;
        c1: &lt;input type=&quot;number&quot; id=&quot;c1&quot; value=&quot;0&quot;&gt;&lt;br&gt;
        d1: &lt;input type=&quot;number&quot; id=&quot;d1&quot; value=&quot;0&quot;&gt;&lt;br&gt;&lt;br&gt;
        Quaternion 2 (a2, b2, c2, d2):&lt;br&gt;
        a2: &lt;input type=&quot;number&quot; id=&quot;a2&quot; value=&quot;1&quot;&gt;&lt;br&gt;
        b2: &lt;input type=&quot;number&quot; id=&quot;b2&quot; value=&quot;0&quot;&gt;&lt;br&gt;
        c2: &lt;input type=&quot;number&quot; id=&quot;c2&quot; value=&quot;0&quot;&gt;&lt;br&gt;
        d2: &lt;input type=&quot;number&quot; id=&quot;d2&quot; value=&quot;0&quot;&gt;&lt;br&gt;&lt;br&gt;
        &lt;button type=&quot;button&quot; onclick=&quot;updateFormula()&quot;&gt;Update Formula&lt;/button&gt;
    &lt;/form&gt;
    &lt;p&gt;Quaternion Multiplication Formula:&lt;/p&gt;
    &lt;div id=&quot;formula&quot;&gt;&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</content>
  </entry>
  <entry>
    <title>widget: modular inverses</title>
    <link href="https://example.com/eleventy-base-blog/blog/modular-multiplicative-inverse/" />
    <updated>2024-05-09T00:00:00Z</updated>
    <id>https://example.com/eleventy-base-blog/blog/modular-multiplicative-inverse/</id>
    <content type="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Multiplicative Inverse Sequence&lt;/title&gt;
    &lt;script type=&quot;text/x-mathjax-config&quot;&gt;
        MathJax.Hub.Config({
          jax: [&quot;input/TeX&quot;, &quot;output/HTML-CSS&quot;],
          extensions: [&quot;tex2jax.js&quot;],
          &quot;HTML-CSS&quot;: { preferredFont: &quot;TeX&quot;, availableFonts: [&quot;STIX&quot;,&quot;TeX&quot;] },
          tex2jax: { inlineMath: [ [&quot;$&quot;, &quot;$&quot;], [&quot;&#92;&#92;(&quot;,&quot;&#92;&#92;)&quot;] ], displayMath: [ [&quot;$$&quot;,&quot;$$&quot;], [&quot;&#92;&#92;[&quot;, &quot;&#92;&#92;]&quot;] ], processEscapes: true, ignoreClass: &quot;tex2jax_ignore|dno&quot; },
          TeX: { noUndefined: { attributes: { mathcolor: &quot;red&quot;, mathbackground: &quot;#FFEEEE&quot;, mathsize: &quot;90%&quot; } } },
          messageStyle: &quot;none&quot;
        });
        &lt;/script&gt;    
        &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js&quot;&gt;&lt;/script&gt;
    
&lt;/head&gt;
&lt;body&gt;
    &lt;h1 id=&quot;multiplicative-inverse-sequence&quot;&gt;Multiplicative Inverse Sequence&lt;/h1&gt;
    &lt;p&gt;
       
       The modular multiplicative inverse of an integer $a $ modulo $m $ is an integer $y $ such that:
       $
       a &#92;cdot y &#92;equiv 1 &#92;pmod{m}
       $
       This inverse exists if and only if $a $ and $m $ are coprime (i.e., their greatest common divisor, or GCD, is 1).
       
For example:
       If $x = 2 $ and $m = 7 $, the sequence might look like:
         $
         [4, 2, 1, 4, 2, 1, &#92;dots]
         $
         This is because:
         $ 2^1 &#92;equiv 2 &#92;pmod{7} $, and the inverse of 2 modulo 7 is 4.
         $ 2^2 &#92;equiv 4 &#92;pmod{7} $, and the inverse of 4 modulo 7 is 2.
         $ 2^3 &#92;equiv 1 &#92;pmod{7} $, and the inverse of 1 modulo 7 is 1.
         The sequence repeats after this point.
       &lt;/p&gt;

    &lt;script&gt;
        function modInverse(a, m) {
            // validate inputs
            [a, m] = [Number(a), Number(m)]
            if (Number.isNaN(a) || Number.isNaN(m)) {
                return NaN; // invalid input
            }
            a = (a % m + m) % m;
            if (!a || m &lt; 2) {
                return NaN; // invalid input
            }
            // find the gcd
            const s = [];
            let b = m;
            while (b) {
                [a, b] = [b, a % b];
                s.push({a, b});
            }
            if (a !== 1) {
                return NaN; // inverse does not exist
            }
            // find the inverse
            let x = 1;
            let y = 0;
            for (let i = s.length - 2; i &gt;= 0; --i) {
                [x, y] = [y, x - y * Math.floor(s[i].a / s[i].b)];
            }
            return (y % m + m) % m;
        }

        // Function to calculate the sequence of multiplicative inverses
        function calculateInverseSequence(x, m) {
            const inverseSequence = [];
            let currentPower = x % m;
            let inverse = modInverse(currentPower, m);
            inverseSequence.push(inverse);

            const seen = new Set();
            seen.add(inverse);

            while (true) {
                currentPower = (currentPower * x) % m;
                inverse = modInverse(currentPower, m);

                if (seen.has(inverse)) {
                    break;
                }

                inverseSequence.push(inverse);
                seen.add(inverse);
            }

            return inverseSequence;
        }

        // Function to handle form submission
        function calculateAndDisplaySequence() {
            const numX = document.getElementById(&#39;numberX&#39;).value;
            const numM = document.getElementById(&#39;numberM&#39;).value;

            const x = Number(numX);
            const m = Number(numM);

            if (Number.isNaN(x) || Number.isNaN(m)) {
                alert(&#39;Please enter valid numbers for x and m.&#39;);
                return;
            }

            const inverseSequence = calculateInverseSequence(x, m);

            document.getElementById(&#39;output&#39;).innerText = `Inverse Sequence: ${inverseSequence.join(&#39;, &#39;)}`;
        }
    &lt;/script&gt;

    &lt;label for=&quot;numberX&quot;&gt;Enter a number (x):&lt;/label&gt;
    &lt;input type=&quot;number&quot; id=&quot;numberX&quot;&gt;&lt;br&gt;&lt;br&gt;
    &lt;label for=&quot;numberM&quot;&gt;Enter a modulus (m):&lt;/label&gt;
    &lt;input type=&quot;number&quot; id=&quot;numberM&quot;&gt;&lt;br&gt;&lt;br&gt;

    &lt;button onclick=&quot;calculateAndDisplaySequence()&quot;&gt;Calculate Inverse Sequence&lt;/button&gt;&lt;br&gt;&lt;br&gt;

    &lt;div id=&quot;output&quot;&gt;&lt;/div&gt;
    &lt;script src=&quot;https://gist.github.com/ischmidls/73b99e6f1f1f273e72442c1efc36efbd.js&quot;&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</content>
  </entry>
  <entry>
    <title>riemann sphere&#39;s field of fractions</title>
    <link href="https://example.com/eleventy-base-blog/blog/spherefractions/" />
    <updated>2024-04-30T00:00:00Z</updated>
    <id>https://example.com/eleventy-base-blog/blog/spherefractions/</id>
    <content type="html">&lt;head&gt;
    &lt;script type=&quot;text/x-mathjax-config&quot;&gt;
    MathJax.Hub.Config({
      jax: [&quot;input/TeX&quot;, &quot;output/HTML-CSS&quot;],
      extensions: [&quot;tex2jax.js&quot;],
      &quot;HTML-CSS&quot;: { preferredFont: &quot;TeX&quot;, availableFonts: [&quot;STIX&quot;,&quot;TeX&quot;] },
      tex2jax: { inlineMath: [ [&quot;$&quot;, &quot;$&quot;], [&quot;&#92;&#92;(&quot;,&quot;&#92;&#92;)&quot;] ], displayMath: [ [&quot;$$&quot;,&quot;$$&quot;], [&quot;&#92;&#92;[&quot;, &quot;&#92;&#92;]&quot;] ], processEscapes: true, ignoreClass: &quot;tex2jax_ignore|dno&quot; },
      TeX: { noUndefined: { attributes: { mathcolor: &quot;red&quot;, mathbackground: &quot;#FFEEEE&quot;, mathsize: &quot;90%&quot; } } },
      messageStyle: &quot;none&quot;
    });
    &lt;/script&gt;    
    &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
    &lt;body&gt;
  &lt;p&gt;
To prove that the global meromorphic functions on the Riemann sphere $&#92;mathbb{P}^1$ (the field of fractions for this variety) are the rational functions, we see:




The Riemann sphere $&#92;mathbb{P}^1$ is the complex projective line, which can be thought of as the complex plane $&#92;mathbb{C}$ compactified by adding a point at infinity, denoted $&#92;infty$. It is covered by two coordinate charts:
$U_0 = &#92;mathbb{P}^1 &#92;setminus &#92;{&#92;infty&#92;}$, with coordinate $z$ (the affine coordinate on $&#92;mathbb{C}$),
$U_1 = &#92;mathbb{P}^1 &#92;setminus &#92;{0&#92;}$, with coordinate $w = &#92;frac{1}{z}$ (the coordinate near $&#92;infty$).

A global meromorphic function on $&#92;mathbb{P}^1$ is a function that is holomorphic except for isolated poles on $&#92;mathbb{P}^1$.




A rational function is a ratio of two polynomials:
$
f(z) = &#92;frac{P(z)}{Q(z)},
$
where $P(z)$ and $Q(z)$ are polynomials in $z$. Such a function is meromorphic on $&#92;mathbb{C}$ because it is holomorphic except at the zeros of $Q(z)$, where it has poles. To check its behavior at $&#92;infty$, we use the coordinate $w = &#92;frac{1}{z}$:
$
f(z) = &#92;frac{P(z)}{Q(z)} = &#92;frac{P(1/w)}{Q(1/w)}.
$
This expression is meromorphic at $w = 0$ (i.e., $z = &#92;infty$) because $P(1/w)$ and $Q(1/w)$ are polynomials in $1/w$. Thus, rational functions are global meromorphic functions on $&#92;mathbb{P}^1$.




Now, let $f$ be a global meromorphic function on $&#92;mathbb{P}^1$. We show that $f$ must be a rational function.

On $U_0 = &#92;mathbb{C}$, $f$ is meromorphic, so it can be written as:
  $
  f(z) = &#92;frac{P(z)}{Q(z)},
  $
  where $P(z)$ and $Q(z)$ are polynomials, and $Q(z) &#92;neq 0$ except at the poles of $f$.

Near $&#92;infty$ (i.e., in $U_1$), $f$ must also be meromorphic. Using the coordinate $w = &#92;frac{1}{z}$, we write:
  $
  f(z) = f&#92;left(&#92;frac{1}{w}&#92;right) = &#92;frac{P(1/w)}{Q(1/w)}.
  $
  For this to be meromorphic at $w = 0$, the degrees of $P(z)$ and $Q(z)$ must satisfy $&#92;deg(P) &#92;leq &#92;deg(Q)$. Otherwise, $f(z)$ would have an essential singularity at $&#92;infty$, which is not allowed for a meromorphic function.

Thus, $f(z)$ is a ratio of polynomials with $&#92;deg(P) &#92;leq &#92;deg(Q)$, meaning $f(z)$ is a rational function.




Every global meromorphic function on $&#92;mathbb{P}^1$ is a rational function, and every rational function is a global meromorphic function on $&#92;mathbb{P}^1$. Therefore, the global meromorphic functions on $&#92;mathbb{P}^1$ are exactly the rational functions.


So, the global meromorphic functions on $ &#92;mathbb{P}^1 $ are exactly the rational functions.
&lt;/p&gt;
&lt;/body&gt;</content>
  </entry>
</feed>