<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet href="pretty-atom-feed.xsl" type="text/xsl"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
  <title>izak</title>
  <subtitle>sharing in learning</subtitle>
  <link href="https://ischmidls.github.io/feed/feed.xml" rel="self" />
  <link href="https://ischmidls.github.io/" />
  <updated>2025-02-14T00:00:00Z</updated>
  <id>https://ischmidls.github.io/</id>
  <author>
    <name>Izak Schmidlkofer</name>
  </author>
  <entry>
    <title>unknown variance of concave distribution</title>
    <link href="https://ischmidls.github.io/blog/unknownvariance/" />
    <updated>2025-02-14T00:00:00Z</updated>
    <id>https://ischmidls.github.io/blog/unknownvariance/</id>
    <content type="html">&lt;script type=&quot;text/x-mathjax-config&quot;&gt;
    MathJax.Hub.Config({
      jax: [&quot;input/TeX&quot;, &quot;output/HTML-CSS&quot;],
      extensions: [&quot;tex2jax.js&quot;],
      &quot;HTML-CSS&quot;: { preferredFont: &quot;TeX&quot;, availableFonts: [&quot;STIX&quot;,&quot;TeX&quot;] },
      tex2jax: { inlineMath: [ [&quot;$&quot;, &quot;$&quot;], [&quot;&#92;&#92;(&quot;,&quot;&#92;&#92;)&quot;] ], displayMath: [ [&quot;$$&quot;,&quot;$$&quot;], [&quot;&#92;&#92;[&quot;, &quot;&#92;&#92;]&quot;] ], processEscapes: true, ignoreClass: &quot;tex2jax_ignore|dno&quot; },
      TeX: { noUndefined: { attributes: { mathcolor: &quot;red&quot;, mathbackground: &quot;#FFEEEE&quot;, mathsize: &quot;90%&quot; } } },
      messageStyle: &quot;none&quot;
    });
    &lt;/script&gt;    
    &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;A strange fact that was not immediately obvious to me is that
    variance of a uniform distribution on &lt;span class=&quot;math inline&quot;&gt;&#92;([a,b]&#92;)&lt;/span&gt; can act as a conservative estimate
    for unknown variance &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;sigma^2&#92;)&lt;/span&gt; of
    many other distributions, namely convex distributions on &lt;span class=&quot;math inline&quot;&gt;&#92;([a,b]&#92;)&lt;/span&gt;.&lt;/p&gt;
    &lt;p&gt;The uniform distribution on &lt;span class=&quot;math inline&quot;&gt;&#92;([a,b]&#92;)&lt;/span&gt; has variance &lt;span class=&quot;math inline&quot;&gt;&#92;((b-a)^2/12&#92;)&lt;/span&gt;. For any concave distribution
    on &lt;span class=&quot;math inline&quot;&gt;&#92;([a,b]&#92;)&lt;/span&gt; (where the PDF lies above
    any line segment joining two points on its graph), the variance &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;sigma^2&#92;)&lt;/span&gt; satisfies &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;sigma^2 &#92;le (b-a)^2/12&#92;)&lt;/span&gt;. This holds
    because any concave PDF is unimodal, and on &lt;span class=&quot;math inline&quot;&gt;&#92;([0,1]&#92;)&lt;/span&gt;, the variance of a distribution
    with mean &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;mu&#92;)&lt;/span&gt; cannot exceed &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;mu(2-3&#92;mu)/3&#92;)&lt;/span&gt; for &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;mu &#92;le 1/2&#92;)&lt;/span&gt; or &lt;span class=&quot;math inline&quot;&gt;&#92;((1-&#92;mu)(3&#92;mu-1)/3&#92;)&lt;/span&gt; for &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;mu &#92;ge 1/2&#92;)&lt;/span&gt;, neither of which exceeds
    &lt;span class=&quot;math inline&quot;&gt;&#92;(1/12&#92;)&lt;/span&gt;. It takes some work to show
    this, which we’ll expand on shortly. But, rescaling to &lt;span class=&quot;math inline&quot;&gt;&#92;([a,b]&#92;)&lt;/span&gt; gives the general result. A tighter
    bound exists when the mean &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;mu&#92;)&lt;/span&gt; is
    known: for &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;mu &#92;le (a+b)/2&#92;)&lt;/span&gt;, &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;sigma^2 &#92;le (&#92;mu-a)(2b+a-3&#92;mu)/3&#92;)&lt;/span&gt;, with a
    symmetric expression for &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;mu &amp;gt;
    (a+b)/2&#92;)&lt;/span&gt;.&lt;/p&gt;
    &lt;p&gt;The supremum of the variance of unimodal distributions on &lt;span class=&quot;math inline&quot;&gt;&#92;([0,1]&#92;)&lt;/span&gt; with mean &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;mu&#92;)&lt;/span&gt; is &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;mu(2
    - 3&#92;mu)/3&#92;)&lt;/span&gt; for &lt;span class=&quot;math inline&quot;&gt;&#92;(0 &#92;le &#92;mu &#92;le
    1/2&#92;)&lt;/span&gt; or &lt;span class=&quot;math inline&quot;&gt;&#92;((1-&#92;mu)(3&#92;mu-1)/3&#92;)&lt;/span&gt;
    for &lt;span class=&quot;math inline&quot;&gt;&#92;(1/2 &#92;le &#92;mu &#92;le 1&#92;)&lt;/span&gt;. This
    supremum is achieved by a distribution that, while lacking a density
    function, can be considered “unimodal” in a generalized sense.
    Specifically, it has a point mass at &lt;span class=&quot;math inline&quot;&gt;&#92;(0&#92;)&lt;/span&gt; (when &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;mu
    &amp;lt; 1/2&#92;)&lt;/span&gt;) or at &lt;span class=&quot;math inline&quot;&gt;&#92;(1&#92;)&lt;/span&gt; (when
    &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;mu &amp;gt; 1/2&#92;)&lt;/span&gt;), with the rest of the
    distribution being uniform.&lt;/p&gt;
    &lt;p&gt;To derive this, we optimize the second moment &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;mathbb{E}[x^2]&#92;)&lt;/span&gt; of a unimodal
    distribution on &lt;span class=&quot;math inline&quot;&gt;&#92;([0,1]&#92;)&lt;/span&gt; under the
    constraints of normalization (&lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;int_0^1 f(x)
    &#92;, dx = 1&#92;)&lt;/span&gt;), mean &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;mathbb{E}&#92;)&lt;/span&gt; &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;int_0^1 x f(x) &#92;, dx = &#92;mu&#92;)&lt;/span&gt;, and
    unimodality (non-increasing density on either side of a mode &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;lambda&#92;)&lt;/span&gt;). The optimal distribution is
    piecewise constant, with density &lt;span class=&quot;math inline&quot;&gt;&#92;(a = (1 +
    &#92;lambda - 2&#92;mu)/&#92;lambda&#92;)&lt;/span&gt; on &lt;span class=&quot;math inline&quot;&gt;&#92;([0,&#92;lambda)&#92;)&lt;/span&gt; and &lt;span class=&quot;math inline&quot;&gt;&#92;(b = (2&#92;mu - &#92;lambda)/(1 - &#92;lambda)&#92;)&lt;/span&gt; on
    &lt;span class=&quot;math inline&quot;&gt;&#92;((&#92;lambda,1]&#92;)&lt;/span&gt;. The second moment
    &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;mathbb{E}[x^2] = &#92;frac{1}{3}(2&#92;mu + (2&#92;mu -
    1)&#92;lambda)&#92;)&lt;/span&gt; is linear in &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;lambda&#92;)&lt;/span&gt;, so it is maximized at &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;lambda = 0&#92;)&lt;/span&gt; (for &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;mu &amp;lt; 1/2&#92;)&lt;/span&gt;) or &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;lambda = 1&#92;)&lt;/span&gt; (for &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;mu &amp;gt; 1/2&#92;)&lt;/span&gt;). When &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;mu = 1/2&#92;)&lt;/span&gt;, the second moment is constant
    for all &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;lambda&#92;)&lt;/span&gt;.&lt;/p&gt;
    &lt;p&gt;In the limits, the optimal distribution approaches a uniform
    distribution with a point mass at &lt;span class=&quot;math inline&quot;&gt;&#92;(0&#92;)&lt;/span&gt;
    (for &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;mu &amp;lt; 1/2&#92;)&lt;/span&gt;) or at &lt;span class=&quot;math inline&quot;&gt;&#92;(1&#92;)&lt;/span&gt; (for &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;mu
    &amp;gt; 1/2&#92;)&lt;/span&gt;). These distributions, though not continuous, satisfy
    the unimodality condition and achieve the supremum of the variance &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;sigma^2_&#92;mu&#92;)&lt;/span&gt;.&lt;/p&gt;
    &lt;hr&gt;
    &lt;p&gt;Note: Recall how to find the variance of a uniform distribution X on &lt;span class=&quot;math inline&quot;&gt;&#92;([a,b]&#92;)&lt;/span&gt;.&lt;/p&gt;
    &lt;p&gt;We know variance is the difference of moments &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;mathbb{V}[X] = &#92;mathbb{E}[X^2] - (&#92;mathbb{E}
        [X])^2&#92;)&lt;/span&gt;.&lt;/p&gt;
        &lt;p&gt;As we see &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;mathbb{E} [X] =
        &#92;frac{1}{b-a}&#92;int_{[a,b]}x dx = &#92;frac{a+b}{2}&#92;)&lt;/span&gt;, and &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;mathbb{E} [X^2] = &#92;frac{1}{b-a}&#92;int_{[a,b]}x^2 dx
        = &#92;frac{b^3-a^3}{3(b-a)}=&#92;frac{a^2+ab+b^2}{3}&#92;)&lt;/span&gt;, we then see
        &lt;span class=&quot;math display&quot;&gt;&#92;[
        &#92;mathbb{V} [X] = &#92;frac{a^2+ab+b^2}{3} - &#92;frac{a^2+2ab+b^2}{4} =
        &#92;frac{a^2-2ab+b^2}{12} =&#92;frac{(b-a)^2}{12}
        &#92;]&lt;/span&gt;&lt;/p&gt;
    &lt;p&gt;Inspired by &lt;a href=&quot;https://stats.stackexchange.com/a/143981/422593&quot;&gt;this discussion&lt;/a&gt; and also &lt;a href=&quot;https://stats.stackexchange.com/a/143984/422593&quot;&gt;this discussion&lt;/a&gt;, with help from &lt;a href=&quot;https://math.stackexchange.com/a/728072/1098426&quot;&gt;this calculation&lt;/a&gt;&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>note: complex derivatives and matrices</title>
    <link href="https://ischmidls.github.io/blog/complexdiff/" />
    <updated>2025-02-12T00:00:00Z</updated>
    <id>https://ischmidls.github.io/blog/complexdiff/</id>
    <content type="html">&lt;script type=&quot;text/x-mathjax-config&quot;&gt;
    MathJax.Hub.Config({
      jax: [&quot;input/TeX&quot;, &quot;output/HTML-CSS&quot;],
      extensions: [&quot;tex2jax.js&quot;],
      &quot;HTML-CSS&quot;: { preferredFont: &quot;TeX&quot;, availableFonts: [&quot;STIX&quot;,&quot;TeX&quot;] },
      tex2jax: { inlineMath: [ [&quot;$&quot;, &quot;$&quot;], [&quot;&#92;&#92;(&quot;,&quot;&#92;&#92;)&quot;] ], displayMath: [ [&quot;$$&quot;,&quot;$$&quot;], [&quot;&#92;&#92;[&quot;, &quot;&#92;&#92;]&quot;] ], processEscapes: true, ignoreClass: &quot;tex2jax_ignore|dno&quot; },
      TeX: { noUndefined: { attributes: { mathcolor: &quot;red&quot;, mathbackground: &quot;#FFEEEE&quot;, mathsize: &quot;90%&quot; } } },
      messageStyle: &quot;none&quot;
    });
    &lt;/script&gt;    
    &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;For a complex function $ f(x + iy) = u(x, y) + iv(x, y) $, the Jacobian matrix is $&#92;mathbf{J} = &#92;begin{pmatrix} &#92;frac{&#92;partial u}{&#92;partial x} &amp; &#92;frac{&#92;partial v}{&#92;partial x} &#92;&#92; &#92;frac{&#92;partial u}{&#92;partial y} &amp; &#92;frac{&#92;partial v}{&#92;partial y} &#92;end{pmatrix}$.
&lt;/p&gt;

&lt;p&gt;For $ f $ to be complex differentiable, $ &#92;mathbf{J} $ must satisfy the Cauchy-Riemann equations $&#92;frac{&#92;partial u}{&#92;partial x} = &#92;frac{&#92;partial v}{&#92;partial y} &#92;quad &#92;text{and} &#92;quad &#92;frac{&#92;partial u}{&#92;partial y} = -&#92;frac{&#92;partial v}{&#92;partial x}.$
&lt;/p&gt;

&lt;p&gt;When these hold, $ &#92;mathbf{J} $ takes the form $&#92;mathbf{J} = &#92;begin{pmatrix} a &amp; -b &#92;&#92; b &amp; a &#92;end{pmatrix}$, where $ a = &#92;frac{&#92;partial u}{&#92;partial x} = &#92;frac{&#92;partial v}{&#92;partial y} $ and $ b = &#92;frac{&#92;partial v}{&#92;partial x} = -&#92;frac{&#92;partial u}{&#92;partial y} $. This matrix corresponds to the complex number $ a + bi $, reflecting the fact that the derivative of a complex function is itself a complex number. For example, for $ f(z) = z^2 $, the Jacobian is $&#92;mathbf{J} = &#92;begin{pmatrix} 2x &amp; 2y &#92;&#92; -2y &amp; 2x &#92;end{pmatrix}$, which corresponds to $ 2x + 2iy $.
&lt;/p&gt;

&lt;p&gt;The matrix representation of complex numbers as $ &#92;begin{pmatrix} a &amp; -b &#92;&#92; b &amp; a &#92;end{pmatrix} $ naturally follows from the geometric interpretation of complex multiplication and De Moivre&#39;s Theorem. A complex number $ z = a + bi $ can be written in polar form as $ z = r (&#92;cos &#92;theta + i &#92;sin &#92;theta) $, where $ r = &#92;sqrt{a^2 + b^2} $ is the magnitude and $ &#92;theta $ is the argument. Multiplication by $ z $ corresponds to scaling by $ r $ and rotating by $ &#92;theta $.
&lt;/p&gt;

&lt;p&gt;The rotation matrix for an angle $ &#92;theta $ is $&#92;begin{pmatrix} &#92;cos &#92;theta &amp; -&#92;sin &#92;theta &#92;&#92; &#92;sin &#92;theta &amp; &#92;cos &#92;theta &#92;end{pmatrix}.$
&lt;/p&gt;

&lt;p&gt;Multiplying this by the scaling factor $ r $ gives $r &#92;begin{pmatrix} &#92;cos &#92;theta &amp; -&#92;sin &#92;theta &#92;&#92; &#92;sin &#92;theta &amp; &#92;cos &#92;theta &#92;end{pmatrix} = &#92;begin{pmatrix} a &amp; -b &#92;&#92; b &amp; a &#92;end{pmatrix}$, where $ a = r &#92;cos &#92;theta $ and $ b = r &#92;sin &#92;theta $. This matches the matrix representation of $ z = a + bi $. Thus, the matrix form $ &#92;begin{pmatrix} a &amp; -b &#92;&#92; b &amp; a &#92;end{pmatrix} $ naturally encodes both scaling and rotation, reflecting the geometric action of complex multiplication as described by De Moivre&#39;s Theorem.
&lt;/p&gt;

&lt;p&gt;For example, the function $f(z) = z$ has $u(x, y) = x$ and $v(x, y) = y$, yielding the Jacobian $&#92;mathbf{J} = &#92;begin{pmatrix} 1 &amp; 0 &#92;&#92; 0 &amp; 1 &#92;end{pmatrix}$, corresponding to $1 + 0i$. &lt;/p&gt;
&lt;p&gt;For $f(z) = z^2$, we have $u(x, y) = x^2 - y^2$ and $v(x, y) = 2xy$, giving the Jacobian $&#92;mathbf{J} = &#92;begin{pmatrix} 2x &amp; 2y &#92;&#92; -2y &amp; 2x &#92;end{pmatrix}$, which corresponds to $2x + 2iy$. &lt;/p&gt;
&lt;p&gt;And for $f(z) = e^z$, we get $u(x, y) = e^x &#92;cos y$ and $v(x, y) = e^x &#92;sin y$, resulting in the Jacobian $&#92;mathbf{J} = &#92;begin{pmatrix} e^x &#92;cos y &amp; -e^x &#92;sin y &#92;&#92; e^x &#92;sin y &amp; e^x &#92;cos y &#92;end{pmatrix}$, corresponding to $e^z$.&lt;/p&gt;



&lt;p&gt;Inspired by &lt;a href=&quot;https://math.stackexchange.com/a/1448085/1098426&quot;&gt;this&lt;/a&gt; discussion.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>widget: matrix product</title>
    <link href="https://ischmidls.github.io/blog/matrixprod/" />
    <updated>2025-01-12T00:00:00Z</updated>
    <id>https://ischmidls.github.io/blog/matrixprod/</id>
    <content type="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;&lt;/head&gt;
&lt;body&gt;
  &lt;form onsubmit=&quot;return false;&quot;&gt;
    &lt;label for=&quot;matrix&quot;&gt;Enter matrix of any dimension to multiply with its transpose:&lt;/label&gt;
    &lt;input type=&quot;text&quot; name=&quot;matrix&quot; id=&quot;matrix&quot; placeholder=&quot;[[1,2],[3,4]]&quot;&gt;
    &lt;button type=&quot;button&quot; onclick=&quot;processMatrix()&quot;&gt;Submit&lt;/button&gt;
  &lt;/form&gt;
  
  &lt;div id=&quot;out&quot;&gt;&lt;/div&gt;
  
  &lt;script&gt;
    async function processMatrix() {
        try {
            let mat = JSON.parse(document.getElementById(&quot;matrix&quot;).value);

            let trans = mat[0].map((_, colIndex) =&gt;
                mat.map(row =&gt; row[colIndex])
            );

            let prod = await multiplyMatrices(mat, trans);

            let div = document.getElementById(&quot;out&quot;);
            div.innerHTML = JSON.stringify(prod);
        } catch (error) {
            console.error(&quot;Error processing the matrix:&quot;, error);
            document.getElementById(&quot;out&quot;).innerHTML = &quot;Error: &quot; + error.message;
        }
    }

    async function multiplyMatrices(A, B) {
      return new Promise((resolve, reject) =&gt; {
          setTimeout(() =&gt; {
              try {
                  const rowsA = A.length;
                  const colsA = A[0].length;
                  const rowsB = B.length;
                  const colsB = B[0].length;

                  if (colsA !== rowsB) {
                      throw new Error(&quot;Matrices cannot be multiplied: Incompatible dimensions.&quot;);
                  }

                  const resultMatrix = Array(rowsA).fill(null).map(() =&gt; Array(colsB).fill(0));

                  for (let i = 0; i &lt; rowsA; i++) {
                      for (let j = 0; j &lt; colsB; j++) {
                          for (let k = 0; k &lt; colsA; k++) {
                              resultMatrix[i][j] += A[i][k] * B[k][j];
                          }
                      }
                  }

                  resolve(resultMatrix);
              } catch (err) {
                  reject(err);
              }
          }, 0);
      });
    }
  &lt;/script&gt;
  &lt;hr&gt;
  &lt;script src=&quot;https://gist.github.com/ischmidls/f2897600ee3cb7ad4650eb9442f5bac6.js&quot;&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</content>
  </entry>
  <entry>
    <title>complete categories</title>
    <link href="https://ischmidls.github.io/blog/alllimits/" />
    <updated>2025-01-08T00:00:00Z</updated>
    <id>https://ischmidls.github.io/blog/alllimits/</id>
    <content type="html">&lt;script type=&quot;text/x-mathjax-config&quot;&gt;
    MathJax.Hub.Config({
      jax: [&quot;input/TeX&quot;, &quot;output/HTML-CSS&quot;],
      extensions: [&quot;tex2jax.js&quot;],
      &quot;HTML-CSS&quot;: { preferredFont: &quot;TeX&quot;, availableFonts: [&quot;STIX&quot;,&quot;TeX&quot;] },
      tex2jax: { inlineMath: [ [&quot;$&quot;, &quot;$&quot;], [&quot;&#92;&#92;(&quot;,&quot;&#92;&#92;)&quot;] ], displayMath: [ [&quot;$$&quot;,&quot;$$&quot;], [&quot;&#92;&#92;[&quot;, &quot;&#92;&#92;]&quot;] ], processEscapes: true, ignoreClass: &quot;tex2jax_ignore|dno&quot; },
      TeX: { noUndefined: { attributes: { mathcolor: &quot;red&quot;, mathbackground: &quot;#FFEEEE&quot;, mathsize: &quot;90%&quot; } } },
      messageStyle: &quot;none&quot;
    });
    &lt;/script&gt;    
    &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;To prove that the forgetful functor &#92;( U: &#92;text{Vect}_k &#92;to &#92;text{Set} &#92;) is monadic, we need to show that it satisfies the conditions of monadicity, as given by Beck&#39;s Monadicity Theorem. The forgetful functor &#92;( U &#92;) maps a vector space over a field &#92;( k &#92;) to its underlying set and maps linear transformations to their underlying functions. 
&lt;/p&gt;
&lt;p&gt; 
The forgetful functor &#92;( U: &#92;text{Vect}_k &#92;to &#92;text{Set} &#92;) has a left adjoint &#92;( F: &#92;text{Set} &#92;to &#92;text{Vect}_k &#92;), which is the free vector space functor. For a set &#92;( X &#92;), &#92;( F(X) &#92;) is the vector space whose basis is &#92;( X &#92;). The adjunction is given by the natural isomorphism:
&#92;[
&#92;text{Hom}_{&#92;text{Vect}_k}(F(X), V) &#92;simeq &#92;text{Hom}_{&#92;text{Set}}(X, U(V)),
&#92;]
where &#92;( V &#92;) is a vector space and &#92;( X &#92;) is a set. This shows that &#92;( U &#92;) is a right adjoint.
&lt;/p&gt;


&lt;p&gt; The adjunction &#92;( F &#92;dashv U &#92;) induces a monad &#92;( T = UF &#92;) on &#92;( &#92;text{Set} &#92;).
First, for a set &#92;( X &#92;), &#92;( T(X) = U(F(X)) &#92;) is the underlying set of the free vector space generated by &#92;( X &#92;). This is the set of formal linear combinations of elements of &#92;( X &#92;) with coefficients in &#92;( k &#92;).
Second, the unit &#92;( &#92;eta_X: X &#92;to T(X) &#92;) maps an element &#92;( x &#92;in X &#92;) to the corresponding basis vector in &#92;( F(X) &#92;).
Third, the multiplication &#92;( &#92;mu_X: T(T(X)) &#92;to T(X) &#92;) is the linear map that &quot;flattens&quot; formal linear combinations of formal linear combinations into formal linear combinations.
&lt;/p&gt;


&lt;p&gt; 
Beck&#39;s Monadicity Theorem states that a functor &#92;( U &#92;) is monadic if:
&#92;((1.)&#92;) &#92;( U &#92;) has a left adjoint, 
&#92;((2.)&#92;) &#92;( U &#92;) reflects isomorphisms, and 
&#92;((3.)&#92;) &#92;( U &#92;) preserves and reflects coequalizers of &#92;( U &#92;)-split pairs.
&lt;/p&gt;
&lt;p&gt; 
This third condition might be least familiar. Wikipedia&#39;s descriptions for this are not as subpar as they often are. First, (&#92;( U &#92;)-split pairs are those parallel pairs of morphisms in $&#92;text{Vect}_k$, which $U$ sends to pairs having a split coequalizer in $&#92;text{Set} $). Second, in the category of sets, the coequalizer of two functions &#92;( f, g: X &#92;to Y &#92;) is the quotient of &#92;( Y &#92;) by the smallest equivalence relation &#92;( &#92;sim &#92;) satisfying &#92;( f(x) &#92;sim g(x) &#92;) for every &#92;( x &#92;in X &#92;). For example, if &#92;( R &#92;) is an equivalence relation on a set &#92;( Y &#92;), and &#92;( r_1, r_2: R &#92;to Y &#92;) are the natural projections (where &#92;( R &#92;subseteq Y &#92;times Y &#92;)), then the coequalizer of &#92;( r_1 &#92;) and &#92;( r_2 &#92;) is the quotient set &#92;( Y / R &#92;). 
&lt;/p&gt;
&lt;p&gt; 
Before looking at &#92;( U &#92;)-split pair in &#92;( &#92;text{Vect}_k &#92;), let&#39;s verify the first two conditions.
&lt;/p&gt;
&lt;p&gt; 
For $(1)$, we already showed &#92;( U &#92;) has a left adjoint.
&lt;/p&gt;
&lt;p&gt; 
For $(2)$, a linear transformation &#92;( f: V &#92;to W &#92;) is an isomorphism in &#92;( &#92;text{Vect}_k &#92;) if and only if it is bijective. Since &#92;( U &#92;) maps &#92;( f &#92;) to its underlying function, &#92;( U(f) &#92;) is an isomorphism in &#92;( &#92;text{Set} &#92;) (i.e., a bijection) if and only if &#92;( f &#92;) is an isomorphism in &#92;( &#92;text{Vect}_k &#92;). Thus, &#92;( U &#92;) reflects isomorphisms.
&lt;/p&gt;
&lt;p&gt; 
For $(3)$, a &#92;( U &#92;)-split pair in &#92;( &#92;text{Vect}_k &#92;) consists of linear maps &#92;( f, g: V &#92;to W &#92;) such that there exist set-theoretic maps &#92;( h: U(W) &#92;to U(V) &#92;) and &#92;( k: U(W) &#92;to U(W) &#92;) making &#92;( U(f), U(g) &#92;) a split pair in &#92;( &#92;text{Set} &#92;). The coequalizer of &#92;( f, g &#92;) in &#92;( &#92;text{Vect}_k &#92;) is the quotient space &#92;( W / &#92;text{Im}(f - g) &#92;), and &#92;( U &#92;) maps this to the set-theoretic coequalizer of &#92;( U(f), U(g) &#92;) in &#92;( &#92;text{Set} &#92;). Since &#92;( U &#92;) is a right adjoint, it preserves coequalizers of &#92;( U &#92;)-split pairs. Moreover, because &#92;( U &#92;) reflects isomorphisms and the splitting conditions ensure that the coequalizer in &#92;( &#92;text{Set} &#92;) lifts uniquely to &#92;( &#92;text{Vect}_k &#92;), &#92;( U &#92;) also reflects coequalizers of &#92;( U &#92;)-split pairs. Thus, &#92;( U &#92;) preserves and reflects such coequalizers.
&lt;/p&gt;

&lt;!-- https://q.uiver.app/#q=WzAsNCxbMCwwLCJWIl0sWzEsMCwiVyJdLFsyLDAsIlcgLyBcXHRleHR7SW19KGYgLSBnKSJdLFsyLDEsIloiXSxbMCwxLCJmIiwwLHsib2Zmc2V0IjotMX1dLFsxLDIsIlxccGkiXSxbMSwzLCJcXHBpJyIsMl0sWzIsMywiXFxleGlzdHMgISBcXCwgaCIsMCx7InN0eWxlIjp7ImJvZHkiOnsibmFtZSI6ImRhc2hlZCJ9fX1dLFswLDEsImciLDIseyJvZmZzZXQiOjF9XV0= --&gt;
&lt;iframe class=&quot;quiver-embed&quot; src=&quot;https://q.uiver.app/#q=WzAsNCxbMCwwLCJWIl0sWzEsMCwiVyJdLFsyLDAsIlcgLyBcXHRleHR7SW19KGYgLSBnKSJdLFsyLDEsIloiXSxbMCwxLCJmIiwwLHsib2Zmc2V0IjotMX1dLFsxLDIsIlxccGkiXSxbMSwzLCJcXHBpJyIsMl0sWzIsMywiXFxleGlzdHMgISBcXCwgaCIsMCx7InN0eWxlIjp7ImJvZHkiOnsibmFtZSI6ImRhc2hlZCJ9fX1dLFswLDEsImciLDIseyJvZmZzZXQiOjF9XV0=&amp;embed&quot; width=&quot;553&quot; height=&quot;304&quot; style=&quot;border-radius: 8px; border: none;&quot;&gt;&lt;/iframe&gt;
&lt;p&gt; 
In particular, in &#92;(&#92;text{Vect}_k&#92;), let &#92;(V&#92;) and &#92;(W&#92;) be vector spaces, and let &#92;(f, g: V &#92;to W&#92;) be linear maps. The coequalizer of &#92;(f&#92;) and &#92;(g&#92;) is the quotient space &#92;(W / &#92;text{Im}(f - g)&#92;), equipped with the canonical projection map &#92;(&#92;pi: W &#92;to W / &#92;text{Im}(f - g)&#92;). For any vector space &#92;(Z&#92;) and linear map &#92;(&#92;pi&#39;: W &#92;to Z&#92;) satisfying &#92;(&#92;pi&#39; &#92;circ f = &#92;pi&#39; &#92;circ g&#92;), there exists a unique linear map &#92;(h: W / &#92;text{Im}(f - g) &#92;to Z&#92;) induced by the universal property of the coequalizer, such that &#92;(&#92;pi&#39; = h &#92;circ &#92;pi&#92;). This universal property characterizes the coequalizer in &#92;(&#92;text{Vect}_k&#92;). 
&lt;/p&gt;
&lt;p&gt; 
As the forgetful functor &#92;( U: &#92;text{Vect}_k &#92;to &#92;text{Set} &#92;) satisfies all the conditions of Beck&#39;s Monadicity Theorem, it is monadic. This particularly means that &#92;( &#92;text{Vect}_k &#92;) is equivalent to the category of algebras over the monad &#92;( T = UF &#92;) on &#92;( &#92;text{Set} &#92;).
&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Now, the nice thing is that $&#92;text{Set}$ has all limits by design. Since the canoncial forgetful functor from $&#92;text{Vect}_k$ is monadic, we see $&#92;text{Vect}_k$ also has all limits.

  It remains to show that the category of chain complexes $ &#92;text{CH}(k) $ has all limits. We can do this analogously to how we showed $&#92;text{Vect}_k$ has all limits given $&#92;text{Set}$ has all limits.
  
  &lt;/p&gt;
  
  &lt;p&gt;To prove that the category of chain complexes $ &#92;text{CH}(k) $ is a reflective subcategory of a category of functors into $ &#92;text{Vect}_k $, we need to show that the inclusion functor $ i: &#92;text{CH}(k) &#92;to &#92;text{Fun}(&#92;mathcal{C}, &#92;text{Vect}_k) $ has a left adjoint. This left adjoint is called the reflector, and it provides a way to &quot;reflect&quot; objects from the larger category (functors into $ &#92;text{Vect}_k $) back into the subcategory $ &#92;text{CH}(k) $.&lt;/p&gt;&lt;p&gt;  Let $ &#92;text{Vect}_k $ be the category of vector spaces over a field $ k $.&lt;/p&gt;&lt;p&gt;  Let $ &#92;text{CH}(k) $ be the category of chain complexes of $ k $-vector spaces. Objects are sequences of vector spaces $ (C_n)_{n &#92;in &#92;mathbb{Z}} $ with differentials $ d_n: C_n &#92;to C_{n-1} $ such that $ d_{n-1} &#92;circ d_n = 0 $, and morphisms are chain maps.&lt;/p&gt;&lt;p&gt;  Let $ &#92;mathcal{C} $ be a small category, and let $ &#92;text{Fun}(&#92;mathcal{C}, &#92;text{Vect}_k) $ be the category of functors from $ &#92;mathcal{C} $ to $ &#92;text{Vect}_k $. Objects are functors $ F: &#92;mathcal{C} &#92;to &#92;text{Vect}_k $, and morphisms are natural transformations.&lt;/p&gt;&lt;p&gt;  Consider the category $ &#92;mathcal{C} = &#92;mathbb{Z} $, where $ &#92;mathbb{Z} $ is viewed as a poset category (with objects integers and a unique morphism $ n &#92;to m $ iff $ n &#92;geq m $).&lt;/p&gt;&lt;p&gt;  A functor $ F: &#92;mathbb{Z} &#92;to &#92;text{Vect}_k $ assigns a vector space $ F(n) $ to each integer $ n $ and a linear map $ F(n &#92;to m): F(n) &#92;to F(m) $ for each $ n &#92;geq m $.&lt;/p&gt;&lt;p&gt;  A chain complex $ (C_n, d_n) $ can be viewed as a functor $ F: &#92;mathbb{Z} &#92;to &#92;text{Vect}_k $, where $ F(n) = C_n $ and $ F(n &#92;to n-1) = d_n $, with the condition $ d_{n-1} &#92;circ d_n = 0 $.&lt;/p&gt;&lt;p&gt;   Thus, $ &#92;text{CH}(k) $ is a subcategory of $ &#92;text{Fun}(&#92;mathbb{Z}, &#92;text{Vect}_k) $.&lt;/p&gt;&lt;p&gt;  To show that $ &#92;text{CH}(k) $ is a reflective subcategory, we need to construct a left adjoint $ L: &#92;text{Fun}(&#92;mathbb{Z}, &#92;text{Vect}_k) &#92;to &#92;text{CH}(k) $ to the inclusion functor $ i: &#92;text{CH}(k) &#92;to &#92;text{Fun}(&#92;mathbb{Z}, &#92;text{Vect}_k) $.&lt;/p&gt;&lt;p&gt;  For a functor $ F &#92;in &#92;text{Fun}(&#92;mathbb{Z}, &#92;text{Vect}_k) $, define $ L(F) $ as the chain complex obtained by &quot;forcing&quot; the condition $ d_{n-1} &#92;circ d_n = 0 $.&lt;/p&gt;&lt;p&gt;To construct the chain complex $ L(F) $ from a functor $ F: &#92;mathbb{Z} &#92;to &#92;text{Vect}_k $, we start by defining $ L(F)_n = F(n) $ and the differential $ d_n = F(n &#92;to n-1) $. However, this does not automatically satisfy the chain complex condition $ d_{n-1} &#92;circ d_n = 0 $. To enforce this condition, we modify $ L(F)_n $ by taking the quotient of $ F(n) $ by the image of $ d_{n+1}: F(n+1) &#92;to F(n) $, particularly submodule generated by this image. This quotient ensures that the composition $ d_{n-1} &#92;circ d_n $ becomes zero, as the image of $ d_{n+1} $ is factored out. The resulting object $ L(F) $ is now a chain complex, as the differentials satisfy the required condition $ d_{n-1} &#92;circ d_n = 0 $. This process of quotienting effectively &quot;reflects&quot; the functor $ F $ into the subcategory of chain complexes.&lt;/p&gt;&lt;p&gt;  The reflector $ L $ is left adjoint to the inclusion functor $ i $. We see there is a natural isomorphism:&lt;/p&gt;&lt;p&gt;     $$&#92;text{Hom}_{&#92;text{CH}(k)}(L(F), C) &#92;simeq &#92;text{Hom}_{&#92;text{Fun}(&#92;mathbb{Z}, &#92;text{Vect}_k)}(F, i(C))$$&lt;/p&gt;&lt;p&gt;     for all $ F &#92;in &#92;text{Fun}(&#92;mathbb{Z}, &#92;text{Vect}_k) $ and $ C &#92;in &#92;text{CH}(k) $.&lt;/p&gt;&lt;p&gt;  This adjunction arises because $ L(F) $ is the &quot;best approximation&quot; of $ F $ as a chain complex, and morphisms from $ L(F) $ to $ C $ correspond naturally to morphisms from $ F $ to $ i(C) $.&lt;/p&gt;&lt;p&gt;  Since the inclusion functor $ i: &#92;text{CH}(k) &#92;to &#92;text{Fun}(&#92;mathbb{Z}, &#92;text{Vect}_k) $ has a left adjoint $ L $, the category $ &#92;text{CH}(k) $ is a reflective subcategory of $ &#92;text{Fun}(&#92;mathbb{Z}, &#92;text{Vect}_k) $.&lt;/p&gt;
  &lt;p&gt;A category where all limits exist is called a &quot;complete category&quot;.&lt;/p&gt;
  &lt;hr&gt;

  These notes were inspired by a remark in &lt;a href=&quot;https://youtu.be/5uI0uJpsEhI?si=f8G1Y0ylOOewxhhG&quot;&gt;this&lt;/a&gt; video.</content>
  </entry>
  <entry>
    <title>textcraft</title>
    <link href="https://ischmidls.github.io/blog/textcraft/" />
    <updated>2024-12-26T00:00:00Z</updated>
    <id>https://ischmidls.github.io/blog/textcraft/</id>
    <content type="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Minecraft Text Adventure&lt;/title&gt;
    &lt;style&gt;
        body {
            font-family: monospace;
            background-color: white;
            color: black;
            margin: 0;
            padding: 20px;
        }
        #output {
            white-space: pre-line;
            margin-bottom: 20px;
            max-height: 400px;
            overflow-y: auto;
        }
        #input {
            width: 100%;
            padding: 10px;
            font-family: monospace;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;output&quot;&gt;Welcome to text-based Minecraft! Type a command (or help) to begin...&lt;/div&gt;
    &lt;input id=&quot;input&quot; type=&quot;text&quot; placeholder=&quot;Enter your command here...&quot; autofocus=&quot;&quot;&gt;
    
     &lt;script&gt;
const output = document.getElementById(&quot;output&quot;);
const input = document.getElementById(&quot;input&quot;);

const biomes = [&#39;Forest Biome&#39;, &#39;Grasslands Biome&#39;, &#39;Desert Biome&#39;]; // Sample biomes
let inventory = [];
// add coordinates
let coordinates = [0,64,0];
const blocks = [&#39;Dirt&#39;, &#39;Cobblestone&#39;, &#39;Coal&#39;, &#39;Diamond&#39;];
const ores = [&#39;Iron Ore&#39;, &#39;Gold Ore&#39;];
const ingots = [&#39;Iron Ingot&#39;, &#39;Gold Ingot&#39;];
const monsters = [&#39;Zombie&#39;, &#39;Creeper&#39;, &#39;Enderman&#39;, &#39;Skeleton&#39;, &#39;Spider&#39;, &#39;Drowned&#39;, &#39;Stray&#39;];
const caves = [&#39;Dripstone Cavern&#39;, &#39;Lush Cave&#39;, &#39;Ravine&#39;, &#39;Cave&#39;, &#39;Abandoned Mineshaft&#39;, &#39;Dungeon&#39;];
let gameState = &quot;idle&quot;; // Track the current state of the game
let currentBiome = &quot;&quot;; // Store the biome during exploration
let experience = 0;
let monster_health = 20;
let player_attack_damage = 1;
let player_health = 20;
let monster_attack_damage = 5;
let void_fall = false;
let slain_by_monster = false;
let mining_strength = 0
const items = {
    &quot;Wooden Sword&quot;: {
        recipe: new Array(2).fill(&quot;Plank&quot;).concat(new Array(1).fill(&quot;Stick&quot;)),
        damage: 1,
        miningStrength: 0,
    },
    &quot;Wooden Pickaxe&quot;: {
        recipe: new Array(3).fill(&quot;Plank&quot;).concat(new Array(2).fill(&quot;Stick&quot;)),
        damage: 1,
        miningStrength: 1,
    },
    &quot;Cobblestone Sword&quot;: {
        recipe: new Array(2).fill(&quot;Cobblestone&quot;).concat(new Array(1).fill(&quot;Stick&quot;)),
        damage: 2,
        miningStrength: 0,
    },
    &quot;Cobblestone Pickaxe&quot;: {
        recipe: new Array(3).fill(&quot;Cobblestone&quot;).concat(new Array(2).fill(&quot;Stick&quot;)),
        damage: 2,
        miningStrength: 2,
    },
    &quot;Iron Sword&quot;: {
        recipe: new Array(2).fill(&quot;Iron&quot;).concat(new Array(1).fill(&quot;Stick&quot;)),
        damage: 3,
        miningStrength: 0,
    },
    &quot;Iron Pickaxe&quot;: {
        recipe: new Array(3).fill(&quot;Iron&quot;).concat(new Array(2).fill(&quot;Stick&quot;)),
        damage: 3,
        miningStrength: 3,
    },
    &quot;Gold Sword&quot;: {
        recipe: new Array(2).fill(&quot;Gold&quot;).concat(new Array(1).fill(&quot;Stick&quot;)),
        damage: 3,
        miningStrength: 0,
    },
    &quot;Gold Pickaxe&quot;: {
        recipe: new Array(3).fill(&quot;Gold&quot;).concat(new Array(2).fill(&quot;Stick&quot;)),
        damage: 3,
        miningStrength: 3,
    },
    &quot;Diamond Sword&quot;: {
        recipe: new Array(2).fill(&quot;Diamond&quot;).concat(new Array(1).fill(&quot;Stick&quot;)),
        damage: 3,
        miningStrength: 0,
    },
    &quot;Diamond Pickaxe&quot;: {
        recipe: new Array(3).fill(&quot;Diamond&quot;).concat(new Array(2).fill(&quot;Stick&quot;)),
        damage: 4,
        miningStrength: 4,
    },
};


const toTitleCase = (str) =&gt; {
    return str.replace(
        /&#92;w&#92;S*/g,
        text =&gt; text.charAt(0).toUpperCase() + text.substring(1).toLowerCase()
    );
}

const appendOutput = (text) =&gt; {
    output.textContent += `&#92;n${text}`;
    output.scrollTop = output.scrollHeight; // Scroll to bottom
};

const startEquip = () =&gt; {
    gameState = &quot;equip&quot;
    appendOutput(&quot;What would you like to equip? (or exit)&quot;)
}

const handleEquip = (command) =&gt; {
    const item = items[toTitleCase(command)];

    if (item) {
        // Update global variables based on the item&#39;s properties
        player_attack_damage = item.damage;
        mining_strength = item.miningStrength;
        appendOutput(
            `Equipped ${command}. Attack damage is now ${player_attack_damage}, and mining strength is ${mining_strength}.`
        );
    } else if (command.toLowerCase() === &quot;exit&quot;) {
        gameState = &quot;idle&quot;
        appendOutput(&quot;Exiting equip&quot;)
    } else {
        appendOutput(`Item &quot;${command}&quot; not found.`);
    }
            &quot;That&#39;s not an item?&quot;
    }


const startExplore = () =&gt; {
    currentBiome = biomes[Math.floor(Math.random() * biomes.length)];
    gameState = &quot;explore&quot;; // Transition to the explore state
    coordinates[0] += Math.floor(Math.random() * 64)
    coordinates[1] += Math.floor(Math.random() * 64)
    appendOutput(`You are now exploring the ${currentBiome}. What resource would you like to collect?`);
    appendOutput(&quot;You can collect seeds or wood from compatible biomes.&quot;);
    appendOutput(&quot;Type &#39;exit&#39; to leave or &#39;explore&#39; to keep exploring&#39;.&quot;);
};

const handleExplore = (command) =&gt; {
    switch (command.toLowerCase()) {
        case &quot;wood&quot;:
            if (currentBiome === &quot;Forest Biome&quot;) {
                appendOutput(&quot;You collected three wood and two sticks!&quot;);
                inventory.push(&quot;Wood&quot;, &quot;Wood&quot;, &quot;Wood&quot;, &quot;Stick&quot;, &quot;Stick&quot;);
            } else {
                appendOutput(&quot;You cannot collect wood here.&quot;);
            }
            break;
        case &quot;seeds&quot;:
            if (currentBiome === &quot;Grasslands Biome&quot;) {
                appendOutput(&quot;You collected five seeds!&quot;);
                inventory.push(&quot;seed&quot;, &quot;seed&quot;, &quot;seed&quot;, &quot;seed&quot;, &quot;seed&quot;);
            } else {
                appendOutput(&quot;You cannot collect seeds here.&quot;);
            }
            break;
        case &quot;exit&quot;:
            appendOutput(&quot;Exiting exploration...&quot;);
            gameState = &quot;idle&quot;; // Return to the idle state
            break;
        case &quot;explore&quot;:
            appendOutput(&quot;You continue to explore...&quot;)
            startExplore()
            break;
        default:
            appendOutput(&quot;Invalid resource. Please specify &#39;wood&#39; or &#39;seeds&#39;, or type &#39;exit&#39; to leave.&quot;);
    }
};

const startMine = () =&gt; {
    currentCave = caves[Math.floor(Math.random() * caves.length)];
    gameState = &quot;mine&quot;; // Transition to the explore state
    appendOutput(`You are now exploring the ${currentCave}. What resource would you like to collect?`);
    appendOutput(&quot;Type &#39;cobblestone&#39; or &#39;dirt&#39; to collect. Type &#39;exit&#39; to leave or &#39;mine&#39; to continue.&quot;);
    appendOutput(&quot;Greater treasures appear at lower depths.&quot;)
};

// function mine() {
//     const move = Math.floor(Math.random() * 5) + 1
//     if (coordinates[2] &lt;= -50 &amp;&amp; move === 1 &amp;&amp; mining_strength &gt;= 3) {
//         appendOutput(&quot;You mined a Diamond&quot;);
//         inventory.push(&quot;Diamond&quot;);
//     } else if (coordinates[2] &lt;= -50 &amp;&amp; move === 1) {
//         appendOutput(&quot;You found a Diamond but need at least an Iron Pickaxe&quot;);
//     } else if (coordinates[2] &lt;= -30 &amp;&amp; [2,3].includes(move) &amp;&amp; mining_strength &gt;= 3) {
//         appendOutput(&quot;You mined three Gold Ore&quot;);
//         inventory.concat(new Array(3).fill(&quot;Gold Ore&quot;));
//     } else if (coordinates[2] &lt;= -30 &amp;&amp; [2,3].includes(move)) {
//         appendOutput(&quot;You found Gold but need at least an Iron Pickaxe&quot;);
//     } else if (coordinates[2] &lt;= -20 &amp;&amp; [2,3,4].includes(move) &amp;&amp; mining_strength &gt;= 2) {
//         appendOutput(&quot;You mined three Iron Ore&quot;);
//         inventory.concat(new Array(3).fill(&quot;Iron Ore&quot;));
//     } else if (coordinates[2] &lt;= -20 &amp;&amp; [2,3,4].includes(move)) {
//         appendOutput(&quot;You found Iron but need at least a Cobblestone Pickaxe&quot;);
//     } else if (coordinates[2] &lt;= -10 &amp;&amp; [2,3,4,5].includes(move) &amp;&amp; mining_strength &gt;= 1) {
//         appendOutput(&quot;You mined three Coal&quot;)
//         inventory.concat(new Array(3).fill(&quot;Coal&quot;))
//     }  else if (coordinates[2] &lt;= -20 &amp;&amp; [2,3,4].includes(move)) {
//         appendOutput(&quot;You found Coal but need at least a Wooden Pickaxe&quot;);
//     }
// }

function mine() {
    const miningRules = [
        {
            depth: -50,
            moves: [1],
            requiredStrength: 3,
            reward: { item: &quot;Diamond&quot;, amount: 1 },
            failureMessage: &quot;You found a Diamond but need at least an Iron Pickaxe&quot;,
        },
        {
            depth: -30,
            moves: [2, 3],
            requiredStrength: 3,
            reward: { item: &quot;Gold Ore&quot;, amount: 3 },
            failureMessage: &quot;You found Gold but need at least an Iron Pickaxe&quot;,
        },
        {
            depth: -20,
            moves: [2, 3, 4],
            requiredStrength: 2,
            reward: { item: &quot;Iron Ore&quot;, amount: 3 },
            failureMessage: &quot;You found Iron but need at least a Cobblestone Pickaxe&quot;,
        },
        {
            depth: -10,
            moves: [2, 3, 4, 5],
            requiredStrength: 1,
            reward: { item: &quot;Coal&quot;, amount: 3 },
            failureMessage: &quot;You found Coal but need at least a Wooden Pickaxe&quot;,
        },
    ];

    const move = Math.floor(Math.random() * 5) + 1;

    for (const rule of miningRules) {
        if (coordinates[2] &lt;= rule.depth &amp;&amp; rule.moves.includes(move)) {
            if (mining_strength &gt;= rule.requiredStrength) {
                appendOutput(`You mined ${rule.reward.amount} ${rule.reward.item}(s)`);
                inventory.push(...new Array(rule.reward.amount).fill(rule.reward.item));
            } else {
                appendOutput(rule.failureMessage);
            }
            return; // Exit after the first match
        }
    }
}


const handleCoordinates = () =&gt; {
    if (coordinates[2] &lt;= -64) {
        appendOutput(&quot;You hit bedrock!&quot;)
    } else if (mining_strength &lt; 1 &amp;&amp; coordinates[2] &lt;= -10) { 
        appendOutput(&quot;You need a pickaxe to go deeper.&quot;)
    } else {
        coordinates[2] -= Math.floor(Math.random() * 16)
    }
}

const handleMine = (command) =&gt; {
    handleCoordinates()
    mine()
    switch (command.toLowerCase()) {
        case &quot;cobblestone&quot;:
            if (mining_strength === 0) {
                appendOutput(&quot;You need at least a wooden pickaxe for cobblestone.&quot;)
                break;
            }
            appendOutput(&quot;You collected three Cobblestone!&quot;);
            inventory.concat(new Array(3).fill(&quot;Cobblestone&quot;));
            break;
        case &quot;dirt&quot;:
            appendOutput(&quot;You collected three Dirt!&quot;);
            inventory.concat(new Array(3).fill(&quot;Dirt&quot;));
            break;
        case &quot;mine&quot;:
            appendOutput(&quot;You delve deeper&quot;)
            startMine()
            break;
        case &quot;exit&quot;:
            appendOutput(&quot;Leaving mine...&quot;);
            gameState = &quot;idle&quot;; // Return to the idle state
            coordinates[2] = 0
            break;
        default:
            appendOutput(&quot;Please specify Dirt or Cobblestone, or type &#39;exit&#39; to leave.&quot;);
    };
};

const startAttack = () =&gt; {
    currentMonster = monsters[Math.floor(Math.random() * monsters.length)];
    gameState = &quot;attack&quot;; // Transition to the explore state
    appendOutput(`You are now attacking the ${monster}. What do you do?`);
    appendOutput(&quot;You can attack, dodge, or flee.&quot;);
    appendOutput(`It has ${monster_health} HP.`);
};

const handleAttack = (command) =&gt; {
    const move = Math.floor(Math.random() * 3) + 1;
    switch (command.toLowerCase()) {
        case &quot;attack&quot;:
            switch (move){
                case 1:
                    appendOutput(`You attack, but the ${monster} dodges`);
                    appendOutput(&#39;and attacks first!&#39;);
                    player_health -= monster_attack_damage;
                    appendOutput(`You now have ${player_health} HP.`);
                    break;
                case 2:
                    appendOutput(`You attack the ${monster}, and your aim is true!`);
                    monster_health -= player_attack_damage;
                    appendOutput(`The ${monster} now has ${monster_health} HP.`);
                    break;
                case 3:
                    appendOutput(`You attack, but the ${monster} dodges!`);
                    break;
                default:
                    appendOutput(&quot;Something went wrong&quot;)
                };

    case &quot;dodge&quot;:
        switch (move){
            case 1:
                appendOutput(`You try dodging the ${monster}&#39;s attack,`);
                appendOutput(&#39;but it catches you anyway!&#39;);
                player_health -= monster_attack_damage;
                appendOutput(`You now have ${player_health} HP.`);
                break;
            case 2:
                appendOutput(`You dodge the ${monster}&#39;s attack!`);
                break;
            case 3:
                appendOutput(`You dodge the ${monster}&#39;s attack!`);
                break;
            default:
                appendOutput(&quot;Something went wrong&quot;)
            };
    case &quot;flee&quot;:  
        appendOutput(`You run away from the ${monster},`);
        gamestate=&quot;idle&quot;
        break;
    default:
        if (monster_health &lt;= 0) {
            console.clear();
            appendOutput(`You have defeated the ${monster}!`);
            appendOutput(&#39;You have earned 5 XP.&#39;);
            experience += 5;
            gamestate=&quot;idle&quot;
        };
        if (player_health &lt;= 0) {
            slain_by_monster = true;
            gameOver();
        };
    };
};

function gameOver() {
    appendOutput(&#39;Game over.&#39;)
    if (slain_by_monster) {
        appendOutput(`player_01 was slain by a ${monster}.`);
    };
    if (void_fall) {
        appendOutput(&#39;player_01 fell in the Void&#39;);
    };
    // Helper function to simulate sleep
    while (new Date().getTime() &lt; new Date().getTime() + 15000);
    location.reload();
};

function drop(array, stringToRemove) {
    const index = array.indexOf(stringToRemove);
    if (index !== -1) {
        array.splice(index, 1); // Remove the first occurrence of the string
    }
    return array;
    }

const startSmelt = () =&gt; {
    if (!inventory.includes(&#39;Planks&#39;) &amp;&amp; !inventory.includes(&#39;Coal&#39;)) {
        appendOutput(&#39;You need Planks or Coal.&#39;);
        return;
    };
    gameState = &quot;smelt&quot;; // Transition to the explore state
    appendOutput(`Would you like to smelt Iron Ore or Gold Ore? (or exit)`);
};

const handleSmelt = (command) =&gt; {
    switch (command.toLowerCase()) {
        case &quot;gold&quot;:
        case &quot;gold ore&quot;:
            inventory  = drop(inventory, &#39;Gold Ore&#39;);
            if (inventory.includes(&#39;Planks&#39;)) {
                inventory  = drop(inventory, &#39;Planks&#39;);
            } else if (inventory.includes(&#39;Coal&#39;)) {
                inventory  = drop(inventory, &#39;Coal&#39;);
            } else {
                appendOutput(&#39;You cannot smelt that.&#39;);
                return;
            }
            inventory.push(&#39;Gold Ingot&#39;);
            appendOutput(&#39;You smelted Gold!&#39;);
            break;
        case &quot;iron&quot;:
        case &quot;iron ore&quot;:
            inventory  = drop(inventory, &#39;Iron Ore&#39;);
            if (inventory.includes(&#39;Planks&#39;)) {
                inventory  = drop(inventory, &#39;Planks&#39;);
            } else if (inventory.includes(&#39;Coal&#39;)) {
                inventory  = drop(inventory, &#39;Coal&#39;);
            } else {
                appendOutput(&#39;You cannot smelt that.&#39;);
                return;
            }
            inventory.push(&#39;Iron Ingot&#39;);
            appendOutput(&#39;You smelted Iron!&#39;);
            break;
        case &quot;exit&quot;:
            gameState = &quot;idle&quot;
            appendOutput(&quot;You exited smelting&quot;)
            break;
        defualt:
            appendOutput(&quot;Something went wrong&quot;)
            gameState = &quot;idle&quot;
        };
    };

const startCraft  = () =&gt; {
    appendOutput(&quot;Would you like to craft a(n) wooden/cobblestone/iron/gold pickaxe/sword? (or exit)&quot;)
    gameState = &quot;craft&quot;
}

function craft(recipe) {
    if (!recipe.every(item =&gt; inventory.includes(item))) {
        appendOutput(&quot;You need materials.&quot;)
        return;
    } else {
        for (let item of recipe) {
            inventory = drop(inventory, item)
        }
    }
}


const handleCraft = (command) =&gt; {
    item = toTitleCase(command)
    if (item === &quot;Exit&quot;) {
        appendOutput(&quot;You left the crafting.&quot;)
        gameState = &quot;idle&quot;
        return;
    } else if (!Object.keys(items).includes(item)) {
        appendOutput(&quot;That&#39;s not an item&quot;)
        return;
    } else {
        recipe = items[item][&quot;recipe&quot;]
        craft(recipe)
        inventory.push(item)
        appendOutput(`You crafted ${item}`)
        return;
    }
}

const handleCommand = (command) =&gt; {
    appendOutput(`&#92;n&#92;n&#92;nCoordinates: ${coordinates}`)
    appendOutput(`HP: ${player_health}`)
    switch (gameState) {
        case &quot;explore&quot;:
            handleExplore(command); // Handle commands specific to the explore state
            return;
        case &quot;mine&quot;:
            handleMine(command);
            return;
        case &quot;attack&quot;:
            handleAttack(command);
            return;
        case &quot;smelt&quot;:
            handleSmelt(command);
            return;
        case &quot;craft&quot;:
            handleCraft(command);
            return;
        case &quot;equip&quot;:
            handleEquip(command)
            return;
        default:
            break;
            // appendOutput(&quot;Would you like to explore, mine, or attack?&quot;);
    }

    switch (command.toLowerCase()) {
        case &quot;explore&quot;:
            startExplore();
            break;
        case &quot;mine&quot;:
            startMine();
            break;
        case &quot;attack&quot;:
            startAttack();
            break;
        case &quot;inventory&quot;:
            appendOutput(inventory.toString());
            break;
        case &quot;smelt&quot;:
            startSmelt();
            break;
        case &quot;craft&quot;:
            startCraft();
            break;
        case &quot;equip&quot;:
            startEquip();
            break;
        case &quot;help&quot;:
            appendOutput(&quot;Commands: explore, mine, attack, smelt, inventory, craft, equip, &amp; help.&quot;);
            break;
        default:
            appendOutput(&quot;I don&#39;t understand that command.&quot;);
    }
};

input.addEventListener(&quot;keydown&quot;, (event) =&gt; {
    if (event.key === &quot;Enter&quot;) {
        const command = input.value.trim();
        if (command) {
            appendOutput(`&gt; ${command}`);
            handleCommand(command);
            input.value = &quot;&quot;; // Clear the input field
        }
    }
});
     &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</content>
  </entry>
  <entry>
    <title>khovanov homology talk</title>
    <link href="https://ischmidls.github.io/blog/khovanov/" />
    <updated>2024-06-14T00:00:00Z</updated>
    <id>https://ischmidls.github.io/blog/khovanov/</id>
    <content type="html">&lt;script type=&quot;text/x-mathjax-config&quot;&gt;
    MathJax.Hub.Config({
      jax: [&quot;input/TeX&quot;, &quot;output/HTML-CSS&quot;],
      extensions: [&quot;tex2jax.js&quot;],
      &quot;HTML-CSS&quot;: { preferredFont: &quot;TeX&quot;, availableFonts: [&quot;STIX&quot;,&quot;TeX&quot;] },
      tex2jax: { inlineMath: [ [&quot;$&quot;, &quot;$&quot;], [&quot;&#92;&#92;(&quot;,&quot;&#92;&#92;)&quot;] ], displayMath: [ [&quot;$$&quot;,&quot;$$&quot;], [&quot;&#92;&#92;[&quot;, &quot;&#92;&#92;]&quot;] ], processEscapes: true, ignoreClass: &quot;tex2jax_ignore|dno&quot; },
      TeX: { noUndefined: { attributes: { mathcolor: &quot;red&quot;, mathbackground: &quot;#FFEEEE&quot;, mathsize: &quot;90%&quot; } } },
      messageStyle: &quot;none&quot;
    });
    &lt;/script&gt;    
    &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js&quot;&gt;&lt;/script&gt;
&lt;p&gt;This is an 8-minute presentation I gave. It was my final project for an undergraduate &quot;writing intensive&quot; course on knot theory.
&lt;/p&gt;

&lt;picture&gt;&lt;source type=&quot;image/avif&quot; srcset=&quot;https://ischmidls.github.io/blog/khovanov/5JuAy0gpIF-2500.avif 2500w&quot;&gt;&lt;source type=&quot;image/webp&quot; srcset=&quot;https://ischmidls.github.io/blog/khovanov/5JuAy0gpIF-2500.webp 2500w&quot;&gt;&lt;img loading=&quot;lazy&quot; decoding=&quot;async&quot; src=&quot;https://ischmidls.github.io/blog/khovanov/5JuAy0gpIF-2500.png&quot; alt=&quot;poster&quot; width=&quot;2500&quot; height=&quot;1406&quot;&gt;&lt;/picture&gt;

&lt;p&gt;Hi, I’d like to tell you about Khovanov homology with minimal intense
    algebra and end with an informal example of ribbon concordance. My
    inspiration was a theorem: “ribbon concordance induces an injective map
    on Khovanov homology,” based on the work of Levine and Zemke (2019).&lt;/p&gt;
    &lt;p&gt;Homology is about “cycles” or kernels (inputs that map to zero) of
    the differential maps modulo those cycles that are “boundaries” or
    images in sequences of vector spaces. This quotient forms the homology
    as a group.&lt;/p&gt;
    &lt;p&gt;The smoothing states of a link diagram form a sequence of vector
    spaces classes a chain complex (vector space = chain, sequence =
    complex) that also have isomorphic homology. The order of the sequence
    is given by differential maps or boundary maps between the vector
    spaces.&lt;/p&gt;
    &lt;p&gt;The image of each map is the kernel of the next, until the sequence
    reaches the trivial kernel, which is just zero.&lt;/p&gt;
    &lt;p&gt;The homology is the group formed by the quotient of the kernel by
    image. If you don’t know about groups, just think about these for now as
    some vector space without scaling. (If you’re unfamiliar with quotients,
    this is just like quotients with numbers, but instead of saying there
    are 4 things that look like 3 among 12 things, you separate them by
    their vector space properties). You can think of this as saying how much
    of the remaining space looks like the kernel.&lt;/p&gt;
    &lt;p&gt;This also has a geometric view. The kernels are cycles, or closed
    loops, for some base point in the vector space. The image is the
    boundaries in the space. We say boundary in the sense that you can
    imagine the vector space basis as a graph, right, with basis vectors as
    vertices?. A boundary is what remains when you remove part of the graph
    that is one dimension less. For example, removing a line from a triangle
    or a face from a pyramid/simplex.&lt;/p&gt;
    &lt;p&gt;When you take two chain complexes and can find two distinct maps
    between the complexes that pair up their (homology groups) chains/vector
    spaces the same way, this induces what are called homotopies between the
    chains or vector spaces.&lt;/p&gt;
    &lt;p&gt;Recall the Jones and Kauffman polynomials came from defining rules
    for link brackets.&lt;/p&gt;
    &lt;p&gt;In thia picture, let &lt;span class=&quot;math inline&quot;&gt;&#92;(L&#92;)&lt;/span&gt; be the
    link and &lt;span class=&quot;math inline&quot;&gt;&#92;(V&#92;)&lt;/span&gt; be a vector space of
    dimensions &lt;span class=&quot;math inline&quot;&gt;&#92;((q + q^{-1})&#92;)&lt;/span&gt;. The map
    &lt;span class=&quot;math inline&quot;&gt;&#92;(F&#92;)&lt;/span&gt; takes a double complex to a
    single complex by taking direct sums along the diagonals of the double
    complex. The differential map &lt;span class=&quot;math inline&quot;&gt;&#92;(d&#92;)&lt;/span&gt; is
    not yet defined.&lt;/p&gt;
    &lt;p&gt;The bracket is given by a direct sum over the smoothings of &lt;span class=&quot;math inline&quot;&gt;&#92;(L&#92;)&lt;/span&gt; of tensor powers of &lt;span class=&quot;math inline&quot;&gt;&#92;(V&#92;)&lt;/span&gt;, where a factor of the powers of &lt;span class=&quot;math inline&quot;&gt;&#92;(V&#92;)&lt;/span&gt; corresponds to a cycle in a smoothing.
    That is, the space &lt;span class=&quot;math inline&quot;&gt;&#92;(V(k)&#92;)&lt;/span&gt; on each
    vertex &lt;span class=&quot;math inline&quot;&gt;&#92;(k&#92;)&lt;/span&gt; has as many tensor factors
    as there are cycles in the smoothing &lt;span class=&quot;math inline&quot;&gt;&#92;(S(k)&#92;)&lt;/span&gt;. These powers behave like spaces of
    linear combinations of marked smoothings of &lt;span class=&quot;math inline&quot;&gt;&#92;(L&#92;)&lt;/span&gt;, so each cycle in a smoothing of &lt;span class=&quot;math inline&quot;&gt;&#92;(L&#92;)&lt;/span&gt; corresponds to an element of &lt;span class=&quot;math inline&quot;&gt;&#92;(V&#92;)&lt;/span&gt;.&lt;/p&gt;
    &lt;p&gt;Khovanov does this similarly, defining his own bracket, with states
    sums and other definitions similar to Khovanov. For the bracket, he
    exploits the fact the Euler characteristic of each chain or vector space
    is the same as the Euler characteristic of the corresponding homology
    group. Here I must make a slight point, Khovanov homology actually
    describes a cohomology, where instead of boundary maps taking away
    components, the maps between chains or vector spaces add components.
    This Euler characteristic of the Khovanov homology also happens to be
    the Jones polynomial we talked about.&lt;/p&gt;
    &lt;p&gt;He also uses that the boundary maps are given by the vector space
    gradings, or the fact that we can add smoothing states together to form
    smoothings with fewer components, or as we did with Kauffman, we can add
    more smoothings to a state to achieve more components. The Khovanov
    polynomial similarly uses the dimensions of each cohomology for the
    chain complex of the link states for the corresponding term in the sum
    defining the polynomial.&lt;/p&gt;
    &lt;p&gt;A Tensor product in this case is just a way to take any of the basis
    vectors and put them into a list, where the list is a new basis vector
    in the new space, and vice versa, taking lists and breaking them apart.
    You can imagine as the kernel of the vector space shrinks, less of the
    vector space looks like its kernel, and in a sense at the limit of these
    boundary maps, we reach the stalk vector space growing out the kernels
    of the chain complex of vector spaces.&lt;/p&gt;
    &lt;p&gt;Now stepping back from the chain complex, we can see it forms a cube.
    And we know this is a chain complex precisely because this cube
    commutes. That is, taking a boundary map in the first row, then mapping
    to the second row should be the same as mapping to the second row then
    taking a boundary map. This also shows that the definitions of the bases
    or the order of smoothings will not change this chain complex for a
    given knot.&lt;/p&gt;
    &lt;p&gt;To wrap up quickly, let’s look at some examples. We have this
    illustration from (Bar-Natan, 2002) for the trefoil. You can see how
    moving between the states forms different brackets from their sums, and
    these brackets form a complex.&lt;/p&gt;
    &lt;p&gt;You can see boundary maps change the tensor power of the vector space
    and the degree shift. The tensor power does not change the vector space
    dimension, but the degree shift does. While these are integer vector
    spaces, you can think of Euclidean space. If a matrix mapping a vector
    space to another is rectangular, it deletes one of the basis elements,
    and the situation is similar here.&lt;/p&gt;
    &lt;p&gt;Concordance or more broadly cobordism can be seen as a map between
    Khovanov homologies and is clearly a homotopy between two links as the
    manifold provides the path mapping. For example, rolling up a sheet of
    paper into a cylinder and slipping a rubber band around each end
    connects two unknotted rubber bands. In 4 dimensions, the cylinder might
    smooth out, untying any knot.&lt;/p&gt;
    &lt;p&gt;A “path” is a continuous map from an interval to a space. A
    “homotopy” of paths is a “family of maps” from an interval to a space
    with the same endpoints where paths follow another path. Think of it as
    a map from two intervals to the space. A “composition/product path” lets
    you glue two paths together. As we discussed in class, a “loop” is a
    path that ends and begins at the same point (i.e., the “basepoint”).&lt;/p&gt;
    &lt;p&gt;We look at cobordisms or concordance with “movie moves”, looking at
    different 3-dimensional places in the four dimensional manifold where
    there are singularities (max, min saddle).&lt;/p&gt;
    &lt;p&gt;And, we could go both directions, given a concordance between two
    links, we can find their Khovanov homologies are the same, or given
    Khovanov homologies between two links, we can find a cobordism between
    the links.&lt;/p&gt;
    &lt;p&gt;Khovanov homology also gives combinatorial methods for more abstract
    homologies in other fields like Floer homologies (3-manifold, Heegaard,
    Lagrangian).&lt;/p&gt;
    &lt;p&gt;And we will have to end there. Any questions?&lt;/p&gt;

    &lt;hr&gt;
    &lt;p&gt;Further Information for potential questions or extra time:&lt;/p&gt;
    &lt;ul&gt;
        &lt;li&gt;Ribbon concordance between two knots has no local minima.&lt;/li&gt;
        &lt;li&gt;Concordance for two submanifolds &#92;( M&#39; &#92;), &#92;( M&#39;&#39; &#92;) contained in &#92;( N &#92;) is a cobordism between them in &#92;( N &#92;times [0, 1] &#92;), so a manifold with boundary &#92;( W &#92;) contained in &#92;( N &#92;times [0, 1] &#92;) whose boundary is &#92;( M&#39; &#92;times &#92;{0&#92;} &#92;) and &#92;( M&#39;&#39; &#92;times &#92;{1&#92;} &#92;).&lt;/li&gt;
        &lt;li&gt;This is a relative form of cobordism since it all happens in &#92;( N &#92;).&lt;/li&gt;
        &lt;li&gt;&#92;( I = [0, 1] &#92;). It is a 1-dimensional cobordism between the 0-dimensional manifolds &#92;( &#92;{0&#92;} &#92;), &#92;( &#92;{1&#92;} &#92;).&lt;/li&gt;
        &lt;li&gt;Generally, for any closed manifold &#92;( M &#92;), &#92;( (M &#92;times I; M &#92;times &#92;{0&#92;}, M &#92;times &#92;{1&#92;}) &#92;) is a cobordism from &#92;( M &#92;times &#92;{0&#92;} &#92;) to &#92;( M &#92;times &#92;{1&#92;} &#92;).&lt;/li&gt;
        &lt;li&gt;A homotopy between two continuous functions &#92;( f &#92;) and &#92;( g &#92;) from a topological space &#92;( X &#92;) to a topological space &#92;( Y &#92;) is defined to be a continuous function &#92;( H: X &#92;times [0, 1] &#92;to Y &#92;) (so from the product of the space with the unit interval &#92;( X &#92;times [0, 1] &#92;) to &#92;( Y &#92;)) such that &#92;( H(x, 0) = f(x) &#92;) and &#92;( H(x, 1) = g(x) &#92;) for all &#92;( x &#92;in X &#92;).&lt;/li&gt;
        &lt;li&gt;Two links, denoted as &#92;( l&#39; &#92;) within &#92;( m &#92;)-sphere and &#92;( l&#39;&#39; &#92;) within &#92;( n &#92;)-sphere, are considered concordant if there exists an embedding function &#92;( f &#92;) from &#92;( l&#39; &#92;times [0, 1] &#92;) to &#92;( n &#92;)-sphere &#92;( &#92;times [0, 1] &#92;).&lt;/li&gt;
        &lt;li&gt;This function has two conditions:
            &lt;ul&gt;
                &lt;li&gt;The image &#92;( f(l&#39; &#92;times &#92;{0&#92;}) = l&#39; &#92;times &#92;{0&#92;} &#92;).&lt;/li&gt;
                &lt;li&gt;The image &#92;( f(l&#39; &#92;times &#92;{1&#92;}) = l&#39;&#39; &#92;times &#92;{1&#92;} &#92;).&lt;/li&gt;
            &lt;/ul&gt;
        &lt;/li&gt;
        &lt;li&gt;This forms an equivalence relation.&lt;/li&gt;
        &lt;li&gt;It is a weaker condition than isotopy and a stronger condition than homotopy, meaning that:
            &lt;ul&gt;
                &lt;li&gt;Isotopy implies concordance/cobordism (and concordance implies cobordism).&lt;/li&gt;
                &lt;li&gt;Concordance/cobordism implies homotopy.&lt;/li&gt;
            &lt;/ul&gt;
        &lt;/li&gt;
        &lt;li&gt;Slice knot concordant with unknot (3D knot bounds disc in 4D).&lt;/li&gt;
        &lt;li&gt;&#92;( Kh(L) &#92;): “Poincaré Polynomial” formal power series in one indeterminate, say &#92;( t &#92;), where the coefficient of &#92;( t^n &#92;) gives the dimension (or rank) of the substructure of elements homogeneous of degree &#92;( n &#92;).&lt;/li&gt;
    &lt;/ul&gt;
    &lt;picture&gt;&lt;source type=&quot;image/avif&quot; srcset=&quot;https://ischmidls.github.io/blog/khovanov/Fn1C3iL7uA-663.avif 663w&quot;&gt;&lt;source type=&quot;image/webp&quot; srcset=&quot;https://ischmidls.github.io/blog/khovanov/Fn1C3iL7uA-663.webp 663w&quot;&gt;&lt;img loading=&quot;lazy&quot; decoding=&quot;async&quot; src=&quot;https://ischmidls.github.io/blog/khovanov/Fn1C3iL7uA-663.png&quot; alt=&quot;guide&quot; width=&quot;663&quot; height=&quot;1096&quot;&gt;&lt;/picture&gt;
    &lt;p&gt;My professor said this guide was too complicated to put on my poster.&lt;/p&gt;
    &lt;p&gt;Further reference:&lt;/p&gt;
    &lt;ul&gt;
    &lt;li&gt;Bar-Natan, D. (2002). On Khovanov’s categorification of the Jones
    polynomial. Algebraic &amp;amp; Geometric Topology, 2(1), 337–370.&lt;/li&gt;
    &lt;li&gt;Bar-Natan, D. (2005). Khovanov’s homology for tangles and
    cobordisms. Geometry &amp;amp; Topology, 9(3), 1443–1499.&lt;/li&gt;
    &lt;li&gt;Hatcher, A. (2002). Algebraic topology. Cambridge: Cambridge
    University Press.&lt;/li&gt;
    &lt;li&gt;Kauffman, L. H. (2016). An Introduction to Khovanov Homology.
    Contemporary Mathematics - American Mathematical Society, 105–139.&lt;/li&gt;
    &lt;li&gt;Levine, A. &amp;amp; Zemke, I. (2019). Khovanov homology and ribbon
    concordances. Bulletin of the London Mathematical Society, 51(6),
    1099–1103.&lt;/li&gt;
    &lt;li&gt;Ray, A. (2023). Slice knots and knot concordance. Winterbraids XI in
    Dijon. ArXiv.org.&lt;/li&gt;
    &lt;/ul&gt;</content>
  </entry>
  <entry>
    <title>cohomology ring of n-sphere</title>
    <link href="https://ischmidls.github.io/blog/cohomologysphere/" />
    <updated>2024-05-30T00:00:00Z</updated>
    <id>https://ischmidls.github.io/blog/cohomologysphere/</id>
    <content type="html">&lt;script type=&quot;text/x-mathjax-config&quot;&gt;
    MathJax.Hub.Config({
      jax: [&quot;input/TeX&quot;, &quot;output/HTML-CSS&quot;],
      extensions: [&quot;tex2jax.js&quot;],
      &quot;HTML-CSS&quot;: { preferredFont: &quot;TeX&quot;, availableFonts: [&quot;STIX&quot;,&quot;TeX&quot;] },
      tex2jax: { inlineMath: [ [&quot;$&quot;, &quot;$&quot;], [&quot;&#92;&#92;(&quot;,&quot;&#92;&#92;)&quot;] ], displayMath: [ [&quot;$$&quot;,&quot;$$&quot;], [&quot;&#92;&#92;[&quot;, &quot;&#92;&#92;]&quot;] ], processEscapes: true, ignoreClass: &quot;tex2jax_ignore|dno&quot; },
      TeX: { noUndefined: { attributes: { mathcolor: &quot;red&quot;, mathbackground: &quot;#FFEEEE&quot;, mathsize: &quot;90%&quot; } } },
      messageStyle: &quot;none&quot;
    });
    &lt;/script&gt;    
    &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js&quot;&gt;&lt;/script&gt;
    &lt;p&gt;
        Differential forms and holes in a space are related through cohomology, but the direct measure of holes is homology. In simplicial homology, a space is decomposed into simplices, and chain groups &#92;(C_k(X)&#92;) are formal linear combinations of &#92;(k&#92;)-simplices. The boundary operator &#92;(&#92;partial&#92;) maps a simplex to its boundary, an alternating sum of its faces, satisfying &#92;(&#92;partial^2 = 0&#92;) due to sign cancellations. Cycles (elements killed by &#92;(&#92;partial&#92;)) represent loops or higher-dimensional analogs, while boundaries (images of &#92;(&#92;partial&#92;)) are loops that bound filled regions. Homology &#92;(H_k(X)&#92;) measures holes by quotienting cycles by boundaries, capturing loops that aren’t filled in.

Cohomology, on the other hand, dualizes this construction. Instead of chains, cohomology uses cochains &#92;(C^k = &#92;text{Hom}(C_k, &#92;mathbb{Z})&#92;), with a coboundary operator increasing dimension. Intuitively, cohomology measures how forms can detect holes. For instance, a closed form (cocycle) that isn’t exact (coboundary) corresponds to a hole. This duality is formalized in theorems like Poincaré duality, which relates &#92;(k&#92;)-chains to &#92;((n-k)&#92;)-cochains via intersection pairing, and the Universal Coefficient Theorem, which connects homology and cohomology over different coefficient rings.

In de Rham cohomology, differential forms are used as cochains, with closed forms representing cocycles and exact forms representing coboundaries. This theory detects holes similarly to simplicial cohomology but uses smooth structures. For example, the space &#92;(&#92;Omega_n(X)&#92;) of differential &#92;(n&#92;)-forms on &#92;(X&#92;) has that closed forms in &#92;(&#92;Omega_n(X)&#92;) detect holes via Stokes&#39; theorem, which ensures that integrals of closed forms over cycles are invariant under homotopy. If two paths yield different integrals for a closed form, they cannot be deformed into each other, indicating a &quot;hole.&quot; This idea is formalized by the de Rham map, &#92;(&#92;Omega_n(X) &#92;to &#92;text{Hom}(C_n(X), &#92;mathbb{R})&#92;), sending a form &#92;(&#92;omega&#92;) to the functional &#92;(&#92;sigma &#92;mapsto &#92;int_&#92;sigma &#92;omega&#92;). Stokes&#39; theorem ensures this is a chain map, and the de Rham theorem shows it induces an isomorphism between de Rham cohomology and singular cohomology, linking differential forms to the intuitive notion of holes. However, coefficients matter: de Rham cohomology with &#92;(&#92;mathbb{R}&#92;) coefficients misses torsion phenomena, like in &#92;(&#92;mathbb{R}P^2&#92;), where a loop traversed twice bounds a disk, but not once. Thus, while differential forms and holes are linked through cohomology, the choice of coefficients and theory determines what geometric or topological features are visible, giving the need for the Universal Coefficient Theorem.
    &lt;/p&gt;
    &lt;p&gt;The above is based on &lt;a href=&quot;https://math.stackexchange.com/a/3635358/1098426&quot;&gt;this&lt;/a&gt; MSE post&lt;/p&gt;
    
    &lt;p&gt;Every continuous map &#92;(f: X &#92;to Y&#92;) induces a homomorphism from the cohomology ring of &#92;(Y&#92;) to that of &#92;(X&#92;), limiting the possible maps between spaces. Unlike more complex invariants like homotopy groups, singular cohomology is often computable for spaces of interest. The construction begins with the singular chain complex, a sequence of free abelian groups &#92;(C_i&#92;) generated by continuous maps from the standard &#92;(i&#92;)-simplex to &#92;(X&#92;), connected by boundary homomorphisms &#92;(&#92;partial_i&#92;). The singular homology of &#92;(X&#92;) is the homology of this complex. To define cohomology, one fixes an abelian group &#92;(A&#92;) and &quot;dualizes the chain complex, replacing &#92;(C_i&#92;) with &#92;(C_i^* = &#92;text{Hom}(C_i, A)&#92;)&quot;...&lt;/p&gt;
    
    &lt;p&gt;... e.g. consider the chain complex &#92;(C_*&#92;) with &#92;(C_0 = &#92;mathbb{Z}&#92;), &#92;(C_1 = &#92;mathbb{Z}&#92;), and &#92;(C_i = 0&#92;) for &#92;(i &#92;neq 0, 1&#92;), connected by the boundary map &#92;(&#92;partial_1: C_1 &#92;to C_0&#92;) defined by &#92;(&#92;partial_1(n) = 2n&#92;). To dualize this complex, replace each &#92;(C_i&#92;) with &#92;(C_i^* = &#92;text{Hom}(C_i, A)&#92;), where &#92;(A&#92;) is an abelian group, say &#92;(A = &#92;mathbb{Z}&#92;). Here, &#92;(C_0^* = &#92;text{Hom}(&#92;mathbb{Z}, &#92;mathbb{Z}) &#92;simeq &#92;mathbb{Z}&#92;) and &#92;(C_1^* = &#92;text{Hom}(&#92;mathbb{Z}, &#92;mathbb{Z}) &#92;simeq &#92;mathbb{Z}&#92;), with the dual map &#92;(d_0: C_0^* &#92;to C_1^*&#92;) defined by &#92;(d_0(f)(m) = f(&#92;partial_1(m)) = f(2m)&#92;). This dual map &#92;(d_0&#92;) effectively &quot;reverses the arrows&quot; of the original boundary map...&lt;/p&gt;
    
    &lt;p&gt;...and replacing &#92;(&#92;partial_i&#92;) with its dual &#92;(d_{i-1}: C_{i-1}^* &#92;to C_i^*&#92;). This reversal of arrows yields a cochain complex, and the &#92;(i&#92;)-th cohomology group &#92;(H^i(X, A)&#92;) is defined as &#92;(&#92;text{ker}(d_i) / &#92;text{im}(d_{i-1})&#92;). Elements of &#92;(C_i^*&#92;) are called &#92;(i&#92;)-cochains, while those in &#92;(&#92;text{ker}(d_i)&#92;) and &#92;(&#92;text{im}(d_{i-1})&#92;) are cocycles and coboundaries, respectively. The cohomology classes, represented by equivalence classes of cocycles, form the cohomology groups, which vanish for negative &#92;(i&#92;).&lt;/p&gt;



    &lt;p&gt;
        In singular cohomology, the cup product defines a multiplication on the cohomology ring &#92;(H^*(X)&#92;) of a topological space &#92;(X&#92;). It is constructed by defining a product on cochains: if &#92;(&#92;alpha^p&#92;) is a &#92;(p&#92;)-cochain and &#92;(&#92;beta^q&#92;) is a &#92;(q&#92;)-cochain, their cup product &#92;(&#92;alpha^p &#92;smile &#92;beta^q&#92;) is a &#92;((p+q)&#92;)-cochain given by &#92;((&#92;alpha^p &#92;smile &#92;beta^q)(&#92;sigma) = &#92;alpha^p(&#92;sigma &#92;circ &#92;iota_{0,1,...,p}) &#92;cdot &#92;beta^q(&#92;sigma &#92;circ &#92;iota_{p,p+1,...,p+q})&#92;), where &#92;(&#92;sigma&#92;) is a singular &#92;((p+q)&#92;)-simplex and &#92;(&#92;iota_S&#92;) embeds the simplex spanned by &#92;(S&#92;) into the &#92;((p+q)&#92;)-simplex. Informally, &#92;(&#92;sigma &#92;circ &#92;iota_{0,1,...,p}&#92;) represents the front &#92;(p&#92;)-face of &#92;(&#92;sigma&#92;), while &#92;(&#92;sigma &#92;circ &#92;iota_{p,p+1,...,p+q}&#92;) represents the back &#92;(q&#92;)-face. The coboundary of the cup product satisfies &#92;(&#92;delta(&#92;alpha^p &#92;smile &#92;beta^q) = &#92;delta&#92;alpha^p &#92;smile &#92;beta^q + (-1)^p (&#92;alpha^p &#92;smile &#92;delta&#92;beta^q)&#92;). This ensures that the cup product of two cocycles is a cocycle, and the product of a coboundary with a cocycle is a coboundary. The cup product thus induces a bilinear operation on cohomology, &#92;(H^p(X) &#92;times H^q(X) &#92;to H^{p+q}(X)&#92;), making &#92;(H^*(X)&#92;) a graded ring.
    &lt;/p&gt;
    &lt;p&gt;For how the cup product is dual to intersection for oriented minfolds, I recommend &lt;a href=&quot;https://math.berkeley.edu/~hutching/teach/215b-2011/cup.pdf&quot;&gt;this paper&lt;/a&gt; by Michael Hutchings
    &lt;/p&gt;
&lt;p&gt;For the &#92;(n&#92;)-sphere &#92;(S^n&#92;), we know that the only non-zero cohomology groups are &#92;(H^0(S^n, &#92;mathbb{Z}) &#92;simeq &#92;mathbb{Z}&#92;) and &#92;(H^n(S^n, &#92;mathbb{Z}) &#92;simeq &#92;mathbb{Z}&#92;)...&lt;/p&gt;

&lt;p&gt;...For the &#92;(n&#92;)-sphere &#92;(S^n&#92;), the only non-zero cohomology groups are &#92;(H^0(S^n, &#92;mathbb{Z}) &#92;simeq &#92;mathbb{Z}&#92;) and &#92;(H^n(S^n, &#92;mathbb{Z}) &#92;simeq &#92;mathbb{Z}&#92;) because &#92;(S^n&#92;) is a connected (it is NOT the union of two disjoint non-empty open sets), compact (every open cover has a finite subcover), orientable manifold. Now, the $n$-sphere is a closed oriented manifold so that we can use the Poincaré duality saying the $k$-cohomology group is isomorphic to the $n-k$-th homology group: $H^k (&#92;mathbb T^2) &#92;cong H_{n-k} (&#92;mathbb T^2)$. The group &#92;(H^0(S^n, &#92;mathbb{Z})&#92;) corresponds to the constant functions on &#92;(S^n&#92;), reflecting its connectedness as there is only one such function up to scaling,. And &#92;(H^n(S^n, &#92;mathbb{Z})&#92;) captures the top-dimensional cohomology, representing the orientation class of &#92;(S^n&#92;), e.g. (thanks to &lt;a href=&quot;https://math.stackexchange.com/a/1706944/1098426&quot;&gt;this&lt;/a&gt; and &lt;a href=&quot;https://math.stackexchange.com/a/1276703/1098426&quot;&gt;that&lt;/a&gt; MSE) for de Rham $H^n_{dR}(S^n)&#92;simeq &#92;mathbb{R}$ by the map $[&#92;omega]&#92;mapsto &#92;int_{S^n} &#92;omega$ where there is $&#92;eta$ a nowhere zero $n$-form on $S$ and we can say $C = &#92;int_S &#92;eta &#92;in &#92;mathbb R$. So for any $[&#92;omega] &#92;in H^n(S)$, see $D:= &#92;int_S &#92;omega$. This is nonzero. Then $[&#92;frac{D}{C} &#92;eta] = [&#92;omega]$ as 
    
    $$&#92;int_S &#92;frac DC &#92;eta = D = &#92;int_S &#92;omega . $$
    
And $&#92;frac DC &#92;eta$ is nowhere vanishing (thus an orientation). All other cohomology groups vanish because &#92;(S^n&#92;) has no &quot;holes&quot; in intermediate dimensions.

...&lt;/p&gt;

&lt;p&gt; ... The generator of &#92;(H^0&#92;) corresponds to the unit element of the ring, denoted as &#92;(1&#92;), since the cup product with &#92;(H^0&#92;) acts as the identity map on &#92;(H^k(X; &#92;mathbb{Z})&#92;). The generator of &#92;(H^n&#92;) is denoted as &#92;(x&#92;). The cup product structure is determined by the relations &#92;(1 &#92;smile 1 = 1&#92;), &#92;(1 &#92;smile x = x&#92;), &#92;(x &#92;smile 1 = x&#92;), and &#92;(x &#92;smile x = 0&#92;), where the last relation arises because &#92;(H^{2n}(S^n, &#92;mathbb{Z}) = 0&#92;). The cohomology ring &#92;(H^*(S^n; &#92;mathbb{Z})&#92;) is therefore the direct sum &#92;(H^0(S^n, &#92;mathbb{Z}) &#92;oplus H^n(S^n, &#92;mathbb{Z})&#92;), which can be expressed as &#92;(&#92;alpha_1 &#92;cdot 1 &#92;oplus &#92;alpha_2 &#92;cdot x&#92;) for integers &#92;(&#92;alpha_1, &#92;alpha_2&#92;). This ring is abstractly isomorphic to the polynomial ring &#92;(&#92;mathbb{Z}[x]/(x^2)&#92;), where &#92;(x&#92;) represents the generator of &#92;(H^n(S^n, &#92;mathbb{Z})&#92;). A similar analysis applies to the real projective plane &#92;(&#92;mathbb{R} P^2&#92;), whose cohomology ring is &#92;(&#92;mathbb{Z}[x]/(2x, x^2)&#92;), with &#92;(x&#92;) being the generator of &#92;(H^2(&#92;mathbb{R} P^2, &#92;mathbb{Z})&#92;). Here, the relations &#92;(2x = 0&#92;) and &#92;(x^2 = 0&#92;) reflect the torsion in the cohomology groups and the vanishing of the cup product in higher degrees, respectively.&lt;/p&gt;

&lt;p&gt;The above note expands on &lt;a href=&quot;https://math.stackexchange.com/a/38618/1098426&quot;&gt;this&lt;/a&gt; MSE post.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>note: field extension practice</title>
    <link href="https://ischmidls.github.io/blog/field-extension-practice/" />
    <updated>2024-05-24T00:00:00Z</updated>
    <id>https://ischmidls.github.io/blog/field-extension-practice/</id>
    <content type="html">&lt;script src=&quot;https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
  &lt;h4 id=&quot;1-lecture-exercise-for-reader&quot;&gt;(1) Lecture Exercise for Reader&lt;/h4&gt;
&lt;p&gt;To show that &lt;span class=&quot;math inline&quot;&gt;&#92;(F / &#92;{0&#92;} &#92;cong F&#92;)&lt;/span&gt;,
    we need to establish an isomorphism between the quotient ring &lt;span class=&quot;math inline&quot;&gt;&#92;(F / &#92;{0&#92;}&#92;)&lt;/span&gt; and the field &lt;span class=&quot;math inline&quot;&gt;&#92;(F&#92;)&lt;/span&gt;.&lt;/p&gt;
    &lt;p&gt;Let &lt;span class=&quot;math inline&quot;&gt;&#92;(F&#92;)&lt;/span&gt; be a field. &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;{0&#92;}&#92;)&lt;/span&gt; is the zero ideal in &lt;span class=&quot;math inline&quot;&gt;&#92;(F&#92;)&lt;/span&gt;.&lt;/p&gt;
    &lt;p&gt;The quotient ring &lt;span class=&quot;math inline&quot;&gt;&#92;(F / &#92;{0&#92;}&#92;)&lt;/span&gt; is
    constructed by partitioning &lt;span class=&quot;math inline&quot;&gt;&#92;(F&#92;)&lt;/span&gt; into
    cosets of the ideal &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;{0&#92;}&#92;)&lt;/span&gt;. Since
    &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;{0&#92;}&#92;)&lt;/span&gt; contains only the zero
    element, every element &lt;span class=&quot;math inline&quot;&gt;&#92;(a &#92;in F&#92;)&lt;/span&gt;
    forms a distinct coset &lt;span class=&quot;math inline&quot;&gt;&#92;(a +
    &#92;{0&#92;}&#92;)&lt;/span&gt;.&lt;/p&gt;
    &lt;p&gt;Each coset &lt;span class=&quot;math inline&quot;&gt;&#92;(a + &#92;{0&#92;}&#92;)&lt;/span&gt; is simply
    &lt;span class=&quot;math inline&quot;&gt;&#92;(a&#92;)&lt;/span&gt;. Hence, the set of cosets is just
    the set of elements of &lt;span class=&quot;math inline&quot;&gt;&#92;(F&#92;)&lt;/span&gt;.&lt;/p&gt;
    &lt;p&gt;The addition and multiplication operations on the cosets are defined
    as follows: &lt;span class=&quot;math display&quot;&gt;&#92;[(a + &#92;{0&#92;}) + (b + &#92;{0&#92;}) = (a
    + b) + &#92;{0&#92;}&#92;]&lt;/span&gt; &lt;span class=&quot;math display&quot;&gt;&#92;[(a + &#92;{0&#92;}) &#92;cdot (b
    + &#92;{0&#92;}) = (a &#92;cdot b) + &#92;{0&#92;}&#92;]&lt;/span&gt; Since &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;{0&#92;}&#92;)&lt;/span&gt; is the zero ideal, these operations
    reduce to: &lt;span class=&quot;math display&quot;&gt;&#92;[a + b + &#92;{0&#92;} = a + b&#92;]&lt;/span&gt;
    &lt;span class=&quot;math display&quot;&gt;&#92;[a &#92;cdot b + &#92;{0&#92;} = a &#92;cdot b&#92;]&lt;/span&gt;&lt;/p&gt;
    &lt;p&gt;Define the map &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;varphi: F / &#92;{0&#92;} &#92;to
    F&#92;)&lt;/span&gt; by &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;varphi(a + &#92;{0&#92;}) =
    a&#92;)&lt;/span&gt;. This map is well-defined because each coset &lt;span class=&quot;math inline&quot;&gt;&#92;(a + &#92;{0&#92;}&#92;)&lt;/span&gt; corresponds uniquely to &lt;span class=&quot;math inline&quot;&gt;&#92;(a&#92;)&lt;/span&gt;.&lt;/p&gt;
    &lt;p&gt;Check that &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;varphi&#92;)&lt;/span&gt; is a ring
    homomorphism: &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;varphi&#92;)&lt;/span&gt; is injective:
    If &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;varphi(a + &#92;{0&#92;}) = &#92;varphi(b +
    &#92;{0&#92;})&#92;)&lt;/span&gt;, then &lt;span class=&quot;math inline&quot;&gt;&#92;(a = b&#92;)&lt;/span&gt;. &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;varphi&#92;)&lt;/span&gt; is surjective: For any &lt;span class=&quot;math inline&quot;&gt;&#92;(a &#92;in F&#92;)&lt;/span&gt;, &lt;span class=&quot;math inline&quot;&gt;&#92;(a =
    &#92;varphi(a + &#92;{0&#92;})&#92;)&lt;/span&gt;.&lt;/p&gt;
    &lt;p&gt;Since &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;varphi&#92;)&lt;/span&gt; is a bijective
    homomorphism, it is an isomorphism. Therefore, &lt;span class=&quot;math inline&quot;&gt;&#92;(F / &#92;{0&#92;} &#92;cong F&#92;)&lt;/span&gt;.&lt;/p&gt;
    &lt;p&gt;Thus, we have shown that &lt;span class=&quot;math inline&quot;&gt;&#92;(F /
    &#92;{0&#92;}&#92;)&lt;/span&gt; is isomorphic to &lt;span class=&quot;math inline&quot;&gt;&#92;(F&#92;)&lt;/span&gt;.
    &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;square&#92;)&lt;/span&gt;&lt;/p&gt;
    &lt;h4 id=&quot;2-lecture-exercise-for-reader&quot;&gt;(2) Lecture Exercise for Reader&lt;/h4&gt;
    &lt;p&gt;(a) Want to show that &lt;span class=&quot;math inline&quot;&gt;&#92;(f = x^3 + 2x +
    1&#92;)&lt;/span&gt; is irreducible over &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;mathbb{Z}_3&#92;)&lt;/span&gt; and that &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;mathbb{Z}_3[x] / I&#92;)&lt;/span&gt; is a field of order
    27 containing a subfield isomorphic to &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;mathbb{Z}_3&#92;)&lt;/span&gt;. A polynomial of degree 3 is
    irreducible over &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;mathbb{Z}_3&#92;)&lt;/span&gt; if it
    has no roots in &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;mathbb{Z}_3&#92;)&lt;/span&gt; and
    cannot be factored into polynomials of lower degrees. To check for
    roots, evaluate &lt;span class=&quot;math inline&quot;&gt;&#92;(f(x) = x^3 + 2x + 1&#92;)&lt;/span&gt;
    at &lt;span class=&quot;math inline&quot;&gt;&#92;(x = 0, 1, 2&#92;)&lt;/span&gt; in &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;mathbb{Z}_3&#92;)&lt;/span&gt;. For &lt;span class=&quot;math inline&quot;&gt;&#92;(f(0) = 0^3 + 2 &#92;cdot 0 + 1 = 1&#92;)&lt;/span&gt;, &lt;span class=&quot;math inline&quot;&gt;&#92;(f(1) = 1^3 + 2 &#92;cdot 1 + 1 = 1 + 2 + 1 = 4 &#92;equiv
    1 &#92;pmod{3}&#92;)&lt;/span&gt;, and &lt;span class=&quot;math inline&quot;&gt;&#92;(f(2) = 2^3 + 2
    &#92;cdot 2 + 1 = 8 + 4 + 1 = 13 &#92;equiv 1 &#92;pmod{3}&#92;)&lt;/span&gt;, none of these
    are zero, so &lt;span class=&quot;math inline&quot;&gt;&#92;(f(x)&#92;)&lt;/span&gt; has no roots in
    &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;mathbb{Z}_3&#92;)&lt;/span&gt;. Since &lt;span class=&quot;math inline&quot;&gt;&#92;(f(x)&#92;)&lt;/span&gt; has no roots, it cannot be factored
    into a product of a linear polynomial and a quadratic polynomial in
    &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;mathbb{Z}_3[x]&#92;)&lt;/span&gt;. Thus, &lt;span class=&quot;math inline&quot;&gt;&#92;(f(x)&#92;)&lt;/span&gt; is irreducible over &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;mathbb{Z}_3&#92;)&lt;/span&gt;. Since &lt;span class=&quot;math inline&quot;&gt;&#92;(f&#92;)&lt;/span&gt; is irreducible, the ideal &lt;span class=&quot;math inline&quot;&gt;&#92;((f)&#92;)&lt;/span&gt; is maximal, and the quotient ring
    &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;mathbb{Z}_3[x] / (f)&#92;)&lt;/span&gt; is a field.
    The polynomial &lt;span class=&quot;math inline&quot;&gt;&#92;(f(x)&#92;)&lt;/span&gt; is of degree 3,
    and the quotient ring &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;mathbb{Z}_3[x] /
    (f)&#92;)&lt;/span&gt; consists of equivalence classes of polynomials of degree
    less than 3: &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;mathbb{Z}_3[x] / (f) = &#92;{ a +
    bx + cx^2 + (f) &#92;mid a, b, c &#92;in &#92;mathbb{Z}_3 &#92;}&#92;)&lt;/span&gt;. There are
    &lt;span class=&quot;math inline&quot;&gt;&#92;(3^3 = 27&#92;)&lt;/span&gt; such equivalence classes,
    so &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;mathbb{Z}_3[x] / (f)&#92;)&lt;/span&gt; is a field
    of order 27. The field &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;mathbb{Z}_3&#92;)&lt;/span&gt;
    is naturally embedded in &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;mathbb{Z}_3[x] /
    (f)&#92;)&lt;/span&gt; as &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;{ a + (f) &#92;mid a &#92;in
    &#92;mathbb{Z}_3 &#92;}&#92;)&lt;/span&gt;, forming a subfield isomorphic to &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;mathbb{Z}_3&#92;)&lt;/span&gt;. &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;square&#92;)&lt;/span&gt;&lt;/p&gt;
    &lt;p&gt;(b) Want to show that &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;mathbb{Z}_3[x] /
    (f)&#92;)&lt;/span&gt; is a field extension of &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;overline{&#92;mathbb{Z}}_3&#92;)&lt;/span&gt; and is a
    3-dimensional vector space over &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;overline{&#92;mathbb{Z}}_3&#92;)&lt;/span&gt; with basis &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;{1 + (f), x + (f), x^2 + (f)&#92;}&#92;)&lt;/span&gt;. Let
    &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;overline{&#92;mathbb{Z}}_3 = &#92;{ 0 + (f), 1 +
    (f), 2 + (f) &#92;}&#92;)&lt;/span&gt;, which is isomorphic to &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;mathbb{Z}_3&#92;)&lt;/span&gt;. The field &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;mathbb{Z}_3[x] / (f)&#92;)&lt;/span&gt; contains &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;overline{&#92;mathbb{Z}}_3&#92;)&lt;/span&gt; as its subfield,
    making it a field extension. Any element of &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;mathbb{Z}_3[x] / (f)&#92;)&lt;/span&gt; can be written as
    &lt;span class=&quot;math inline&quot;&gt;&#92;(a + bx + cx^2 + (f)&#92;)&lt;/span&gt; where &lt;span class=&quot;math inline&quot;&gt;&#92;(a, b, c &#92;in &#92;mathbb{Z}_3&#92;)&lt;/span&gt;, and the
    elements &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;{1 + (f), x + (f), x^2 +
    (f)&#92;}&#92;)&lt;/span&gt; span &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;mathbb{Z}_3[x] /
    (f)&#92;)&lt;/span&gt;. To show that &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;{1 + (f), x +
    (f), x^2 + (f)&#92;}&#92;)&lt;/span&gt; is a basis, we need to establish linear
    independence and spanning. For linear independence, suppose &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;alpha (1 + (f)) + &#92;beta (x + (f)) + &#92;gamma (x^2 +
    (f)) = 0 + (f)&#92;)&lt;/span&gt;, which implies &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;alpha + &#92;beta x + &#92;gamma x^2 &#92;equiv 0
    &#92;pmod{f}&#92;)&lt;/span&gt;. Since &lt;span class=&quot;math inline&quot;&gt;&#92;(1, x, x^2&#92;)&lt;/span&gt;
    are linearly independent in &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;mathbb{Z}_3[x]&#92;)&lt;/span&gt; modulo &lt;span class=&quot;math inline&quot;&gt;&#92;(f(x)&#92;)&lt;/span&gt;, it follows that &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;alpha = &#92;beta = &#92;gamma = 0&#92;)&lt;/span&gt;. For
    spanning, any element in &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;mathbb{Z}_3[x] /
    (f)&#92;)&lt;/span&gt; can be expressed as a linear combination of &lt;span class=&quot;math inline&quot;&gt;&#92;(1, x, x^2&#92;)&lt;/span&gt; over &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;overline{&#92;mathbb{Z}}_3&#92;)&lt;/span&gt;. Thus, &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;mathbb{Z}_3[x] / (f)&#92;)&lt;/span&gt; is a 3-dimensional
    vector space over &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;overline{&#92;mathbb{Z}}_3&#92;)&lt;/span&gt; with basis &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;{1 + (f), x + (f), x^2 + (f)&#92;}&#92;)&lt;/span&gt;. &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;square&#92;)&lt;/span&gt;&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>widget: divisors and totient</title>
    <link href="https://ischmidls.github.io/blog/divisors-and-totient/" />
    <updated>2024-05-15T00:00:00Z</updated>
    <id>https://ischmidls.github.io/blog/divisors-and-totient/</id>
    <content type="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Divisors and Primes Finder&lt;/title&gt;
    &lt;script&gt;
        function findDivisorsAndPrimes() {
            // Get the user input value
            let inputValue = document.getElementById(&quot;numberInput&quot;).value;
            let number = parseInt(inputValue);

            // Validate if the input is a positive integer
            if (isNaN(number) || number &lt;= 0) {
                alert(&quot;Please enter a positive integer.&quot;);
                return;
            }

            // Function to find all divisors of a number
            function findDivisors(n) {
                let divisors = [];
                for (let i = 1; i &lt;= n; i++) {
                    if (n % i === 0) {
                        divisors.push(i);
                    }
                }
                return divisors;
            }

            // Function to check if a number is prime
            function isPrime(n) {
                if (n &lt;= 1) {
                    return false;
                }
                for (let i = 2; i &lt;= Math.sqrt(n); i++) {
                    if (n % i === 0) {
                        return false;
                    }
                }
                return true;
            }

            // Find divisors and primes less than the input number
            let divisors = findDivisors(number);
            let primes = [];
            for (let i = 2; i &lt; number; i++) {
                if (isPrime(i)) {
                    primes.push(i);
                }
            }

            // Display the results including length of lists
            let divisorsLength = divisors.length;
            let primesLength = primes.length;

            document.getElementById(&quot;divisors&quot;).textContent = `Divisors (${divisorsLength}): ` + divisors.join(&quot;, &quot;);
            document.getElementById(&quot;primes&quot;).textContent = `Primes less than ${number} (${primesLength}): ` + primes.join(&quot;, &quot;);
        }
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;p&gt;Find Divisors and Primes&lt;/p&gt;
    &lt;label for=&quot;numberInput&quot;&gt;Enter a positive integer:&lt;/label&gt;
    &lt;input type=&quot;text&quot; id=&quot;numberInput&quot;&gt;
    &lt;button onclick=&quot;findDivisorsAndPrimes()&quot;&gt;Find&lt;/button&gt;
    &lt;p id=&quot;divisors&quot;&gt;&lt;/p&gt;
    &lt;p id=&quot;primes&quot;&gt;&lt;/p&gt;
    &lt;script src=&quot;https://gist.github.com/ischmidls/0c3e254f052768d0df8d49e283478a56.js&quot;&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</content>
  </entry>
  <entry>
    <title>widget: quaternion template</title>
    <link href="https://ischmidls.github.io/blog/quaternion-multiplication/" />
    <updated>2024-05-10T00:00:00Z</updated>
    <id>https://ischmidls.github.io/blog/quaternion-multiplication/</id>
    <content type="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Quaternion Multiplication Formula&lt;/title&gt;
    &lt;script src=&quot;https://polyfill.io/v3/polyfill.min.js?features=es6&quot;&gt;&lt;/script&gt;
    &lt;script id=&quot;MathJax-script&quot; async=&quot;&quot; src=&quot;https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js&quot;&gt;&lt;/script&gt;
    &lt;script&gt;
        // Function to update the LaTeX formula based on input values
        function updateFormula() {
            // Get input values from the form
            let a1 = document.getElementById(&#39;a1&#39;).value;
            let b1 = document.getElementById(&#39;b1&#39;).value;
            let c1 = document.getElementById(&#39;c1&#39;).value;
            let d1 = document.getElementById(&#39;d1&#39;).value;
            let a2 = document.getElementById(&#39;a2&#39;).value;
            let b2 = document.getElementById(&#39;b2&#39;).value;
            let c2 = document.getElementById(&#39;c2&#39;).value;
            let d2 = document.getElementById(&#39;d2&#39;).value;

            // Construct the LaTeX formula with the input values
            let formula = `&#92;&#92;( &#92;&#92;begin{align*}`;
            formula += `(${a1}+${b1}i+${c1}j+${d1}k)&#92;&#92;odot (${a2}+${b2}i+${c2}j+${d2}k)`;
            formula += `&amp;= (${a1} &#92;&#92;cdot ${a2} - ${b1} &#92;&#92;cdot ${b2} - ${c1} &#92;&#92;cdot ${c2} - ${d1} &#92;&#92;cdot ${d2}) &#92;&#92;&#92;&#92;[8pt]`;
            formula += `&amp;&#92;&#92;quad + (${a1} &#92;&#92;cdot ${b2} + ${b1} &#92;&#92;cdot ${a2} + ${c1} &#92;&#92;cdot ${d2} - ${d1} &#92;&#92;cdot ${c2})i &#92;&#92;&#92;&#92;[8pt]`;
            formula += `&amp;&#92;&#92;quad + (${a1} &#92;&#92;cdot ${c2} + ${c1} &#92;&#92;cdot ${a2} + ${d1} &#92;&#92;cdot ${b2} - ${b1} &#92;&#92;cdot ${d2})j &#92;&#92;&#92;&#92;[8pt]`;
            formula += `&amp;&#92;&#92;quad + (${a1} &#92;&#92;cdot ${d2} + ${d1} &#92;&#92;cdot ${a2} + ${b1} &#92;&#92;cdot ${c2} - ${c1} &#92;&#92;cdot ${b2})k.`;
            formula += `&#92;&#92;end{align*} &#92;&#92;)`;

            // Set the content of the formula div
            document.getElementById(&#39;formula&#39;).innerHTML = formula;

            // Use MathJax to typeset the updated formula
            MathJax.typesetPromise().catch((err) =&gt; console.log(err));
        }
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h2 id=&quot;quaternion-multiplication-formula&quot;&gt;Quaternion Multiplication Formula&lt;/h2&gt;
  &lt;p&gt;&#92;begin{align*}
  (a_1+b_1i+c_1j+d_1k)&#92;odot (a_2+b_2i+c_2j+d_2k) &amp;= (a_1a_2 - b_1b_2 - c_1c_2 - d_1d_2)&#92;&#92;
  &amp;&#92;quad + (a_1b_2 + b_1a_2 + c_1d_2 - d_1c_2)i&#92;&#92;
  &amp;&#92;quad +  (a_1c_2 + c_1a_2 + d_1b_2 - b_1d_2)j &#92;&#92;
  &amp;&#92;quad+ (a_1d_2 + d_1a_2 + b_1c_2 - c_1b_2)k.
  &#92;end{align*}&lt;/p&gt;
    &lt;p&gt;Enter values for quaternion components to display the quaternion multiplication formula:&lt;/p&gt;
    &lt;form&gt;
        Quaternion 1 (a1, b1, c1, d1):&lt;br&gt;
        a1: &lt;input type=&quot;number&quot; id=&quot;a1&quot; value=&quot;1&quot;&gt;&lt;br&gt;
        b1: &lt;input type=&quot;number&quot; id=&quot;b1&quot; value=&quot;0&quot;&gt;&lt;br&gt;
        c1: &lt;input type=&quot;number&quot; id=&quot;c1&quot; value=&quot;0&quot;&gt;&lt;br&gt;
        d1: &lt;input type=&quot;number&quot; id=&quot;d1&quot; value=&quot;0&quot;&gt;&lt;br&gt;&lt;br&gt;
        Quaternion 2 (a2, b2, c2, d2):&lt;br&gt;
        a2: &lt;input type=&quot;number&quot; id=&quot;a2&quot; value=&quot;1&quot;&gt;&lt;br&gt;
        b2: &lt;input type=&quot;number&quot; id=&quot;b2&quot; value=&quot;0&quot;&gt;&lt;br&gt;
        c2: &lt;input type=&quot;number&quot; id=&quot;c2&quot; value=&quot;0&quot;&gt;&lt;br&gt;
        d2: &lt;input type=&quot;number&quot; id=&quot;d2&quot; value=&quot;0&quot;&gt;&lt;br&gt;&lt;br&gt;
        &lt;button type=&quot;button&quot; onclick=&quot;updateFormula()&quot;&gt;Update Formula&lt;/button&gt;
    &lt;/form&gt;
    &lt;p&gt;Quaternion Multiplication Formula:&lt;/p&gt;
    &lt;div id=&quot;formula&quot;&gt;&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</content>
  </entry>
</feed>