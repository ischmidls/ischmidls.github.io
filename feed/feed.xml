<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet href="pretty-atom-feed.xsl" type="text/xsl"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
  <title>izak</title>
  <subtitle>sharing in learning</subtitle>
  <link href="https://ischmidls.github.io/feed/feed.xml" rel="self" />
  <link href="https://ischmidls.github.io/" />
  <updated>2025-03-15T00:00:00Z</updated>
  <id>https://ischmidls.github.io/</id>
  <author>
    <name>Izak Schmidlkofer</name>
  </author>
  <entry>
    <title>note: multifactor anova simulation</title>
    <link href="https://ischmidls.github.io/blog/multifactorsim/" />
    <updated>2025-03-15T00:00:00Z</updated>
    <id>https://ischmidls.github.io/blog/multifactorsim/</id>
    <content type="html">&lt;!-- &lt;iframe src=&quot;https://librarianizak.github.io/multifactor.html&quot;&gt;&lt;/iframe&gt; --&gt;

&lt;h3 id=&quot;multifactor-study-n-1-replicates&quot;&gt;Multifactor Study (&lt;span class=&quot;math inline&quot;&gt;&lt;em&gt;n&lt;/em&gt; &amp;gt; 1&lt;/span&gt; replicates)&lt;/h3&gt;
    &lt;pre&gt;&lt;code&gt;library(dplyr)&lt;/code&gt;&lt;/pre&gt;
    &lt;p&gt;This simulation demonstrates a multifactor ANOVA with treatments,
    blocks, and replicates. We compare an &lt;strong&gt;additive model&lt;/strong&gt;
    (no interaction) and a &lt;strong&gt;saturated model&lt;/strong&gt; (with
    interaction) to analyze the effects of treatments and blocks on a
    response variable.&lt;/p&gt;
    &lt;hr&gt;
    &lt;pre&gt;&lt;code&gt;# Set seed for reproducibility
    set.seed(123)
    
    # Define experimental design parameters
    n_treatments &amp;lt;- 3  # Number of treatments
    n_blocks &amp;lt;- 4       # Number of blocks
    n_replicates &amp;lt;- 2   # Number of replicates per treatment-block combination
    
    # Generate synthetic data
    data &amp;lt;- expand.grid(
      Treatment = factor(paste0(&amp;quot;T&amp;quot;, 1:n_treatments)),
      Block = factor(paste0(&amp;quot;B&amp;quot;, 1:n_blocks)),
      Replicate = 1:n_replicates
    ) %&amp;gt;%
      mutate(
        Response = rnorm(n(), mean = as.numeric(Treatment) + as.numeric(Block), sd = 1)
      )
    
    # Display the first few rows of the data
    head(data)
    ##   Treatment Block Replicate Response
    ## 1        T1    B1         1 1.439524
    ## 2        T2    B1         1 2.769823
    ## 3        T3    B1         1 5.558708
    ## 4        T1    B2         1 3.070508
    ## 5        T2    B2         1 4.129288
    ## 6        T3    B2         1 6.715065&lt;/code&gt;&lt;/pre&gt;
    &lt;p&gt;The synthetic dataset includes &lt;code&gt;Treatment&lt;/code&gt;,
    &lt;code&gt;Block&lt;/code&gt;, and &lt;code&gt;Replicate&lt;/code&gt; factors, with a
    &lt;code&gt;Response&lt;/code&gt; variable generated from a normal distribution. The
    mean of the response depends on the treatment and block, with added
    random noise.&lt;/p&gt;
    &lt;hr&gt;
    &lt;pre&gt;&lt;code&gt;# Perform multifactor ANOVA: Additive model (no interaction)
    additive_model &amp;lt;- aov(Response ~ Treatment + Block, data = data)
    additive_summary &amp;lt;- summary(additive_model)
    additive_summary
    ##             Df Sum Sq Mean Sq F value  Pr(&amp;gt;F)   
    ## Treatment    2  9.832   4.916   4.852 0.02064 * 
    ## Block        3 22.699   7.566   7.467 0.00189 **
    ## Residuals   18 18.239   1.013                   
    ## ---
    ## Signif. codes:  0 &amp;#39;***&amp;#39; 0.001 &amp;#39;**&amp;#39; 0.01 &amp;#39;*&amp;#39; 0.05 &amp;#39;.&amp;#39; 0.1 &amp;#39; &amp;#39; 1
    # Perform multifactor ANOVA: Saturated Model (with interaction)
    saturated_model &amp;lt;- aov(Response ~ Treatment * Block, data = data)
    saturated_summary &amp;lt;- summary(saturated_model)
    saturated_summary
    ##                 Df Sum Sq Mean Sq F value  Pr(&amp;gt;F)   
    ## Treatment        2  9.832   4.916   4.030 0.04583 * 
    ## Block            3 22.699   7.566   6.202 0.00867 **
    ## Treatment:Block  6  3.600   0.600   0.492 0.80270   
    ## Residuals       12 14.639   1.220                   
    ## ---
    ## Signif. codes:  0 &amp;#39;***&amp;#39; 0.001 &amp;#39;**&amp;#39; 0.01 &amp;#39;*&amp;#39; 0.05 &amp;#39;.&amp;#39; 0.1 &amp;#39; &amp;#39; 1&lt;/code&gt;&lt;/pre&gt;
    &lt;p&gt;Two models are fitted: the &lt;strong&gt;additive model&lt;/strong&gt; assumes no
    interaction between treatments and blocks, while the &lt;strong&gt;saturated
    model&lt;/strong&gt; includes an interaction term between treatments and
    blocks.&lt;/p&gt;
    &lt;hr&gt;
    &lt;pre&gt;&lt;code&gt;# Extract D.f. for additive model
    df_treatment_additive &amp;lt;- additive_summary[[1]][&amp;quot;Treatment&amp;quot;, &amp;quot;Df&amp;quot;]
    df_block_additive &amp;lt;- additive_summary[[1]][&amp;quot;Block&amp;quot;, &amp;quot;Df&amp;quot;]
    df_residual_additive &amp;lt;- additive_summary[[1]][&amp;quot;Residuals&amp;quot;, &amp;quot;Df&amp;quot;]
    
    # Extract D.f. for Saturated Model
    df_treatment_saturated &amp;lt;- saturated_summary[[1]][trimws(rownames(saturated_summary[[1]])) == &amp;quot;Treatment&amp;quot;, &amp;quot;Df&amp;quot;]
    df_block_saturated &amp;lt;- saturated_summary[[1]][&amp;quot;Block&amp;quot;, &amp;quot;Df&amp;quot;]
    df_saturated &amp;lt;- saturated_summary[[1]][&amp;quot;Treatment:Block&amp;quot;, &amp;quot;Df&amp;quot;]
    df_residual_saturated &amp;lt;- saturated_summary[[1]][&amp;quot;Residuals&amp;quot;, &amp;quot;Df&amp;quot;]
    
    # Calculate total number of observations
    n_obs &amp;lt;- n_treatments * n_blocks * n_replicates
    
    # Manually calculate df_resid for additive model
    df_resid_additive_manual &amp;lt;- n_obs - (n_treatments + n_blocks - 1)
    
    # Manually calculate df_resid for saturated model
    df_resid_saturated_manual &amp;lt;- n_obs - (n_treatments * n_blocks)&lt;/code&gt;&lt;/pre&gt;
    &lt;p&gt;The total number of observations is calculated as &lt;span class=&quot;math inline&quot;&gt;&lt;em&gt;n&lt;/em&gt; = #treatments × #blocks × #replicates&lt;/span&gt;.
    For the &lt;strong&gt;additive model&lt;/strong&gt;, the residual degrees of freedom
    are &lt;span class=&quot;math inline&quot;&gt;df&lt;sub&gt;residual&lt;/sub&gt; = &lt;em&gt;n&lt;/em&gt; − (#treatments + #blocks − 1)&lt;/span&gt;.
    For the &lt;strong&gt;saturated model&lt;/strong&gt;, the residual degrees of
    freedom are &lt;span class=&quot;math inline&quot;&gt;df&lt;sub&gt;residual&lt;/sub&gt; = &lt;em&gt;n&lt;/em&gt; − (#treatments × #blocks)&lt;/span&gt;.&lt;/p&gt;
    &lt;hr&gt;
    &lt;h4 id=&quot;additive-model-no-interaction&quot;&gt;Additive Model (No
    Interaction)&lt;/h4&gt;
    &lt;pre&gt;&lt;code&gt;# Print results for additive model
    cat(
      &amp;quot;Total number of observations (n) &amp;quot;, n_obs, &amp;quot;&#92;n&amp;quot;,
      &amp;quot;D.f. for Treatment &amp;quot;, df_treatment_additive, &amp;quot;&#92;n&amp;quot;,
      &amp;quot;D.f. for Block &amp;quot;, df_block_additive, &amp;quot;&#92;n&amp;quot;,
      &amp;quot;D.f. for Residuals (ANOVA table) &amp;quot;, df_residual_additive, &amp;quot;&#92;n&amp;quot;,
      &amp;quot;D.f. for Residuals  (manual) &amp;quot;, df_resid_additive_manual, &amp;quot;&#92;n&amp;quot;,
      sep = &amp;quot;&amp;quot;
    )
    ## Total number of observations (n) 24
    ## D.f. for Treatment 2
    ## D.f. for Block 3
    ## D.f. for Residuals (ANOVA table) 18
    ## D.f. for Residuals  (manual) 18&lt;/code&gt;&lt;/pre&gt;
    &lt;h4 id=&quot;saturated-model-with-interaction&quot;&gt;Saturated Model (With
    Interaction)&lt;/h4&gt;
    &lt;pre&gt;&lt;code&gt;# Print results for Saturated Model
    cat(
      &amp;quot;Total number of observations (n) &amp;quot;, n_obs, &amp;quot;&#92;n&amp;quot;,
      &amp;quot;D.f. for Treatment &amp;quot;, df_treatment_saturated, &amp;quot;&#92;n&amp;quot;,
      &amp;quot;D.f. for Block &amp;quot;, df_block_saturated, &amp;quot;&#92;n&amp;quot;,
      &amp;quot;D.f. for Treatment:Block Interaction &amp;quot;, df_saturated, &amp;quot;&#92;n&amp;quot;,
      &amp;quot;D.f. for Residuals  (ANOVA table) &amp;quot;, df_residual_saturated, &amp;quot;&#92;n&amp;quot;,
       &amp;quot;D.f. for Residuals  (manual) &amp;quot;, df_resid_saturated_manual, &amp;quot;&#92;n&amp;quot;,
      sep = &amp;quot;&amp;quot;
    )
    ## Total number of observations (n) 24
    ## D.f. for Treatment 2
    ## D.f. for Block 3
    ## D.f. for Treatment:Block Interaction 6
    ## D.f. for Residuals  (ANOVA table) 12
    ## D.f. for Residuals  (manual) 12&lt;/code&gt;&lt;/pre&gt;
    &lt;h4 id=&quot;results&quot;&gt;Results:&lt;/h4&gt;
    &lt;p&gt;The &lt;strong&gt;additive model&lt;/strong&gt; has larger residual degrees of
    freedom because it does not account for interaction. The
    &lt;strong&gt;saturated model&lt;/strong&gt; includes interaction degrees of
    freedom, reducing the residual degrees of freedom. The total number of
    observations remains the same for both models.&lt;/p&gt;
    &lt;hr&gt;
    &lt;h3 id=&quot;multifactor-study-n-1-replicates-1&quot;&gt;Multifactor Study (&lt;span class=&quot;math inline&quot;&gt;&lt;em&gt;n&lt;/em&gt; = 1&lt;/span&gt; replicates)&lt;/h3&gt;
    &lt;p&gt;This simulation demonstrates two scenarios for analyzing multifactor
    experiments with no replicates: (1) assuming interaction terms are
    insignificant and fitting an additive model, and (2) treating one factor
    as numeric to reduce the number of parameters and estimate residual
    variation.&lt;/p&gt;
    &lt;hr&gt;
    &lt;h4 id=&quot;interaction-terms-are-insignificant-no-replicates&quot;&gt;1.
    Interaction Terms Are Insignificant (No Replicates)&lt;/h4&gt;
    &lt;p&gt;In this scenario, we assume that the interaction between the two
    factors (&lt;code&gt;Treatment&lt;/code&gt; and &lt;code&gt;Block&lt;/code&gt;) is
    insignificant. This allows us to fit an additive model (no interaction)
    even in the absence of replicates, leaving degrees of freedom for
    estimating residual variation.&lt;/p&gt;
    &lt;pre&gt;&lt;code&gt;# Set seed for reproducibility
    set.seed(123)
    
    # Define experimental design parameters
    n_treatments &amp;lt;- 3  # Number of treatments
    n_blocks &amp;lt;- 4       # Number of blocks
    n_replicates &amp;lt;- 1   # No replicates
    
    # Generate synthetic data (no interaction)
    data_no_replicates &amp;lt;- expand.grid(
      Treatment = factor(paste0(&amp;quot;T&amp;quot;, 1:n_treatments)),
      Block = factor(paste0(&amp;quot;B&amp;quot;, 1:n_blocks)),
      Replicate = 1:n_replicates
    ) %&amp;gt;%
      mutate(
        Response = rnorm(n(), mean = as.numeric(Treatment) + as.numeric(Block), sd = 1)
      )
    
    # Fit additive model (no interaction)
    additive_model &amp;lt;- aov(Response ~ Treatment + Block, data = data_no_replicates)
    additive_summary &amp;lt;- summary(additive_model)
    
    # Print ANOVA table
    print(additive_summary)
    ##             Df Sum Sq Mean Sq F value Pr(&amp;gt;F)  
    ## Treatment    2 16.623   8.311   9.068 0.0154 *
    ## Block        3 14.844   4.948   5.398 0.0386 *
    ## Residuals    6  5.499   0.917                 
    ## ---
    ## Signif. codes:  0 &amp;#39;***&amp;#39; 0.001 &amp;#39;**&amp;#39; 0.01 &amp;#39;*&amp;#39; 0.05 &amp;#39;.&amp;#39; 0.1 &amp;#39; &amp;#39; 1&lt;/code&gt;&lt;/pre&gt;
    &lt;hr&gt;
    &lt;h4 id=&quot;one-factor-can-be-treated-as-numeric-no-replicates&quot;&gt;2. One
    Factor Can Be Treated as Numeric (No Replicates)&lt;/h4&gt;
    &lt;p&gt;In this scenario, one of the factors (e.g., &lt;code&gt;Treatment&lt;/code&gt;)
    has three or more numerical levels, and we can model its effect as a
    linear function of the numerical variable. This reduces the number of
    parameters, leaving degrees of freedom for estimating residual
    variation.&lt;/p&gt;
    &lt;pre&gt;&lt;code&gt;# Set seed for reproducibility
    set.seed(123)
    
    # Define experimental design parameters
    n_treatments &amp;lt;- 3  # Number of treatments (numeric levels)
    n_blocks &amp;lt;- 4       # Number of blocks
    n_replicates &amp;lt;- 1   # No replicates
    
    # Generate synthetic data (linear effect of Treatment)
    data_numeric_treatment &amp;lt;- expand.grid(
      Treatment = 1:n_treatments,  # Numeric treatment levels
      Block = factor(paste0(&amp;quot;B&amp;quot;, 1:n_blocks)),
      Replicate = 1:n_replicates
    ) %&amp;gt;%
      mutate(
        Response = rnorm(n(), mean = 2 * Treatment + as.numeric(Block), sd = 1)
      )
    
    # Fit model with Treatment as numeric
    numeric_model &amp;lt;- aov(Response ~ Treatment + Block, data = data_numeric_treatment)
    numeric_summary &amp;lt;- summary(numeric_model)
    
    # Print ANOVA table
    print(numeric_summary)
    ##             Df Sum Sq Mean Sq F value   Pr(&amp;gt;F)    
    ## Treatment    1  47.15   47.15  56.749 0.000134 ***
    ## Block        3  14.84    4.95   5.955 0.024341 *  
    ## Residuals    7   5.82    0.83                     
    ## ---
    ## Signif. codes:  0 &amp;#39;***&amp;#39; 0.001 &amp;#39;**&amp;#39; 0.01 &amp;#39;*&amp;#39; 0.05 &amp;#39;.&amp;#39; 0.1 &amp;#39; &amp;#39; 1&lt;/code&gt;&lt;/pre&gt;
    &lt;hr&gt;
    &lt;h4 id=&quot;differences-between-the-two-scenarios&quot;&gt;Differences Between the
    Two Scenarios&lt;/h4&gt;
    &lt;p&gt;The first scenario assumes no interaction between factors and fits an
    additive model to estimate residual variation. The second scenario
    treats one factor as a numeric variable (linear effect), reducing the
    number of parameters and allowing estimation of residual variation.&lt;/p&gt;
    &lt;pre&gt;&lt;code&gt;anova(additive_model)
    ## Analysis of Variance Table
    ## 
    ## Response: Response
    ##           Df  Sum Sq Mean Sq F value  Pr(&amp;gt;F)  
    ## Treatment  2 16.6226  8.3113  9.0679 0.01536 *
    ## Block      3 14.8440  4.9480  5.3984 0.03857 *
    ## Residuals  6  5.4994  0.9166                  
    ## ---
    ## Signif. codes:  0 &amp;#39;***&amp;#39; 0.001 &amp;#39;**&amp;#39; 0.01 &amp;#39;*&amp;#39; 0.05 &amp;#39;.&amp;#39; 0.1 &amp;#39; &amp;#39; 1
    anova(numeric_model)
    ## Analysis of Variance Table
    ## 
    ## Response: Response
    ##           Df Sum Sq Mean Sq F value    Pr(&amp;gt;F)    
    ## Treatment  1 47.149  47.149 56.7492 0.0001335 ***
    ## Block      3 14.844   4.948  5.9555 0.0243415 *  
    ## Residuals  7  5.816   0.831                      
    ## ---
    ## Signif. codes:  0 &amp;#39;***&amp;#39; 0.001 &amp;#39;**&amp;#39; 0.01 &amp;#39;*&amp;#39; 0.05 &amp;#39;.&amp;#39; 0.1 &amp;#39; &amp;#39; 1&lt;/code&gt;&lt;/pre&gt;
    &lt;p&gt;The additive model treats &lt;code&gt;Treatment&lt;/code&gt; as a categorical
    variable with 2 degrees of freedom, yielding a sum of squares of 16.62,
    a mean square of 8.31, an F-value of 9.07, and a p-value of 0.015. In
    contrast, the numeric model treats &lt;code&gt;Treatment&lt;/code&gt; as a numeric
    variable with 1 degree of freedom, resulting in a larger sum of squares
    (47.15), mean square (47.15), and F-value (56.75), with a highly
    significant p-value (0.0001). Both models show significant effects for
    &lt;code&gt;Block&lt;/code&gt;, but the numeric model explains more variation in the
    response variable through the linear effect of &lt;code&gt;Treatment&lt;/code&gt;,
    as evidenced by the higher F-value and lower p-value. This suggests that
    modeling &lt;code&gt;Treatment&lt;/code&gt; as a numeric variable provides a better
    fit for the data in this case than eliminating interactions.&lt;/p&gt;
    &lt;p&gt;Modeling &lt;code&gt;Treatment&lt;/code&gt; as a numeric variable will
    &lt;strong&gt;not always provide a better fit&lt;/strong&gt; for the data than
    eliminating interactions. Whether this approach improves the fit depends
    on the underlying relationship between the &lt;code&gt;Treatment&lt;/code&gt;
    variable and the response. If the true relationship between
    &lt;code&gt;Treatment&lt;/code&gt; and the response is &lt;strong&gt;linear&lt;/strong&gt;, then
    treating &lt;code&gt;Treatment&lt;/code&gt; as numeric can provide a better fit by
    reducing the number of parameters and capturing the trend more
    efficiently. However, if the relationship is &lt;strong&gt;nonlinear&lt;/strong&gt;
    or if there are significant interactions between &lt;code&gt;Treatment&lt;/code&gt;
    and other factors (e.g., &lt;code&gt;Block&lt;/code&gt;), then treating
    &lt;code&gt;Treatment&lt;/code&gt; as numeric may oversimplify the model and lead to
    a poorer fit. In such cases, retaining &lt;code&gt;Treatment&lt;/code&gt; as a
    categorical variable and eliminating insignificant interactions (if
    justified) might be more appropriate. The choice of model should be
    guided by diagnostic checks, such as residual analysis, lack-of-fit
    tests, and domain knowledge, to ensure the model accurately reflects the
    data structure.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>note: multiple linear regression simulation</title>
    <link href="https://ischmidls.github.io/blog/mlrsim/" />
    <updated>2025-03-15T00:00:00Z</updated>
    <id>https://ischmidls.github.io/blog/mlrsim/</id>
    <content type="html">&lt;h2 id=&quot;simulating-data-and-fitting-a-multiple-linear-regression-model&quot;&gt;Simulating
Data and Fitting a Multiple Linear Regression Model&lt;/h2&gt;
&lt;p&gt;In this example, we simulate data and fit a multiple linear
regression model to it. We then manually calculate the adjusted
R-squared and F-statistic to compare with the values provided by the
model summary.&lt;/p&gt;
&lt;h3 id=&quot;simulating-data&quot;&gt;Simulating Data&lt;/h3&gt;
&lt;p&gt;First, we set the seed for reproducibility and simulate the data:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# Set seed for reproducibility
set.seed(123)

# Simulate data
n &amp;lt;- 30  # Number of observations
x1 &amp;lt;- rnorm(n, mean = 10, sd = 2)  # Continuous predictor 1
x2 &amp;lt;- rnorm(n, mean = 5, sd = 1)   # Continuous predictor 2
x3 &amp;lt;- factor(sample(c(&amp;quot;A&amp;quot;, &amp;quot;B&amp;quot;, &amp;quot;C&amp;quot;), n, replace = TRUE))  # Categorical predictor with 3 levels
x4 &amp;lt;- rnorm(n, mean = 0, sd = 1)   # Continuous predictor 3

# Simulate response variable (y) based on the predictors
y &amp;lt;- 2 + 1.5 * x1 + 0.8 * x2 + ifelse(x3 == &amp;quot;B&amp;quot;, 3, ifelse(x3 == &amp;quot;C&amp;quot;, 5, 0)) + 1.2 * x4 + rnorm(n, mean = 0, sd = 1)

# Combine data into a data frame
data &amp;lt;- data.frame(y, x1, x2, x3, x4)

# Preview
head(data)
##          y        x1       x2 x3          x4
## 1 18.49021  8.879049 5.426464  A -0.78273028
## 2 25.53604  9.539645 4.704929  C -0.77899724
## 3 32.70612 13.117417 5.895126  C -0.37480009
## 4 27.01636 10.141017 5.878133  C -0.31939381
## 5 24.88084 10.258575 5.821581  B  0.08454377
## 6 28.92555 13.430130 5.688640  B -0.76847360&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;fitting-the-multiple-linear-regression-model&quot;&gt;Fitting the
Multiple Linear Regression Model&lt;/h3&gt;
&lt;p&gt;Next, we fit the multiple linear regression model and compare summary
with anova output:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# Fit the multiple linear regression model
mlr_model &amp;lt;- lm(y ~ x1 + x2 + x3 + x4, data = data)

# Display the summary of the model
summary(mlr_model)
## 
## Call:
## lm(formula = y ~ x1 + x2 + x3 + x4, data = data)
## 
## Residuals:
##     Min      1Q  Median      3Q     Max 
## -1.6234 -0.4573 -0.1174  0.6899  1.2926 
## 
## Coefficients:
##             Estimate Std. Error t value Pr(&amp;gt;|t|)    
## (Intercept) -0.71889    1.36357  -0.527 0.602887    
## x1           1.65819    0.07951  20.854  &amp;lt; 2e-16 ***
## x2           0.84485    0.18675   4.524 0.000139 ***
## x3B          4.43388    0.42597  10.409 2.23e-10 ***
## x3C          6.44933    0.46137  13.979 4.99e-13 ***
## x4           1.25028    0.23694   5.277 2.06e-05 ***
## ---
## Signif. codes:  0 &amp;#39;***&amp;#39; 0.001 &amp;#39;**&amp;#39; 0.01 &amp;#39;*&amp;#39; 0.05 &amp;#39;.&amp;#39; 0.1 &amp;#39; &amp;#39; 1
## 
## Residual standard error: 0.8099 on 24 degrees of freedom
## Multiple R-squared:  0.9708, Adjusted R-squared:  0.9648 
## F-statistic: 159.8 on 5 and 24 DF,  p-value: &amp;lt; 2.2e-16
anova(mlr_model)
## Analysis of Variance Table
## 
## Response: y
##           Df Sum Sq Mean Sq  F value    Pr(&amp;gt;F)    
## x1         1 335.74  335.74 511.8012 &amp;lt; 2.2e-16 ***
## x2         1   2.97    2.97   4.5347   0.04367 *  
## x3         2 167.31   83.66 127.5251 1.638e-13 ***
## x4         1  18.27   18.27  27.8451 2.065e-05 ***
## Residuals 24  15.74    0.66                       
## ---
## Signif. codes:  0 &amp;#39;***&amp;#39; 0.001 &amp;#39;**&amp;#39; 0.01 &amp;#39;*&amp;#39; 0.05 &amp;#39;.&amp;#39; 0.1 &amp;#39; &amp;#39; 1&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;checking-adjusted-r-squared-manually&quot;&gt;Checking Adjusted
R-squared Manually&lt;/h3&gt;
&lt;p&gt;We can manually calculate the adjusted R-squared and compare it with
the value from the model summary:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# Extract necessary values
SSE &amp;lt;- sum(residuals(mlr_model)^2)  # Sum of squared errors
SST &amp;lt;- sum((y - mean(y))^2)         # Total sum of squares
ptrue &amp;lt;- length(coef(mlr_model))        # Number of parameters (including intercept)

# Number of continuous predictors
num_continuous &amp;lt;- sum(sapply(data, is.numeric)) - 1  # Subtract 1 to exclude the response variable (y)

# Number of levels in the categorical predictor
num_levels &amp;lt;- length(levels(data$x3))

# Total number of parameters (p)
p &amp;lt;- 1 + num_continuous + (num_levels - 1)

cat(&amp;quot;Total number of parameters (p):&amp;quot;, p, &amp;quot;like the number of mlr coefficients &amp;quot;, ptrue,&amp;quot;&#92;n&amp;quot;)
## Total number of parameters (p): 6 like the number of mlr coefficients  6
# Compute Adjusted R-squared manually
adjusted_r_squared &amp;lt;- 1 - (SSE / SST) * ((n - 1) / (n - p))

# Compare with the Adjusted R-squared from the model summary
cat(&amp;quot;Adjusted R-squared (manual):&amp;quot;, adjusted_r_squared, &amp;quot;&#92;n&amp;quot;)
## Adjusted R-squared (manual): 0.964773
cat(&amp;quot;Adjusted R-squared (from model):&amp;quot;, summary(mlr_model)$adj.r.squared, &amp;quot;&#92;n&amp;quot;)
## Adjusted R-squared (from model): 0.964773&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;observed-mean-observed-and-fitted-values-for-sum-of-squares&quot;&gt;Observed,
Mean Observed, and Fitted Values for Sum of Squares&lt;/h3&gt;
&lt;p&gt;In regression analysis, let &lt;span class=&quot;math inline&quot;&gt;&lt;em&gt;y&lt;/em&gt;&lt;sub&gt;&lt;em&gt;i&lt;/em&gt;&lt;/sub&gt;&lt;/span&gt; (observed,
blue) represent the actual data points, &lt;span class=&quot;math inline&quot;&gt;&lt;em&gt;ŷ&lt;/em&gt;&lt;sub&gt;&lt;em&gt;i&lt;/em&gt;&lt;/sub&gt;&lt;/span&gt; (fitted,
green) denote the predicted values from the model, and &lt;span class=&quot;math inline&quot;&gt;&lt;em&gt;ȳ&lt;/em&gt;&lt;/span&gt; (mean of observed values, purple)
be the average of the observed data. The reference line &lt;span class=&quot;math inline&quot;&gt;&lt;em&gt;y&lt;/em&gt; = &lt;em&gt;x&lt;/em&gt;&lt;/span&gt; (red) serves as a 1:1
comparison line. The total sum of squares (SST), &lt;span class=&quot;math inline&quot;&gt;$&#92;text{SST} = &#92;sum_{i = 1}^{n}&#92;left( y_{i} - &#92;bar{y}
&#92;right)^{2}$&lt;/span&gt;, quantifies the total variation in &lt;span class=&quot;math inline&quot;&gt;&lt;em&gt;y&lt;/em&gt;&lt;sub&gt;&lt;em&gt;i&lt;/em&gt;&lt;/sub&gt;&lt;/span&gt;. This can be
decomposed into the sum of squared errors (SSE), &lt;span class=&quot;math inline&quot;&gt;$&#92;text{SSE} = &#92;sum_{i = 1}^{n}&#92;left( y_{i} -
{&#92;widehat{y}}_{i} &#92;right)^{2}$&lt;/span&gt;, capturing the deviation of &lt;span class=&quot;math inline&quot;&gt;&lt;em&gt;y&lt;/em&gt;&lt;sub&gt;&lt;em&gt;i&lt;/em&gt;&lt;/sub&gt;&lt;/span&gt; from &lt;span class=&quot;math inline&quot;&gt;&lt;em&gt;ŷ&lt;/em&gt;&lt;sub&gt;&lt;em&gt;i&lt;/em&gt;&lt;/sub&gt;&lt;/span&gt;, and the sum
of squares due to regression (SSR), &lt;span class=&quot;math inline&quot;&gt;$&#92;text{SSR} = &#92;sum_{i = 1}^{n}&#92;left(
{&#92;widehat{y}}_{i} - &#92;bar{y} &#92;right)^{2}$&lt;/span&gt;, representing the
variation explained by the model, such that &lt;span class=&quot;math inline&quot;&gt;SST = SSE + SSR&lt;/span&gt; or equivalently, &lt;span class=&quot;math inline&quot;&gt;$&#92;sum_{i = 1}^{n}&#92;left( y_{i} - &#92;bar{y} &#92;right)^{2}
= &#92;sum_{i = 1}^{n}&#92;left( y_{i} - {&#92;widehat{y}}_{i} &#92;right)^{2} + &#92;sum_{i
= 1}^{n}&#92;left( {&#92;widehat{y}}_{i} - &#92;bar{y} &#92;right)^{2}$&lt;/span&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;library(ggplot2)
# Add fitted values to the data frame
data$Fitted &amp;lt;- fitted(mlr_model)

# Calculate the mean of the observed values
mean_y &amp;lt;- mean(data$y)

# Create the plot
ggplot(data, aes(x = Fitted, y = y)) +
  geom_point(aes(color = &amp;quot;Observed&amp;quot;), alpha = 0.7) +  # Observed values
  geom_point(aes(y = Fitted, color = &amp;quot;Fitted&amp;quot;), alpha = 0.7) +  # Fitted values
  geom_abline(aes(slope = 1, intercept = 0, color = &amp;quot;Reference Line (y = x)&amp;quot;), linetype = &amp;quot;dashed&amp;quot;) +  # Reference line (y = x)
  geom_hline(aes(yintercept = mean_y, color = &amp;quot;Mean of Observed Values&amp;quot;), linetype = &amp;quot;dotted&amp;quot;) +  # Mean of observed values
  labs(
    title = &amp;quot;Observed vs. Fitted Values&amp;quot;,
    x = &amp;quot;Fitted Values (Predicted)&amp;quot;,
    y = &amp;quot;Observed Values (Actual)&amp;quot;,
    color = &amp;quot;Legend&amp;quot;
  ) +
  theme_minimal() +
  theme(
    legend.position = &amp;quot;bottom&amp;quot;,
    plot.title = element_text(hjust = 0.5, face = &amp;quot;bold&amp;quot;)
  ) +
  scale_color_manual(values = c(
    &amp;quot;Observed&amp;quot; = &amp;quot;blue&amp;quot;,
    &amp;quot;Fitted&amp;quot; = &amp;quot;green&amp;quot;,
    &amp;quot;Reference Line (y = x)&amp;quot; = &amp;quot;red&amp;quot;,
    &amp;quot;Mean of Observed Values&amp;quot; = &amp;quot;purple&amp;quot;
  ))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://ischmidls.github.io/blog/mlrsim/IwOoJmLkyM-1155.png&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;checking-f-statistic-manually&quot;&gt;Checking F-statistic
Manually&lt;/h3&gt;
&lt;p&gt;Finally, we manually calculate the F-statistic and compare it with
the value from the model summary:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;coef(mlr_model)
## (Intercept)          x1          x2         x3B         x3C          x4 
##  -0.7188876   1.6581923   0.8448530   4.4338831   6.4493264   1.2502829
# Extract necessary values
SSR &amp;lt;- sum((fitted(mlr_model) - mean(y))^2)  # Regression sum of squares
SSE &amp;lt;- sum(residuals(mlr_model)^2)           # Residual sum of squares
n &amp;lt;- nrow(data)                              # Number of observations
p &amp;lt;- length(coef(mlr_model)) - 1             # Number of predictors (excluding intercept)

# Degrees of freedom
df_regression &amp;lt;- p
df_residual &amp;lt;- n - p - 1

# Calculate MSR and MSE
MSR &amp;lt;- SSR / df_regression
MSE &amp;lt;- SSE / df_residual

# Calculate F-statistic
F_statistic &amp;lt;- MSR / MSE

# Compare with the F-statistic from the model summary
cat(&amp;quot;F-statistic (manual):&amp;quot;, F_statistic, &amp;quot;&#92;n&amp;quot;)
## F-statistic (manual): 159.8462
cat(&amp;quot;F-statistic (from model):&amp;quot;, summary(mlr_model)$fstatistic[1], &amp;quot;&#92;n&amp;quot;)
## F-statistic (from model): 159.8462&lt;/code&gt;&lt;/pre&gt;</content>
  </entry>
  <entry>
    <title>unknown variance of concave distribution</title>
    <link href="https://ischmidls.github.io/blog/unknownvariance/" />
    <updated>2025-02-14T00:00:00Z</updated>
    <id>https://ischmidls.github.io/blog/unknownvariance/</id>
    <content type="html">&lt;script type=&quot;text/x-mathjax-config&quot;&gt;
    MathJax.Hub.Config({
      jax: [&quot;input/TeX&quot;, &quot;output/HTML-CSS&quot;],
      extensions: [&quot;tex2jax.js&quot;],
      &quot;HTML-CSS&quot;: { preferredFont: &quot;TeX&quot;, availableFonts: [&quot;STIX&quot;,&quot;TeX&quot;] },
      tex2jax: { inlineMath: [ [&quot;$&quot;, &quot;$&quot;], [&quot;&#92;&#92;(&quot;,&quot;&#92;&#92;)&quot;] ], displayMath: [ [&quot;$$&quot;,&quot;$$&quot;], [&quot;&#92;&#92;[&quot;, &quot;&#92;&#92;]&quot;] ], processEscapes: true, ignoreClass: &quot;tex2jax_ignore|dno&quot; },
      TeX: { noUndefined: { attributes: { mathcolor: &quot;red&quot;, mathbackground: &quot;#FFEEEE&quot;, mathsize: &quot;90%&quot; } } },
      messageStyle: &quot;none&quot;
    });
    &lt;/script&gt;    
    &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;A strange fact that was not immediately obvious to me is that
    variance of a uniform distribution on &lt;span class=&quot;math inline&quot;&gt;&#92;([a,b]&#92;)&lt;/span&gt; can act as a conservative estimate
    for unknown variance &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;sigma^2&#92;)&lt;/span&gt; of
    many other distributions, namely convex distributions on &lt;span class=&quot;math inline&quot;&gt;&#92;([a,b]&#92;)&lt;/span&gt;.&lt;/p&gt;
    &lt;p&gt;The uniform distribution on &lt;span class=&quot;math inline&quot;&gt;&#92;([a,b]&#92;)&lt;/span&gt; has variance &lt;span class=&quot;math inline&quot;&gt;&#92;((b-a)^2/12&#92;)&lt;/span&gt;. For any concave distribution
    on &lt;span class=&quot;math inline&quot;&gt;&#92;([a,b]&#92;)&lt;/span&gt; (where the PDF lies above
    any line segment joining two points on its graph), the variance &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;sigma^2&#92;)&lt;/span&gt; satisfies &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;sigma^2 &#92;le (b-a)^2/12&#92;)&lt;/span&gt;. This holds
    because any concave PDF is unimodal, and on &lt;span class=&quot;math inline&quot;&gt;&#92;([0,1]&#92;)&lt;/span&gt;, the variance of a distribution
    with mean &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;mu&#92;)&lt;/span&gt; cannot exceed &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;mu(2-3&#92;mu)/3&#92;)&lt;/span&gt; for &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;mu &#92;le 1/2&#92;)&lt;/span&gt; or &lt;span class=&quot;math inline&quot;&gt;&#92;((1-&#92;mu)(3&#92;mu-1)/3&#92;)&lt;/span&gt; for &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;mu &#92;ge 1/2&#92;)&lt;/span&gt;, neither of which exceeds
    &lt;span class=&quot;math inline&quot;&gt;&#92;(1/12&#92;)&lt;/span&gt;. It takes some work to show
    this, which we’ll expand on shortly. But, rescaling to &lt;span class=&quot;math inline&quot;&gt;&#92;([a,b]&#92;)&lt;/span&gt; gives the general result. A tighter
    bound exists when the mean &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;mu&#92;)&lt;/span&gt; is
    known: for &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;mu &#92;le (a+b)/2&#92;)&lt;/span&gt;, &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;sigma^2 &#92;le (&#92;mu-a)(2b+a-3&#92;mu)/3&#92;)&lt;/span&gt;, with a
    symmetric expression for &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;mu &amp;gt;
    (a+b)/2&#92;)&lt;/span&gt;.&lt;/p&gt;
    &lt;p&gt;The supremum of the variance of unimodal distributions on &lt;span class=&quot;math inline&quot;&gt;&#92;([0,1]&#92;)&lt;/span&gt; with mean &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;mu&#92;)&lt;/span&gt; is &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;mu(2
    - 3&#92;mu)/3&#92;)&lt;/span&gt; for &lt;span class=&quot;math inline&quot;&gt;&#92;(0 &#92;le &#92;mu &#92;le
    1/2&#92;)&lt;/span&gt; or &lt;span class=&quot;math inline&quot;&gt;&#92;((1-&#92;mu)(3&#92;mu-1)/3&#92;)&lt;/span&gt;
    for &lt;span class=&quot;math inline&quot;&gt;&#92;(1/2 &#92;le &#92;mu &#92;le 1&#92;)&lt;/span&gt;. This
    supremum is achieved by a distribution that, while lacking a density
    function, can be considered “unimodal” in a generalized sense.
    Specifically, it has a point mass at &lt;span class=&quot;math inline&quot;&gt;&#92;(0&#92;)&lt;/span&gt; (when &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;mu
    &amp;lt; 1/2&#92;)&lt;/span&gt;) or at &lt;span class=&quot;math inline&quot;&gt;&#92;(1&#92;)&lt;/span&gt; (when
    &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;mu &amp;gt; 1/2&#92;)&lt;/span&gt;), with the rest of the
    distribution being uniform.&lt;/p&gt;
    &lt;p&gt;To derive this, we optimize the second moment &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;mathbb{E}[x^2]&#92;)&lt;/span&gt; of a unimodal
    distribution on &lt;span class=&quot;math inline&quot;&gt;&#92;([0,1]&#92;)&lt;/span&gt; under the
    constraints of normalization (&lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;int_0^1 f(x)
    &#92;, dx = 1&#92;)&lt;/span&gt;), mean &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;mathbb{E}&#92;)&lt;/span&gt; &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;int_0^1 x f(x) &#92;, dx = &#92;mu&#92;)&lt;/span&gt;, and
    unimodality (non-increasing density on either side of a mode &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;lambda&#92;)&lt;/span&gt;). The optimal distribution is
    piecewise constant, with density &lt;span class=&quot;math inline&quot;&gt;&#92;(a = (1 +
    &#92;lambda - 2&#92;mu)/&#92;lambda&#92;)&lt;/span&gt; on &lt;span class=&quot;math inline&quot;&gt;&#92;([0,&#92;lambda)&#92;)&lt;/span&gt; and &lt;span class=&quot;math inline&quot;&gt;&#92;(b = (2&#92;mu - &#92;lambda)/(1 - &#92;lambda)&#92;)&lt;/span&gt; on
    &lt;span class=&quot;math inline&quot;&gt;&#92;((&#92;lambda,1]&#92;)&lt;/span&gt;. The second moment
    &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;mathbb{E}[x^2] = &#92;frac{1}{3}(2&#92;mu + (2&#92;mu -
    1)&#92;lambda)&#92;)&lt;/span&gt; is linear in &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;lambda&#92;)&lt;/span&gt;, so it is maximized at &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;lambda = 0&#92;)&lt;/span&gt; (for &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;mu &amp;lt; 1/2&#92;)&lt;/span&gt;) or &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;lambda = 1&#92;)&lt;/span&gt; (for &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;mu &amp;gt; 1/2&#92;)&lt;/span&gt;). When &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;mu = 1/2&#92;)&lt;/span&gt;, the second moment is constant
    for all &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;lambda&#92;)&lt;/span&gt;.&lt;/p&gt;
    &lt;p&gt;In the limits, the optimal distribution approaches a uniform
    distribution with a point mass at &lt;span class=&quot;math inline&quot;&gt;&#92;(0&#92;)&lt;/span&gt;
    (for &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;mu &amp;lt; 1/2&#92;)&lt;/span&gt;) or at &lt;span class=&quot;math inline&quot;&gt;&#92;(1&#92;)&lt;/span&gt; (for &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;mu
    &amp;gt; 1/2&#92;)&lt;/span&gt;). These distributions, though not continuous, satisfy
    the unimodality condition and achieve the supremum of the variance &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;sigma^2_&#92;mu&#92;)&lt;/span&gt;.&lt;/p&gt;
    &lt;hr&gt;
    &lt;p&gt;Note: Recall how to find the variance of a uniform distribution X on &lt;span class=&quot;math inline&quot;&gt;&#92;([a,b]&#92;)&lt;/span&gt;.&lt;/p&gt;
    &lt;p&gt;We know variance is the difference of moments &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;mathbb{V}[X] = &#92;mathbb{E}[X^2] - (&#92;mathbb{E}
        [X])^2&#92;)&lt;/span&gt;.&lt;/p&gt;
        &lt;p&gt;As we see &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;mathbb{E} [X] =
        &#92;frac{1}{b-a}&#92;int_{[a,b]}x dx = &#92;frac{a+b}{2}&#92;)&lt;/span&gt;, and &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;mathbb{E} [X^2] = &#92;frac{1}{b-a}&#92;int_{[a,b]}x^2 dx
        = &#92;frac{b^3-a^3}{3(b-a)}=&#92;frac{a^2+ab+b^2}{3}&#92;)&lt;/span&gt;, we then see
        &lt;span class=&quot;math display&quot;&gt;&#92;[
        &#92;mathbb{V} [X] = &#92;frac{a^2+ab+b^2}{3} - &#92;frac{a^2+2ab+b^2}{4} =
        &#92;frac{a^2-2ab+b^2}{12} =&#92;frac{(b-a)^2}{12}
        &#92;]&lt;/span&gt;&lt;/p&gt;
    &lt;p&gt;Inspired by &lt;a href=&quot;https://stats.stackexchange.com/a/143981/422593&quot;&gt;this discussion&lt;/a&gt; and also &lt;a href=&quot;https://stats.stackexchange.com/a/143984/422593&quot;&gt;this discussion&lt;/a&gt;, with help from &lt;a href=&quot;https://math.stackexchange.com/a/728072/1098426&quot;&gt;this calculation&lt;/a&gt;&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>note: complex derivatives and matrices</title>
    <link href="https://ischmidls.github.io/blog/complexdiff/" />
    <updated>2025-02-12T00:00:00Z</updated>
    <id>https://ischmidls.github.io/blog/complexdiff/</id>
    <content type="html">&lt;script type=&quot;text/x-mathjax-config&quot;&gt;
    MathJax.Hub.Config({
      jax: [&quot;input/TeX&quot;, &quot;output/HTML-CSS&quot;],
      extensions: [&quot;tex2jax.js&quot;],
      &quot;HTML-CSS&quot;: { preferredFont: &quot;TeX&quot;, availableFonts: [&quot;STIX&quot;,&quot;TeX&quot;] },
      tex2jax: { inlineMath: [ [&quot;$&quot;, &quot;$&quot;], [&quot;&#92;&#92;(&quot;,&quot;&#92;&#92;)&quot;] ], displayMath: [ [&quot;$$&quot;,&quot;$$&quot;], [&quot;&#92;&#92;[&quot;, &quot;&#92;&#92;]&quot;] ], processEscapes: true, ignoreClass: &quot;tex2jax_ignore|dno&quot; },
      TeX: { noUndefined: { attributes: { mathcolor: &quot;red&quot;, mathbackground: &quot;#FFEEEE&quot;, mathsize: &quot;90%&quot; } } },
      messageStyle: &quot;none&quot;
    });
    &lt;/script&gt;    
    &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;For a complex function $ f(x + iy) = u(x, y) + iv(x, y) $, the Jacobian matrix is $&#92;mathbf{J} = &#92;begin{pmatrix} &#92;frac{&#92;partial u}{&#92;partial x} &amp; &#92;frac{&#92;partial v}{&#92;partial x} &#92;&#92; &#92;frac{&#92;partial u}{&#92;partial y} &amp; &#92;frac{&#92;partial v}{&#92;partial y} &#92;end{pmatrix}$.
&lt;/p&gt;

&lt;p&gt;For $ f $ to be complex differentiable, $ &#92;mathbf{J} $ must satisfy the Cauchy-Riemann equations $&#92;frac{&#92;partial u}{&#92;partial x} = &#92;frac{&#92;partial v}{&#92;partial y} &#92;quad &#92;text{and} &#92;quad &#92;frac{&#92;partial u}{&#92;partial y} = -&#92;frac{&#92;partial v}{&#92;partial x}.$
&lt;/p&gt;

&lt;p&gt;When these hold, $ &#92;mathbf{J} $ takes the form $&#92;mathbf{J} = &#92;begin{pmatrix} a &amp; -b &#92;&#92; b &amp; a &#92;end{pmatrix}$, where $ a = &#92;frac{&#92;partial u}{&#92;partial x} = &#92;frac{&#92;partial v}{&#92;partial y} $ and $ b = &#92;frac{&#92;partial v}{&#92;partial x} = -&#92;frac{&#92;partial u}{&#92;partial y} $. This matrix corresponds to the complex number $ a + bi $, reflecting the fact that the derivative of a complex function is itself a complex number. For example, for $ f(z) = z^2 $, the Jacobian is $&#92;mathbf{J} = &#92;begin{pmatrix} 2x &amp; 2y &#92;&#92; -2y &amp; 2x &#92;end{pmatrix}$, which corresponds to $ 2x + 2iy $.
&lt;/p&gt;

&lt;p&gt;The matrix representation of complex numbers as $ &#92;begin{pmatrix} a &amp; -b &#92;&#92; b &amp; a &#92;end{pmatrix} $ naturally follows from the geometric interpretation of complex multiplication and De Moivre&#39;s Theorem. A complex number $ z = a + bi $ can be written in polar form as $ z = r (&#92;cos &#92;theta + i &#92;sin &#92;theta) $, where $ r = &#92;sqrt{a^2 + b^2} $ is the magnitude and $ &#92;theta $ is the argument. Multiplication by $ z $ corresponds to scaling by $ r $ and rotating by $ &#92;theta $.
&lt;/p&gt;

&lt;p&gt;The rotation matrix for an angle $ &#92;theta $ is $&#92;begin{pmatrix} &#92;cos &#92;theta &amp; -&#92;sin &#92;theta &#92;&#92; &#92;sin &#92;theta &amp; &#92;cos &#92;theta &#92;end{pmatrix}.$
&lt;/p&gt;

&lt;p&gt;Multiplying this by the scaling factor $ r $ gives $r &#92;begin{pmatrix} &#92;cos &#92;theta &amp; -&#92;sin &#92;theta &#92;&#92; &#92;sin &#92;theta &amp; &#92;cos &#92;theta &#92;end{pmatrix} = &#92;begin{pmatrix} a &amp; -b &#92;&#92; b &amp; a &#92;end{pmatrix}$, where $ a = r &#92;cos &#92;theta $ and $ b = r &#92;sin &#92;theta $. This matches the matrix representation of $ z = a + bi $. Thus, the matrix form $ &#92;begin{pmatrix} a &amp; -b &#92;&#92; b &amp; a &#92;end{pmatrix} $ naturally encodes both scaling and rotation, reflecting the geometric action of complex multiplication as described by De Moivre&#39;s Theorem.
&lt;/p&gt;

&lt;p&gt;For example, the function $f(z) = z$ has $u(x, y) = x$ and $v(x, y) = y$, yielding the Jacobian $&#92;mathbf{J} = &#92;begin{pmatrix} 1 &amp; 0 &#92;&#92; 0 &amp; 1 &#92;end{pmatrix}$, corresponding to $1 + 0i$. &lt;/p&gt;
&lt;p&gt;For $f(z) = z^2$, we have $u(x, y) = x^2 - y^2$ and $v(x, y) = 2xy$, giving the Jacobian $&#92;mathbf{J} = &#92;begin{pmatrix} 2x &amp; 2y &#92;&#92; -2y &amp; 2x &#92;end{pmatrix}$, which corresponds to $2x + 2iy$. &lt;/p&gt;
&lt;p&gt;And for $f(z) = e^z$, we get $u(x, y) = e^x &#92;cos y$ and $v(x, y) = e^x &#92;sin y$, resulting in the Jacobian $&#92;mathbf{J} = &#92;begin{pmatrix} e^x &#92;cos y &amp; -e^x &#92;sin y &#92;&#92; e^x &#92;sin y &amp; e^x &#92;cos y &#92;end{pmatrix}$, corresponding to $e^z$.&lt;/p&gt;



&lt;p&gt;Inspired by &lt;a href=&quot;https://math.stackexchange.com/a/1448085/1098426&quot;&gt;this&lt;/a&gt; discussion.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>irreducible divisors</title>
    <link href="https://ischmidls.github.io/blog/irreddivisors/" />
    <updated>2025-01-14T00:00:00Z</updated>
    <id>https://ischmidls.github.io/blog/irreddivisors/</id>
    <content type="html">&lt;!DOCTYPE html&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; lang=&quot;&quot; xml:lang=&quot;&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;utf-8&quot;&gt;
  &lt;meta name=&quot;generator&quot; content=&quot;pandoc&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, user-scalable=yes&quot;&gt;
  &lt;title&gt;Untitled&lt;/title&gt;
  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;p&gt;Here is a proof I struggled with in the spring of 2024 that I wanted
to come back to. To start, this proof gives nice motivation for an
abstract area of math called Galois theory which is most famous for
showing that there’s no “quadratic formula” or closed expression for the
roots of a polynomial of degrees greater than four. But another
interesting motivation is in coding theory, where finite fields and
their polynomials can construct error-correcting codes. For example,
Reed-Solomon codes encode data as polynomials over a finite field &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;mathbb{F}_{2^m}&#92;)&lt;/span&gt;. The proof that
irreducible polynomials divide &lt;span class=&quot;math inline&quot;&gt;&#92;(x^{p^n} -
x&#92;)&lt;/span&gt; ensures that the roots of these polynomials lie within &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;mathbb{F}_{2^m}&#92;)&lt;/span&gt;, making encoding and
decoding efficient. This property allows Reed-Solomon codes to detect
and correct errors in data transmission, such as in CDs or QR codes. By
adding &lt;span class=&quot;math inline&quot;&gt;&#92;(t = n - k&#92;)&lt;/span&gt; check symbols to
the data, Reed-Solomon codes can detect any combination of up to &lt;span class=&quot;math inline&quot;&gt;&#92;(t&#92;)&lt;/span&gt; erroneous symbols, or locate and
correct up to &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;lfloor t/2 &#92;rfloor&#92;)&lt;/span&gt;
erroneous symbols at unknown locations.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;We want to show every irreducible polynomial &lt;span class=&quot;math inline&quot;&gt;&#92;(p(x)&#92;)&lt;/span&gt; over a finite field of prime
characteristic &lt;span class=&quot;math inline&quot;&gt;&#92;(F_p&#92;)&lt;/span&gt; is a divisor of
&lt;span class=&quot;math inline&quot;&gt;&#92;(x^{p^n}-x&#92;)&lt;/span&gt; for some natural number
&lt;span class=&quot;math inline&quot;&gt;&#92;(n&#92;)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;First, as a lemma, we’ll show every finite field &lt;span class=&quot;math inline&quot;&gt;&#92;(F&#92;)&lt;/span&gt; is perfect, meaning every irreducible
polynomial over &lt;span class=&quot;math inline&quot;&gt;&#92;(F&#92;)&lt;/span&gt; has no multiple
roots in any field extension over &lt;span class=&quot;math inline&quot;&gt;&#92;(F&#92;)&lt;/span&gt;, or equivalently, every irreducible
polynomial over &lt;span class=&quot;math inline&quot;&gt;&#92;(F&#92;)&lt;/span&gt; is separable, or
its roots are distinct in an algebraic closure of &lt;span class=&quot;math inline&quot;&gt;&#92;(F&#92;)&lt;/span&gt;, so the number of distinct roots is
equal to the degree of the polynomial.&lt;/p&gt;
&lt;p&gt;Say &lt;span class=&quot;math inline&quot;&gt;&#92;(F&#92;)&lt;/span&gt; is a finite field of
characteristic &lt;span class=&quot;math inline&quot;&gt;&#92;(p&#92;)&lt;/span&gt;. Say &lt;span class=&quot;math inline&quot;&gt;&#92;(f&#92;)&lt;/span&gt; maps &lt;span class=&quot;math inline&quot;&gt;&#92;(F&#92;)&lt;/span&gt; to &lt;span class=&quot;math inline&quot;&gt;&#92;(F&#92;)&lt;/span&gt; by &lt;span class=&quot;math inline&quot;&gt;&#92;(f(x) =
x^p&#92;)&lt;/span&gt; for any &lt;span class=&quot;math inline&quot;&gt;&#92;(x &#92;in F&#92;)&lt;/span&gt;. See
&lt;span class=&quot;math inline&quot;&gt;&#92;(f&#92;)&lt;/span&gt; is a field automorphism as &lt;span class=&quot;math inline&quot;&gt;&#92;(f(ab) = (ab)^p = a^p b^p = f(a) f(b)&#92;)&lt;/span&gt; and
&lt;span class=&quot;math inline&quot;&gt;&#92;(f(a+b) = (a+b)^p = a^p + &#92;binom{p}{1}
a^{p-1} b + &#92;binom{p}{2} a^{p-2}b^2 + &#92;dots + &#92;binom{p}{p-1}ab^{p-1} +
b^p = a^p + b^p&#92;)&lt;/span&gt;as &lt;span class=&quot;math inline&quot;&gt;&#92;(p&#92;)&lt;/span&gt;
divides &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;binom{p}{i}&#92;)&lt;/span&gt;. And, &lt;span class=&quot;math inline&quot;&gt;&#92;(x &#92;neq 0&#92;)&lt;/span&gt; gives &lt;span class=&quot;math inline&quot;&gt;&#92;(x^p &#92;neq 0&#92;)&lt;/span&gt;, so &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;ker f = &#92;{0&#92;}&#92;)&lt;/span&gt;. Then &lt;span class=&quot;math inline&quot;&gt;&#92;(f&#92;)&lt;/span&gt; is injective and as &lt;span class=&quot;math inline&quot;&gt;&#92;(F&#92;)&lt;/span&gt; is finite, &lt;span class=&quot;math inline&quot;&gt;&#92;(f&#92;)&lt;/span&gt; injective gives &lt;span class=&quot;math inline&quot;&gt;&#92;(f&#92;)&lt;/span&gt; surjective. We see then &lt;span class=&quot;math inline&quot;&gt;&#92;(F^p = F&#92;)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;Now, to show any irreducible polynomial over &lt;span class=&quot;math inline&quot;&gt;&#92;(F_p&#92;)&lt;/span&gt; divides &lt;span class=&quot;math inline&quot;&gt;&#92;(x^{p^n}-x&#92;)&lt;/span&gt;, say &lt;span class=&quot;math inline&quot;&gt;&#92;(p(x)&#92;)&lt;/span&gt; is an irreducible polynomial of
degree &lt;span class=&quot;math inline&quot;&gt;&#92;(m&#92;)&lt;/span&gt; in &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;mathbb{F}_p[x]&#92;)&lt;/span&gt;. Let &lt;span class=&quot;math inline&quot;&gt;&#92;(K&#92;)&lt;/span&gt; be the finite extension of &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;mathbb{F}_p&#92;)&lt;/span&gt; obtained by adjoining all
the zeros of &lt;span class=&quot;math inline&quot;&gt;&#92;(p(x)&#92;)&lt;/span&gt; in &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;overline{&#92;mathbb{F}_p}&#92;)&lt;/span&gt;, the algebraic
closure of &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;mathbb{F}_p&#92;)&lt;/span&gt;. Then &lt;span class=&quot;math inline&quot;&gt;&#92;(K&#92;)&lt;/span&gt; is a finite field of order &lt;span class=&quot;math inline&quot;&gt;&#92;(p^n&#92;)&lt;/span&gt; for some positive integer &lt;span class=&quot;math inline&quot;&gt;&#92;(n&#92;)&lt;/span&gt;, and consists precisely of all zeros of
&lt;span class=&quot;math inline&quot;&gt;&#92;(x^{p^n} - x&#92;)&lt;/span&gt; in &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;overline{&#92;mathbb{F}_p}&#92;)&lt;/span&gt;. Now &lt;span class=&quot;math inline&quot;&gt;&#92;(p(x)&#92;)&lt;/span&gt; factors into linear factors in &lt;span class=&quot;math inline&quot;&gt;&#92;(K[x]&#92;)&lt;/span&gt;, as the linear factors of &lt;span class=&quot;math inline&quot;&gt;&#92;(x^{p^n} - x&#92;)&lt;/span&gt; in &lt;span class=&quot;math inline&quot;&gt;&#92;(K[x]&#92;)&lt;/span&gt; include these linear factors, and
&lt;span class=&quot;math inline&quot;&gt;&#92;(p(x)&#92;)&lt;/span&gt; has no repeated roots since we
showed every finite field is perfect. Thus, &lt;span class=&quot;math inline&quot;&gt;&#92;(p(x)&#92;)&lt;/span&gt; is a divisor of &lt;span class=&quot;math inline&quot;&gt;&#92;(x^{p^n} - x&#92;)&lt;/span&gt;.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</content>
  </entry>
  <entry>
    <title>complete categories</title>
    <link href="https://ischmidls.github.io/blog/alllimits/" />
    <updated>2025-01-08T00:00:00Z</updated>
    <id>https://ischmidls.github.io/blog/alllimits/</id>
    <content type="html">&lt;script type=&quot;text/x-mathjax-config&quot;&gt;
    MathJax.Hub.Config({
      jax: [&quot;input/TeX&quot;, &quot;output/HTML-CSS&quot;],
      extensions: [&quot;tex2jax.js&quot;],
      &quot;HTML-CSS&quot;: { preferredFont: &quot;TeX&quot;, availableFonts: [&quot;STIX&quot;,&quot;TeX&quot;] },
      tex2jax: { inlineMath: [ [&quot;$&quot;, &quot;$&quot;], [&quot;&#92;&#92;(&quot;,&quot;&#92;&#92;)&quot;] ], displayMath: [ [&quot;$$&quot;,&quot;$$&quot;], [&quot;&#92;&#92;[&quot;, &quot;&#92;&#92;]&quot;] ], processEscapes: true, ignoreClass: &quot;tex2jax_ignore|dno&quot; },
      TeX: { noUndefined: { attributes: { mathcolor: &quot;red&quot;, mathbackground: &quot;#FFEEEE&quot;, mathsize: &quot;90%&quot; } } },
      messageStyle: &quot;none&quot;
    });
    &lt;/script&gt;    
    &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;To prove that the forgetful functor &#92;( U: &#92;text{Vect}_k &#92;to &#92;text{Set} &#92;) is monadic, we need to show that it satisfies the conditions of monadicity, as given by Beck&#39;s Monadicity Theorem. The forgetful functor &#92;( U &#92;) maps a vector space over a field &#92;( k &#92;) to its underlying set and maps linear transformations to their underlying functions. 
&lt;/p&gt;
&lt;p&gt; 
The forgetful functor &#92;( U: &#92;text{Vect}_k &#92;to &#92;text{Set} &#92;) has a left adjoint &#92;( F: &#92;text{Set} &#92;to &#92;text{Vect}_k &#92;), which is the free vector space functor. For a set &#92;( X &#92;), &#92;( F(X) &#92;) is the vector space whose basis is &#92;( X &#92;). The adjunction is given by the natural isomorphism:
&#92;[
&#92;text{Hom}_{&#92;text{Vect}_k}(F(X), V) &#92;simeq &#92;text{Hom}_{&#92;text{Set}}(X, U(V)),
&#92;]
where &#92;( V &#92;) is a vector space and &#92;( X &#92;) is a set. This shows that &#92;( U &#92;) is a right adjoint.
&lt;/p&gt;


&lt;p&gt; The adjunction &#92;( F &#92;dashv U &#92;) induces a monad &#92;( T = UF &#92;) on &#92;( &#92;text{Set} &#92;).
First, for a set &#92;( X &#92;), &#92;( T(X) = U(F(X)) &#92;) is the underlying set of the free vector space generated by &#92;( X &#92;). This is the set of formal linear combinations of elements of &#92;( X &#92;) with coefficients in &#92;( k &#92;).
Second, the unit &#92;( &#92;eta_X: X &#92;to T(X) &#92;) maps an element &#92;( x &#92;in X &#92;) to the corresponding basis vector in &#92;( F(X) &#92;).
Third, the multiplication &#92;( &#92;mu_X: T(T(X)) &#92;to T(X) &#92;) is the linear map that &quot;flattens&quot; formal linear combinations of formal linear combinations into formal linear combinations.
&lt;/p&gt;


&lt;p&gt; 
Beck&#39;s Monadicity Theorem states that a functor &#92;( U &#92;) is monadic if:
&#92;((1.)&#92;) &#92;( U &#92;) has a left adjoint, 
&#92;((2.)&#92;) &#92;( U &#92;) reflects isomorphisms, and 
&#92;((3.)&#92;) &#92;( U &#92;) preserves and reflects coequalizers of &#92;( U &#92;)-split pairs.
&lt;/p&gt;
&lt;p&gt; 
This third condition might be least familiar. Wikipedia&#39;s descriptions for this are not as subpar as they often are. First, (&#92;( U &#92;)-split pairs are those parallel pairs of morphisms in $&#92;text{Vect}_k$, which $U$ sends to pairs having a split coequalizer in $&#92;text{Set} $). Second, in the category of sets, the coequalizer of two functions &#92;( f, g: X &#92;to Y &#92;) is the quotient of &#92;( Y &#92;) by the smallest equivalence relation &#92;( &#92;sim &#92;) satisfying &#92;( f(x) &#92;sim g(x) &#92;) for every &#92;( x &#92;in X &#92;). For example, if &#92;( R &#92;) is an equivalence relation on a set &#92;( Y &#92;), and &#92;( r_1, r_2: R &#92;to Y &#92;) are the natural projections (where &#92;( R &#92;subseteq Y &#92;times Y &#92;)), then the coequalizer of &#92;( r_1 &#92;) and &#92;( r_2 &#92;) is the quotient set &#92;( Y / R &#92;). 
&lt;/p&gt;
&lt;p&gt; 
Before looking at &#92;( U &#92;)-split pair in &#92;( &#92;text{Vect}_k &#92;), let&#39;s verify the first two conditions.
&lt;/p&gt;
&lt;p&gt; 
For $(1)$, we already showed &#92;( U &#92;) has a left adjoint.
&lt;/p&gt;
&lt;p&gt; 
For $(2)$, a linear transformation &#92;( f: V &#92;to W &#92;) is an isomorphism in &#92;( &#92;text{Vect}_k &#92;) if and only if it is bijective. Since &#92;( U &#92;) maps &#92;( f &#92;) to its underlying function, &#92;( U(f) &#92;) is an isomorphism in &#92;( &#92;text{Set} &#92;) (i.e., a bijection) if and only if &#92;( f &#92;) is an isomorphism in &#92;( &#92;text{Vect}_k &#92;). Thus, &#92;( U &#92;) reflects isomorphisms.
&lt;/p&gt;
&lt;p&gt; 
For $(3)$, a &#92;( U &#92;)-split pair in &#92;( &#92;text{Vect}_k &#92;) consists of linear maps &#92;( f, g: V &#92;to W &#92;) such that there exist set-theoretic maps &#92;( h: U(W) &#92;to U(V) &#92;) and &#92;( k: U(W) &#92;to U(W) &#92;) making &#92;( U(f), U(g) &#92;) a split pair in &#92;( &#92;text{Set} &#92;). The coequalizer of &#92;( f, g &#92;) in &#92;( &#92;text{Vect}_k &#92;) is the quotient space &#92;( W / &#92;text{Im}(f - g) &#92;), and &#92;( U &#92;) maps this to the set-theoretic coequalizer of &#92;( U(f), U(g) &#92;) in &#92;( &#92;text{Set} &#92;). Since &#92;( U &#92;) is a right adjoint, it preserves coequalizers of &#92;( U &#92;)-split pairs. Moreover, because &#92;( U &#92;) reflects isomorphisms and the splitting conditions ensure that the coequalizer in &#92;( &#92;text{Set} &#92;) lifts uniquely to &#92;( &#92;text{Vect}_k &#92;), &#92;( U &#92;) also reflects coequalizers of &#92;( U &#92;)-split pairs. Thus, &#92;( U &#92;) preserves and reflects such coequalizers.
&lt;/p&gt;

&lt;!-- https://q.uiver.app/#q=WzAsNCxbMCwwLCJWIl0sWzEsMCwiVyJdLFsyLDAsIlcgLyBcXHRleHR7SW19KGYgLSBnKSJdLFsyLDEsIloiXSxbMCwxLCJmIiwwLHsib2Zmc2V0IjotMX1dLFsxLDIsIlxccGkiXSxbMSwzLCJcXHBpJyIsMl0sWzIsMywiXFxleGlzdHMgISBcXCwgaCIsMCx7InN0eWxlIjp7ImJvZHkiOnsibmFtZSI6ImRhc2hlZCJ9fX1dLFswLDEsImciLDIseyJvZmZzZXQiOjF9XV0= --&gt;
&lt;iframe class=&quot;quiver-embed&quot; src=&quot;https://q.uiver.app/#q=WzAsNCxbMCwwLCJWIl0sWzEsMCwiVyJdLFsyLDAsIlcgLyBcXHRleHR7SW19KGYgLSBnKSJdLFsyLDEsIloiXSxbMCwxLCJmIiwwLHsib2Zmc2V0IjotMX1dLFsxLDIsIlxccGkiXSxbMSwzLCJcXHBpJyIsMl0sWzIsMywiXFxleGlzdHMgISBcXCwgaCIsMCx7InN0eWxlIjp7ImJvZHkiOnsibmFtZSI6ImRhc2hlZCJ9fX1dLFswLDEsImciLDIseyJvZmZzZXQiOjF9XV0=&amp;embed&quot; width=&quot;553&quot; height=&quot;304&quot; style=&quot;border-radius: 8px; border: none;&quot;&gt;&lt;/iframe&gt;
&lt;p&gt; 
In particular, in &#92;(&#92;text{Vect}_k&#92;), let &#92;(V&#92;) and &#92;(W&#92;) be vector spaces, and let &#92;(f, g: V &#92;to W&#92;) be linear maps. The coequalizer of &#92;(f&#92;) and &#92;(g&#92;) is the quotient space &#92;(W / &#92;text{Im}(f - g)&#92;), equipped with the canonical projection map &#92;(&#92;pi: W &#92;to W / &#92;text{Im}(f - g)&#92;). For any vector space &#92;(Z&#92;) and linear map &#92;(&#92;pi&#39;: W &#92;to Z&#92;) satisfying &#92;(&#92;pi&#39; &#92;circ f = &#92;pi&#39; &#92;circ g&#92;), there exists a unique linear map &#92;(h: W / &#92;text{Im}(f - g) &#92;to Z&#92;) induced by the universal property of the coequalizer, such that &#92;(&#92;pi&#39; = h &#92;circ &#92;pi&#92;). This universal property characterizes the coequalizer in &#92;(&#92;text{Vect}_k&#92;). 
&lt;/p&gt;
&lt;p&gt; 
As the forgetful functor &#92;( U: &#92;text{Vect}_k &#92;to &#92;text{Set} &#92;) satisfies all the conditions of Beck&#39;s Monadicity Theorem, it is monadic. This particularly means that &#92;( &#92;text{Vect}_k &#92;) is equivalent to the category of algebras over the monad &#92;( T = UF &#92;) on &#92;( &#92;text{Set} &#92;).
&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Now, the nice thing is that $&#92;text{Set}$ has all limits by design. Since the canoncial forgetful functor from $&#92;text{Vect}_k$ is monadic, we see $&#92;text{Vect}_k$ also has all limits.

  It remains to show that the category of chain complexes $ &#92;text{CH}(k) $ has all limits. We can do this analogously to how we showed $&#92;text{Vect}_k$ has all limits given $&#92;text{Set}$ has all limits.
  
  &lt;/p&gt;
  
  &lt;p&gt;To prove that the category of chain complexes $ &#92;text{CH}(k) $ is a reflective subcategory of a category of functors into $ &#92;text{Vect}_k $, we need to show that the inclusion functor $ i: &#92;text{CH}(k) &#92;to &#92;text{Fun}(&#92;mathcal{C}, &#92;text{Vect}_k) $ has a left adjoint. This left adjoint is called the reflector, and it provides a way to &quot;reflect&quot; objects from the larger category (functors into $ &#92;text{Vect}_k $) back into the subcategory $ &#92;text{CH}(k) $.&lt;/p&gt;&lt;p&gt;  Let $ &#92;text{Vect}_k $ be the category of vector spaces over a field $ k $.&lt;/p&gt;&lt;p&gt;  Let $ &#92;text{CH}(k) $ be the category of chain complexes of $ k $-vector spaces. Objects are sequences of vector spaces $ (C_n)_{n &#92;in &#92;mathbb{Z}} $ with differentials $ d_n: C_n &#92;to C_{n-1} $ such that $ d_{n-1} &#92;circ d_n = 0 $, and morphisms are chain maps.&lt;/p&gt;&lt;p&gt;  Let $ &#92;mathcal{C} $ be a small category, and let $ &#92;text{Fun}(&#92;mathcal{C}, &#92;text{Vect}_k) $ be the category of functors from $ &#92;mathcal{C} $ to $ &#92;text{Vect}_k $. Objects are functors $ F: &#92;mathcal{C} &#92;to &#92;text{Vect}_k $, and morphisms are natural transformations.&lt;/p&gt;&lt;p&gt;  Consider the category $ &#92;mathcal{C} = &#92;mathbb{Z} $, where $ &#92;mathbb{Z} $ is viewed as a poset category (with objects integers and a unique morphism $ n &#92;to m $ iff $ n &#92;geq m $).&lt;/p&gt;&lt;p&gt;  A functor $ F: &#92;mathbb{Z} &#92;to &#92;text{Vect}_k $ assigns a vector space $ F(n) $ to each integer $ n $ and a linear map $ F(n &#92;to m): F(n) &#92;to F(m) $ for each $ n &#92;geq m $.&lt;/p&gt;&lt;p&gt;  A chain complex $ (C_n, d_n) $ can be viewed as a functor $ F: &#92;mathbb{Z} &#92;to &#92;text{Vect}_k $, where $ F(n) = C_n $ and $ F(n &#92;to n-1) = d_n $, with the condition $ d_{n-1} &#92;circ d_n = 0 $.&lt;/p&gt;&lt;p&gt;   Thus, $ &#92;text{CH}(k) $ is a subcategory of $ &#92;text{Fun}(&#92;mathbb{Z}, &#92;text{Vect}_k) $.&lt;/p&gt;&lt;p&gt;  To show that $ &#92;text{CH}(k) $ is a reflective subcategory, we need to construct a left adjoint $ L: &#92;text{Fun}(&#92;mathbb{Z}, &#92;text{Vect}_k) &#92;to &#92;text{CH}(k) $ to the inclusion functor $ i: &#92;text{CH}(k) &#92;to &#92;text{Fun}(&#92;mathbb{Z}, &#92;text{Vect}_k) $.&lt;/p&gt;&lt;p&gt;  For a functor $ F &#92;in &#92;text{Fun}(&#92;mathbb{Z}, &#92;text{Vect}_k) $, define $ L(F) $ as the chain complex obtained by &quot;forcing&quot; the condition $ d_{n-1} &#92;circ d_n = 0 $.&lt;/p&gt;&lt;p&gt;To construct the chain complex $ L(F) $ from a functor $ F: &#92;mathbb{Z} &#92;to &#92;text{Vect}_k $, we start by defining $ L(F)_n = F(n) $ and the differential $ d_n = F(n &#92;to n-1) $. However, this does not automatically satisfy the chain complex condition $ d_{n-1} &#92;circ d_n = 0 $. To enforce this condition, we modify $ L(F)_n $ by taking the quotient of $ F(n) $ by the image of $ d_{n+1}: F(n+1) &#92;to F(n) $, particularly submodule generated by this image. This quotient ensures that the composition $ d_{n-1} &#92;circ d_n $ becomes zero, as the image of $ d_{n+1} $ is factored out. The resulting object $ L(F) $ is now a chain complex, as the differentials satisfy the required condition $ d_{n-1} &#92;circ d_n = 0 $. This process of quotienting effectively &quot;reflects&quot; the functor $ F $ into the subcategory of chain complexes.&lt;/p&gt;&lt;p&gt;  The reflector $ L $ is left adjoint to the inclusion functor $ i $. We see there is a natural isomorphism:&lt;/p&gt;&lt;p&gt;     $$&#92;text{Hom}_{&#92;text{CH}(k)}(L(F), C) &#92;simeq &#92;text{Hom}_{&#92;text{Fun}(&#92;mathbb{Z}, &#92;text{Vect}_k)}(F, i(C))$$&lt;/p&gt;&lt;p&gt;     for all $ F &#92;in &#92;text{Fun}(&#92;mathbb{Z}, &#92;text{Vect}_k) $ and $ C &#92;in &#92;text{CH}(k) $.&lt;/p&gt;&lt;p&gt;  This adjunction arises because $ L(F) $ is the &quot;best approximation&quot; of $ F $ as a chain complex, and morphisms from $ L(F) $ to $ C $ correspond naturally to morphisms from $ F $ to $ i(C) $.&lt;/p&gt;&lt;p&gt;  Since the inclusion functor $ i: &#92;text{CH}(k) &#92;to &#92;text{Fun}(&#92;mathbb{Z}, &#92;text{Vect}_k) $ has a left adjoint $ L $, the category $ &#92;text{CH}(k) $ is a reflective subcategory of $ &#92;text{Fun}(&#92;mathbb{Z}, &#92;text{Vect}_k) $.&lt;/p&gt;
  &lt;p&gt;A category where all limits exist is called a &quot;complete category&quot;.&lt;/p&gt;
  &lt;hr&gt;

  These notes were inspired by a remark in &lt;a href=&quot;https://youtu.be/5uI0uJpsEhI?si=f8G1Y0ylOOewxhhG&quot;&gt;this&lt;/a&gt; video.</content>
  </entry>
  <entry>
    <title>textcraft</title>
    <link href="https://ischmidls.github.io/blog/textcraft/" />
    <updated>2025-01-04T00:00:00Z</updated>
    <id>https://ischmidls.github.io/blog/textcraft/</id>
    <content type="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Minecraft Text Adventure&lt;/title&gt;
    &lt;style&gt;
        body {
            font-family: monospace;
            background-color: white;
            color: black;
            margin: 0;
            padding: 20px;
        }
        #output {
            white-space: pre-line;
            margin-bottom: 20px;
            max-height: 400px;
            overflow-y: auto;
        }
        #input {
            width: 100%;
            padding: 10px;
            font-family: monospace;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;output&quot;&gt;Welcome to text-based Minecraft! Type a command (or help) to begin...&lt;/div&gt;
    &lt;input id=&quot;input&quot; type=&quot;text&quot; placeholder=&quot;Enter your command here...&quot; autofocus=&quot;&quot;&gt;
    
     &lt;script&gt;
const output = document.getElementById(&quot;output&quot;);
const input = document.getElementById(&quot;input&quot;);

const biomes = [&#39;Forest Biome&#39;, &#39;Grasslands Biome&#39;, &#39;Desert Biome&#39;]; // Sample biomes
let inventory = [];
// add coordinates
let coordinates = [0,64,0];
const blocks = [&#39;Dirt&#39;, &#39;Cobblestone&#39;, &#39;Coal&#39;, &#39;Diamond&#39;];
const ores = [&#39;Iron Ore&#39;, &#39;Gold Ore&#39;];
const ingots = [&#39;Iron Ingot&#39;, &#39;Gold Ingot&#39;];
const monsters = [&#39;Zombie&#39;, &#39;Creeper&#39;, &#39;Enderman&#39;, &#39;Skeleton&#39;, &#39;Spider&#39;, &#39;Drowned&#39;, &#39;Stray&#39;];
const caves = [&#39;Dripstone Cavern&#39;, &#39;Lush Cave&#39;, &#39;Ravine&#39;, &#39;Cave&#39;, &#39;Abandoned Mineshaft&#39;, &#39;Dungeon&#39;];
let gameState = &quot;idle&quot;; // Track the current state of the game
let currentBiome = &quot;&quot;; // Store the biome during exploration
let experience = 0;
let monster_health = 20;
let player_attack_damage = 1;
let player_health = 20;
let monster_attack_damage = 5;
let void_fall = false;
let slain_by_monster = false;
let mining_strength = 0
const items = {
    &quot;Wooden Sword&quot;: {
        recipe: new Array(2).fill(&quot;Plank&quot;).concat(new Array(1).fill(&quot;Stick&quot;)),
        damage: 1,
        miningStrength: 0,
    },
    &quot;Wooden Pickaxe&quot;: {
        recipe: new Array(3).fill(&quot;Plank&quot;).concat(new Array(2).fill(&quot;Stick&quot;)),
        damage: 1,
        miningStrength: 1,
    },
    &quot;Cobblestone Sword&quot;: {
        recipe: new Array(2).fill(&quot;Cobblestone&quot;).concat(new Array(1).fill(&quot;Stick&quot;)),
        damage: 2,
        miningStrength: 0,
    },
    &quot;Cobblestone Pickaxe&quot;: {
        recipe: new Array(3).fill(&quot;Cobblestone&quot;).concat(new Array(2).fill(&quot;Stick&quot;)),
        damage: 2,
        miningStrength: 2,
    },
    &quot;Iron Sword&quot;: {
        recipe: new Array(2).fill(&quot;Iron&quot;).concat(new Array(1).fill(&quot;Stick&quot;)),
        damage: 3,
        miningStrength: 0,
    },
    &quot;Iron Pickaxe&quot;: {
        recipe: new Array(3).fill(&quot;Iron&quot;).concat(new Array(2).fill(&quot;Stick&quot;)),
        damage: 3,
        miningStrength: 3,
    },
    &quot;Gold Sword&quot;: {
        recipe: new Array(2).fill(&quot;Gold&quot;).concat(new Array(1).fill(&quot;Stick&quot;)),
        damage: 3,
        miningStrength: 0,
    },
    &quot;Gold Pickaxe&quot;: {
        recipe: new Array(3).fill(&quot;Gold&quot;).concat(new Array(2).fill(&quot;Stick&quot;)),
        damage: 3,
        miningStrength: 3,
    },
    &quot;Diamond Sword&quot;: {
        recipe: new Array(2).fill(&quot;Diamond&quot;).concat(new Array(1).fill(&quot;Stick&quot;)),
        damage: 3,
        miningStrength: 0,
    },
    &quot;Diamond Pickaxe&quot;: {
        recipe: new Array(3).fill(&quot;Diamond&quot;).concat(new Array(2).fill(&quot;Stick&quot;)),
        damage: 4,
        miningStrength: 4,
    },
};


const toTitleCase = (str) =&gt; {
    return str.replace(
        /&#92;w&#92;S*/g,
        text =&gt; text.charAt(0).toUpperCase() + text.substring(1).toLowerCase()
    );
}

const appendOutput = (text) =&gt; {
    output.textContent += `&#92;n${text}`;
    output.scrollTop = output.scrollHeight; // Scroll to bottom
};

const startEquip = () =&gt; {
    gameState = &quot;equip&quot;
    appendOutput(&quot;What would you like to equip? (or exit)&quot;)
}

const handleEquip = (command) =&gt; {
    const item = items[toTitleCase(command)];

    if (item) {
        // Update global variables based on the item&#39;s properties
        player_attack_damage = item.damage;
        mining_strength = item.miningStrength;
        appendOutput(
            `Equipped ${command}. Attack damage is now ${player_attack_damage}, and mining strength is ${mining_strength}.`
        );
    } else if (command.toLowerCase() === &quot;exit&quot;) {
        gameState = &quot;idle&quot;
        appendOutput(&quot;Exiting equip&quot;)
    } else {
        appendOutput(`Item &quot;${command}&quot; not found.`);
    }
            &quot;That&#39;s not an item?&quot;
    }


const startExplore = () =&gt; {
    currentBiome = biomes[Math.floor(Math.random() * biomes.length)];
    gameState = &quot;explore&quot;; // Transition to the explore state
    coordinates[0] += Math.floor(Math.random() * 64)
    coordinates[1] += Math.floor(Math.random() * 64)
    appendOutput(`You are now exploring the ${currentBiome}. What resource would you like to collect?`);
    appendOutput(&quot;You can collect seeds or wood from compatible biomes.&quot;);
    appendOutput(&quot;Type &#39;exit&#39; to leave or &#39;explore&#39; to keep exploring&#39;.&quot;);
};

const handleExplore = (command) =&gt; {
    switch (command.toLowerCase()) {
        case &quot;wood&quot;:
            if (currentBiome === &quot;Forest Biome&quot;) {
                appendOutput(&quot;You collected three wood and two sticks!&quot;);
                inventory.push(&quot;Wood&quot;, &quot;Wood&quot;, &quot;Wood&quot;, &quot;Stick&quot;, &quot;Stick&quot;);
            } else {
                appendOutput(&quot;You cannot collect wood here.&quot;);
            }
            break;
        case &quot;seeds&quot;:
            if (currentBiome === &quot;Grasslands Biome&quot;) {
                appendOutput(&quot;You collected five seeds!&quot;);
                inventory.push(&quot;seed&quot;, &quot;seed&quot;, &quot;seed&quot;, &quot;seed&quot;, &quot;seed&quot;);
            } else {
                appendOutput(&quot;You cannot collect seeds here.&quot;);
            }
            break;
        case &quot;exit&quot;:
            appendOutput(&quot;Exiting exploration...&quot;);
            gameState = &quot;idle&quot;; // Return to the idle state
            break;
        case &quot;explore&quot;:
            appendOutput(&quot;You continue to explore...&quot;)
            startExplore()
            break;
        default:
            appendOutput(&quot;Invalid resource. Please specify &#39;wood&#39; or &#39;seeds&#39;, or type &#39;exit&#39; to leave.&quot;);
    }
};

const startMine = () =&gt; {
    currentCave = caves[Math.floor(Math.random() * caves.length)];
    gameState = &quot;mine&quot;; // Transition to the explore state
    appendOutput(`You are now exploring the ${currentCave}. What resource would you like to collect?`);
    appendOutput(&quot;Type &#39;cobblestone&#39; or &#39;dirt&#39; to collect. Type &#39;exit&#39; to leave or &#39;mine&#39; to continue.&quot;);
    appendOutput(&quot;Greater treasures appear at lower depths.&quot;)
};

// function mine() {
//     const move = Math.floor(Math.random() * 5) + 1
//     if (coordinates[2] &lt;= -50 &amp;&amp; move === 1 &amp;&amp; mining_strength &gt;= 3) {
//         appendOutput(&quot;You mined a Diamond&quot;);
//         inventory.push(&quot;Diamond&quot;);
//     } else if (coordinates[2] &lt;= -50 &amp;&amp; move === 1) {
//         appendOutput(&quot;You found a Diamond but need at least an Iron Pickaxe&quot;);
//     } else if (coordinates[2] &lt;= -30 &amp;&amp; [2,3].includes(move) &amp;&amp; mining_strength &gt;= 3) {
//         appendOutput(&quot;You mined three Gold Ore&quot;);
//         inventory.concat(new Array(3).fill(&quot;Gold Ore&quot;));
//     } else if (coordinates[2] &lt;= -30 &amp;&amp; [2,3].includes(move)) {
//         appendOutput(&quot;You found Gold but need at least an Iron Pickaxe&quot;);
//     } else if (coordinates[2] &lt;= -20 &amp;&amp; [2,3,4].includes(move) &amp;&amp; mining_strength &gt;= 2) {
//         appendOutput(&quot;You mined three Iron Ore&quot;);
//         inventory.concat(new Array(3).fill(&quot;Iron Ore&quot;));
//     } else if (coordinates[2] &lt;= -20 &amp;&amp; [2,3,4].includes(move)) {
//         appendOutput(&quot;You found Iron but need at least a Cobblestone Pickaxe&quot;);
//     } else if (coordinates[2] &lt;= -10 &amp;&amp; [2,3,4,5].includes(move) &amp;&amp; mining_strength &gt;= 1) {
//         appendOutput(&quot;You mined three Coal&quot;)
//         inventory.concat(new Array(3).fill(&quot;Coal&quot;))
//     }  else if (coordinates[2] &lt;= -20 &amp;&amp; [2,3,4].includes(move)) {
//         appendOutput(&quot;You found Coal but need at least a Wooden Pickaxe&quot;);
//     }
// }

function mine() {
    const miningRules = [
        {
            depth: -50,
            moves: [1],
            requiredStrength: 3,
            reward: { item: &quot;Diamond&quot;, amount: 1 },
            failureMessage: &quot;You found a Diamond but need at least an Iron Pickaxe&quot;,
        },
        {
            depth: -30,
            moves: [2, 3],
            requiredStrength: 3,
            reward: { item: &quot;Gold Ore&quot;, amount: 3 },
            failureMessage: &quot;You found Gold but need at least an Iron Pickaxe&quot;,
        },
        {
            depth: -20,
            moves: [2, 3, 4],
            requiredStrength: 2,
            reward: { item: &quot;Iron Ore&quot;, amount: 3 },
            failureMessage: &quot;You found Iron but need at least a Cobblestone Pickaxe&quot;,
        },
        {
            depth: -10,
            moves: [2, 3, 4, 5],
            requiredStrength: 1,
            reward: { item: &quot;Coal&quot;, amount: 3 },
            failureMessage: &quot;You found Coal but need at least a Wooden Pickaxe&quot;,
        },
    ];

    const move = Math.floor(Math.random() * 5) + 1;

    for (const rule of miningRules) {
        if (coordinates[2] &lt;= rule.depth &amp;&amp; rule.moves.includes(move)) {
            if (mining_strength &gt;= rule.requiredStrength) {
                appendOutput(`You mined ${rule.reward.amount} ${rule.reward.item}(s)`);
                inventory.push(...new Array(rule.reward.amount).fill(rule.reward.item));
            } else {
                appendOutput(rule.failureMessage);
            }
            return; // Exit after the first match
        }
    }
}


const handleCoordinates = () =&gt; {
    if (coordinates[2] &lt;= -64) {
        appendOutput(&quot;You hit bedrock!&quot;)
    } else if (mining_strength &lt; 1 &amp;&amp; coordinates[2] &lt;= -10) { 
        appendOutput(&quot;You need a pickaxe to go deeper.&quot;)
    } else {
        coordinates[2] -= Math.floor(Math.random() * 16)
    }
}

const handleMine = (command) =&gt; {
    handleCoordinates()
    mine()
    switch (command.toLowerCase()) {
        case &quot;cobblestone&quot;:
            if (mining_strength === 0) {
                appendOutput(&quot;You need at least a wooden pickaxe for cobblestone.&quot;)
                break;
            }
            appendOutput(&quot;You collected three Cobblestone!&quot;);
            inventory.concat(new Array(3).fill(&quot;Cobblestone&quot;));
            break;
        case &quot;dirt&quot;:
            appendOutput(&quot;You collected three Dirt!&quot;);
            inventory.concat(new Array(3).fill(&quot;Dirt&quot;));
            break;
        case &quot;mine&quot;:
            appendOutput(&quot;You delve deeper&quot;)
            startMine()
            break;
        case &quot;exit&quot;:
            appendOutput(&quot;Leaving mine...&quot;);
            gameState = &quot;idle&quot;; // Return to the idle state
            coordinates[2] = 0
            break;
        default:
            appendOutput(&quot;Please specify Dirt or Cobblestone, or type &#39;exit&#39; to leave.&quot;);
    };
};

const startAttack = () =&gt; {
    currentMonster = monsters[Math.floor(Math.random() * monsters.length)];
    gameState = &quot;attack&quot;; // Transition to the explore state
    appendOutput(`You are now attacking the ${monster}. What do you do?`);
    appendOutput(&quot;You can attack, dodge, or flee.&quot;);
    appendOutput(`It has ${monster_health} HP.`);
};

const handleAttack = (command) =&gt; {
    const move = Math.floor(Math.random() * 3) + 1;
    switch (command.toLowerCase()) {
        case &quot;attack&quot;:
            switch (move){
                case 1:
                    appendOutput(`You attack, but the ${monster} dodges`);
                    appendOutput(&#39;and attacks first!&#39;);
                    player_health -= monster_attack_damage;
                    appendOutput(`You now have ${player_health} HP.`);
                    break;
                case 2:
                    appendOutput(`You attack the ${monster}, and your aim is true!`);
                    monster_health -= player_attack_damage;
                    appendOutput(`The ${monster} now has ${monster_health} HP.`);
                    break;
                case 3:
                    appendOutput(`You attack, but the ${monster} dodges!`);
                    break;
                default:
                    appendOutput(&quot;Something went wrong&quot;)
                };

    case &quot;dodge&quot;:
        switch (move){
            case 1:
                appendOutput(`You try dodging the ${monster}&#39;s attack,`);
                appendOutput(&#39;but it catches you anyway!&#39;);
                player_health -= monster_attack_damage;
                appendOutput(`You now have ${player_health} HP.`);
                break;
            case 2:
                appendOutput(`You dodge the ${monster}&#39;s attack!`);
                break;
            case 3:
                appendOutput(`You dodge the ${monster}&#39;s attack!`);
                break;
            default:
                appendOutput(&quot;Something went wrong&quot;)
            };
    case &quot;flee&quot;:  
        appendOutput(`You run away from the ${monster},`);
        gamestate=&quot;idle&quot;
        break;
    default:
        if (monster_health &lt;= 0) {
            console.clear();
            appendOutput(`You have defeated the ${monster}!`);
            appendOutput(&#39;You have earned 5 XP.&#39;);
            experience += 5;
            gamestate=&quot;idle&quot;
        };
        if (player_health &lt;= 0) {
            slain_by_monster = true;
            gameOver();
        };
    };
};

function gameOver() {
    appendOutput(&#39;Game over.&#39;)
    if (slain_by_monster) {
        appendOutput(`player_01 was slain by a ${monster}.`);
    };
    if (void_fall) {
        appendOutput(&#39;player_01 fell in the Void&#39;);
    };
    // Helper function to simulate sleep
    while (new Date().getTime() &lt; new Date().getTime() + 15000);
    location.reload();
};

function drop(array, stringToRemove) {
    const index = array.indexOf(stringToRemove);
    if (index !== -1) {
        array.splice(index, 1); // Remove the first occurrence of the string
    }
    return array;
    }

const startSmelt = () =&gt; {
    if (!inventory.includes(&#39;Planks&#39;) &amp;&amp; !inventory.includes(&#39;Coal&#39;)) {
        appendOutput(&#39;You need Planks or Coal.&#39;);
        return;
    };
    gameState = &quot;smelt&quot;; // Transition to the explore state
    appendOutput(`Would you like to smelt Iron Ore or Gold Ore? (or exit)`);
};

const handleSmelt = (command) =&gt; {
    switch (command.toLowerCase()) {
        case &quot;gold&quot;:
        case &quot;gold ore&quot;:
            inventory  = drop(inventory, &#39;Gold Ore&#39;);
            if (inventory.includes(&#39;Planks&#39;)) {
                inventory  = drop(inventory, &#39;Planks&#39;);
            } else if (inventory.includes(&#39;Coal&#39;)) {
                inventory  = drop(inventory, &#39;Coal&#39;);
            } else {
                appendOutput(&#39;You cannot smelt that.&#39;);
                return;
            }
            inventory.push(&#39;Gold Ingot&#39;);
            appendOutput(&#39;You smelted Gold!&#39;);
            break;
        case &quot;iron&quot;:
        case &quot;iron ore&quot;:
            inventory  = drop(inventory, &#39;Iron Ore&#39;);
            if (inventory.includes(&#39;Planks&#39;)) {
                inventory  = drop(inventory, &#39;Planks&#39;);
            } else if (inventory.includes(&#39;Coal&#39;)) {
                inventory  = drop(inventory, &#39;Coal&#39;);
            } else {
                appendOutput(&#39;You cannot smelt that.&#39;);
                return;
            }
            inventory.push(&#39;Iron Ingot&#39;);
            appendOutput(&#39;You smelted Iron!&#39;);
            break;
        case &quot;exit&quot;:
            gameState = &quot;idle&quot;
            appendOutput(&quot;You exited smelting&quot;)
            break;
        defualt:
            appendOutput(&quot;Something went wrong&quot;)
            gameState = &quot;idle&quot;
        };
    };

const startCraft  = () =&gt; {
    appendOutput(&quot;Would you like to craft a(n) wooden/cobblestone/iron/gold pickaxe/sword? (or exit)&quot;)
    gameState = &quot;craft&quot;
}

function craft(recipe) {
    if (!recipe.every(item =&gt; inventory.includes(item))) {
        appendOutput(&quot;You need materials.&quot;)
        return;
    } else {
        for (let item of recipe) {
            inventory = drop(inventory, item)
        }
    }
}


const handleCraft = (command) =&gt; {
    item = toTitleCase(command)
    if (item === &quot;Exit&quot;) {
        appendOutput(&quot;You left the crafting.&quot;)
        gameState = &quot;idle&quot;
        return;
    } else if (!Object.keys(items).includes(item)) {
        appendOutput(&quot;That&#39;s not an item&quot;)
        return;
    } else {
        recipe = items[item][&quot;recipe&quot;]
        craft(recipe)
        inventory.push(item)
        appendOutput(`You crafted ${item}`)
        return;
    }
}

const handleCommand = (command) =&gt; {
    appendOutput(`&#92;n&#92;n&#92;nCoordinates: ${coordinates}`)
    appendOutput(`HP: ${player_health}`)
    switch (gameState) {
        case &quot;explore&quot;:
            handleExplore(command); // Handle commands specific to the explore state
            return;
        case &quot;mine&quot;:
            handleMine(command);
            return;
        case &quot;attack&quot;:
            handleAttack(command);
            return;
        case &quot;smelt&quot;:
            handleSmelt(command);
            return;
        case &quot;craft&quot;:
            handleCraft(command);
            return;
        case &quot;equip&quot;:
            handleEquip(command)
            return;
        default:
            break;
            // appendOutput(&quot;Would you like to explore, mine, or attack?&quot;);
    }

    switch (command.toLowerCase()) {
        case &quot;explore&quot;:
            startExplore();
            break;
        case &quot;mine&quot;:
            startMine();
            break;
        case &quot;attack&quot;:
            startAttack();
            break;
        case &quot;inventory&quot;:
            appendOutput(inventory.toString());
            break;
        case &quot;smelt&quot;:
            startSmelt();
            break;
        case &quot;craft&quot;:
            startCraft();
            break;
        case &quot;equip&quot;:
            startEquip();
            break;
        case &quot;help&quot;:
            appendOutput(&quot;Commands: explore, mine, attack, smelt, inventory, craft, equip, &amp; help.&quot;);
            break;
        default:
            appendOutput(&quot;I don&#39;t understand that command.&quot;);
    }
};

input.addEventListener(&quot;keydown&quot;, (event) =&gt; {
    if (event.key === &quot;Enter&quot;) {
        const command = input.value.trim();
        if (command) {
            appendOutput(`&gt; ${command}`);
            handleCommand(command);
            input.value = &quot;&quot;; // Clear the input field
        }
    }
});
     &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</content>
  </entry>
  <entry>
    <title>applied differential equations review</title>
    <link href="https://ischmidls.github.io/blog/diffeqreview/" />
    <updated>2024-09-30T00:00:00Z</updated>
    <id>https://ischmidls.github.io/blog/diffeqreview/</id>
    <content type="html">&lt;script type=&quot;text/x-mathjax-config&quot;&gt; MathJax.Hub.Config({
    jax: [&quot;input/TeX&quot;, &quot;output/HTML-CSS&quot;],
    extensions: [&quot;tex2jax.js&quot;],
    &quot;HTML-CSS&quot;: { preferredFont: &quot;TeX&quot;, availableFonts: [&quot;STIX&quot;,&quot;TeX&quot;] },
    tex2jax: { inlineMath: [ [&quot;$&quot;, &quot;$&quot;], [&quot;&#92;&#92;(&quot;,&quot;&#92;&#92;)&quot;] ], displayMath: [ [&quot;$$&quot;,&quot;$$&quot;], [&quot;&#92;&#92;[&quot;, &quot;&#92;&#92;]&quot;] ], processEscapes: true, ignoreClass: &quot;tex2jax_ignore|dno&quot; },
    TeX: { noUndefined: { attributes: { mathcolor: &quot;red&quot;, mathbackground: &quot;#FFEEEE&quot;, mathsize: &quot;90%&quot; } } },
    messageStyle: &quot;none&quot;
  });
  &lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js&quot;&gt;&lt;/script&gt;
&lt;p&gt;Welcome to my review for the class that I always forget the most about while I am tutoring.&lt;/p&gt;
&lt;h3 id=&quot;linear-first-order-equations&quot;&gt;2.1: Linear First Order Equations&lt;/h3&gt;
&lt;p&gt;Solve &lt;span class=&quot;math inline&quot;&gt;&#92;(y&amp;#39; + 2y = e^{-x}&#92;)&lt;/span&gt;. The integrating factor &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;mu(x) = e^{2x}&#92;)&lt;/span&gt; yields the solution &lt;span class=&quot;math inline&quot;&gt;&#92;(y(x) = &#92;frac{1}{3}e^{-x} + Ce^{-2x}&#92;)&lt;/span&gt;. &lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;separable-equations&quot;&gt;2.2: Separable Equations&lt;/h3&gt;
&lt;p&gt;Solve &lt;span class=&quot;math inline&quot;&gt;&#92;(y&amp;#39; = xy^2&#92;)&lt;/span&gt;. Separating variables and integrating gives &lt;span class=&quot;math inline&quot;&gt;&#92;(y(x) = -&#92;frac{2}{x^2 + C}&#92;)&lt;/span&gt;. &lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;existence-and-uniqueness-of-nonlinear-equations&quot;&gt;2.3: Existence and Uniqueness of Nonlinear Equations&lt;/h3&gt;
&lt;p&gt;If a function &lt;span class=&quot;math inline&quot;&gt;&#92;(f(x, y)&#92;)&lt;/span&gt; is continuous within an open rectangle in the &lt;span class=&quot;math inline&quot;&gt;&#92;(xy&#92;)&lt;/span&gt;-plane containing a point &lt;span class=&quot;math inline&quot;&gt;&#92;((x_0, y_0)&#92;)&lt;/span&gt;, then the initial value problem &lt;span class=&quot;math inline&quot;&gt;&#92;(y&amp;#39; = f(x, y)&#92;)&lt;/span&gt;, &lt;span class=&quot;math inline&quot;&gt;&#92;(y(x_0) = y_0&#92;)&lt;/span&gt; has at least one solution (existence). If the partial derivative &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;frac{&#92;partial f}{&#92;partial y}&#92;)&lt;/span&gt; is also continuous within that rectangle, then the solution is unique. &lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;transformation-into-separable-equations&quot;&gt;2.4: Transformation into Separable Equations&lt;/h3&gt;
&lt;p&gt;To solve the differential equation &lt;span class=&quot;math inline&quot;&gt;&#92;(y&amp;#39; = &#92;frac{x + y}{x - y}&#92;)&lt;/span&gt;, we use the substitution &lt;span class=&quot;math inline&quot;&gt;&#92;(v = &#92;frac{y}{x}&#92;)&lt;/span&gt;, which implies &lt;span class=&quot;math inline&quot;&gt;&#92;(y = vx&#92;)&lt;/span&gt; and &lt;span class=&quot;math inline&quot;&gt;&#92;(y&amp;#39; = v + xv&amp;#39;&#92;)&lt;/span&gt;. Substituting into the equation gives &lt;span class=&quot;math inline&quot;&gt;&#92;(v + xv&amp;#39; = &#92;frac{x + vx}{x - vx} = &#92;frac{1 + v}{1 - v}.&#92;)&lt;/span&gt; Rearranging, we get &lt;span class=&quot;math inline&quot;&gt;&#92;(xv&amp;#39; = &#92;frac{1 + v}{1 - v} - v = &#92;frac{1 + v^2}{1 - v}.&#92;)&lt;/span&gt; This is now a separable equation in &lt;span class=&quot;math inline&quot;&gt;&#92;(v&#92;)&lt;/span&gt; and &lt;span class=&quot;math inline&quot;&gt;&#92;(x&#92;)&lt;/span&gt;. Separating variables and integrating yields &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;int &#92;frac{1 - v}{1 + v^2} &#92;, dv = &#92;int &#92;frac{1}{x} &#92;, dx.&#92;)&lt;/span&gt; Solving these integrals and substituting back &lt;span class=&quot;math inline&quot;&gt;&#92;(v = &#92;frac{y}{x}&#92;)&lt;/span&gt; gives the solution to the original equation. &lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;exact-equations&quot;&gt;2.5: Exact Equations&lt;/h3&gt;
&lt;p&gt;Solve &lt;span class=&quot;math inline&quot;&gt;&#92;((2xy + y^2)dx + (x^2 + 2xy)dy = 0&#92;)&lt;/span&gt;. The potential function &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;Psi(x, y) = x^2y + xy^2&#92;)&lt;/span&gt; yields the solution &lt;span class=&quot;math inline&quot;&gt;&#92;(x^2y + xy^2 = C&#92;)&lt;/span&gt;. &lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;integrating-factors&quot;&gt;2.6: Integrating Factors&lt;/h3&gt;
&lt;p&gt;Solve &lt;span class=&quot;math inline&quot;&gt;&#92;(y dx - x dy = 0&#92;)&lt;/span&gt;. The integrating factor &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;mu(x, y) = &#92;frac{1}{x^2}&#92;)&lt;/span&gt; makes it exact, yielding &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;frac{y}{x} = C&#92;)&lt;/span&gt;. &lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;growth-and-decay&quot;&gt;4.1: Growth and Decay&lt;/h3&gt;
&lt;p&gt;A population grows exponentially: &lt;span class=&quot;math inline&quot;&gt;&#92;(P(t) = P_0 e^{kt}&#92;)&lt;/span&gt;, where &lt;span class=&quot;math inline&quot;&gt;&#92;(P_0&#92;)&lt;/span&gt; is the initial population and &lt;span class=&quot;math inline&quot;&gt;&#92;(k&#92;)&lt;/span&gt; is the growth rate. &lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;cooling-and-mixing&quot;&gt;4.2: Cooling and Mixing&lt;/h3&gt;
&lt;p&gt;Newton’s Law of Cooling: &lt;span class=&quot;math inline&quot;&gt;&#92;(T(t) = T_a + (T_0 - T_a)e^{-kt}&#92;)&lt;/span&gt;, where &lt;span class=&quot;math inline&quot;&gt;&#92;(T_a&#92;)&lt;/span&gt; is ambient temperature and &lt;span class=&quot;math inline&quot;&gt;&#92;(T_0&#92;)&lt;/span&gt; is initial temperature. &lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;elementary-mechanics&quot;&gt;4.3: Elementary Mechanics&lt;/h3&gt;
&lt;p&gt;A falling object with air resistance: &lt;span class=&quot;math inline&quot;&gt;&#92;(m&#92;frac{dv}{dt} = mg - kv&#92;)&lt;/span&gt;. The solution is &lt;span class=&quot;math inline&quot;&gt;&#92;(v(t) = &#92;frac{mg}{k}(1 - e^{-kt/m})&#92;)&lt;/span&gt;. &lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;autonomous-second-order-equations&quot;&gt;4.4: Autonomous Second Order Equations&lt;/h3&gt;
&lt;p&gt;Solve &lt;span class=&quot;math inline&quot;&gt;&#92;(y&amp;#39;&amp;#39; + y = 0&#92;)&lt;/span&gt;. The general solution is &lt;span class=&quot;math inline&quot;&gt;&#92;(y(x) = C_1 &#92;cos x + C_2 &#92;sin x&#92;)&lt;/span&gt;. &lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;constant-coefficient-homogeneous-equations&quot;&gt;5.2: Constant Coefficient Homogeneous Equations&lt;/h3&gt;
&lt;p&gt;A constant coefficient homogeneous equation has the form &lt;span class=&quot;math inline&quot;&gt;&#92;(y&amp;#39;&amp;#39; + ay&amp;#39; + by = 0&#92;)&lt;/span&gt;, where &lt;span class=&quot;math inline&quot;&gt;&#92;(a&#92;)&lt;/span&gt; and &lt;span class=&quot;math inline&quot;&gt;&#92;(b&#92;)&lt;/span&gt; are constants. The solution is found by solving the characteristic equation &lt;span class=&quot;math inline&quot;&gt;&#92;(r^2 + ar + b = 0&#92;)&lt;/span&gt;. For &lt;span class=&quot;math inline&quot;&gt;&#92;(y&amp;#39;&amp;#39; + 4y&amp;#39; + 4y = 0&#92;)&lt;/span&gt;, the characteristic equation &lt;span class=&quot;math inline&quot;&gt;&#92;(r^2 + 4r + 4 = 0&#92;)&lt;/span&gt; yields a repeated root &lt;span class=&quot;math inline&quot;&gt;&#92;(r = -2&#92;)&lt;/span&gt;. This results in the general solution &lt;span class=&quot;math inline&quot;&gt;&#92;(y(x) = (C_1 + C_2 x)e^{-2x}&#92;)&lt;/span&gt;, where &lt;span class=&quot;math inline&quot;&gt;&#92;(C_1&#92;)&lt;/span&gt; and &lt;span class=&quot;math inline&quot;&gt;&#92;(C_2&#92;)&lt;/span&gt; are constants determined by initial conditions. &lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;nonhomogeneous-linear-equations&quot;&gt;5.3: Nonhomogeneous Linear Equations&lt;/h3&gt;
&lt;p&gt;A nonhomogeneous linear equation has the form &lt;span class=&quot;math inline&quot;&gt;&#92;(y&amp;#39;&amp;#39; + ay&amp;#39; + by = g(x)&#92;)&lt;/span&gt;, where &lt;span class=&quot;math inline&quot;&gt;&#92;(g(x)&#92;)&lt;/span&gt; is a nonzero function. The general solution is the sum of the complementary solution (solution to the homogeneous equation) and a particular solution to the nonhomogeneous equation. For &lt;span class=&quot;math inline&quot;&gt;&#92;(y&amp;#39;&amp;#39; + y = &#92;sin x&#92;)&lt;/span&gt;, the complementary solution is &lt;span class=&quot;math inline&quot;&gt;&#92;(y_c(x) = C_1 &#92;cos x + C_2 &#92;sin x&#92;)&lt;/span&gt;, and a particular solution is &lt;span class=&quot;math inline&quot;&gt;&#92;(y_p(x) = -&#92;frac{1}{2}x &#92;cos x&#92;)&lt;/span&gt;. Thus, the general solution is &lt;span class=&quot;math inline&quot;&gt;&#92;(y(x) = C_1 &#92;cos x + C_2 &#92;sin x - &#92;frac{1}{2}x &#92;cos x&#92;)&lt;/span&gt;. &lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;method-of-undetermined-coefficients&quot;&gt;5.4: Method of Undetermined Coefficients&lt;/h3&gt;
&lt;p&gt;The method of undetermined coefficients is a technique for finding a particular solution &lt;span class=&quot;math inline&quot;&gt;&#92;(y_p(x)&#92;)&lt;/span&gt; to nonhomogeneous linear differential equations of the form &lt;span class=&quot;math inline&quot;&gt;&#92;(y&amp;#39;&amp;#39; + ay&amp;#39; + by = g(x)&#92;)&lt;/span&gt;, where &lt;span class=&quot;math inline&quot;&gt;&#92;(g(x)&#92;)&lt;/span&gt; is a polynomial, exponential, sine, cosine, or a combination of these. The idea is to guess a form for &lt;span class=&quot;math inline&quot;&gt;&#92;(y_p(x)&#92;)&lt;/span&gt; based on &lt;span class=&quot;math inline&quot;&gt;&#92;(g(x)&#92;)&lt;/span&gt;, with undetermined coefficients, and then substitute it into the equation to solve for those coefficients. For &lt;span class=&quot;math inline&quot;&gt;&#92;(y&amp;#39;&amp;#39; + y = x^2&#92;)&lt;/span&gt;, since &lt;span class=&quot;math inline&quot;&gt;&#92;(g(x) = x^2&#92;)&lt;/span&gt; is a polynomial, we guess &lt;span class=&quot;math inline&quot;&gt;&#92;(y_p(x) = Ax^2 + Bx + C&#92;)&lt;/span&gt;. Substituting &lt;span class=&quot;math inline&quot;&gt;&#92;(y_p&#92;)&lt;/span&gt;, &lt;span class=&quot;math inline&quot;&gt;&#92;(y_p&amp;#39;&#92;)&lt;/span&gt;, and &lt;span class=&quot;math inline&quot;&gt;&#92;(y_p&amp;#39;&amp;#39;&#92;)&lt;/span&gt; into the equation and equating coefficients, we find &lt;span class=&quot;math inline&quot;&gt;&#92;(A = 1&#92;)&lt;/span&gt;, &lt;span class=&quot;math inline&quot;&gt;&#92;(B = 0&#92;)&lt;/span&gt;, and &lt;span class=&quot;math inline&quot;&gt;&#92;(C = -2&#92;)&lt;/span&gt;, giving &lt;span class=&quot;math inline&quot;&gt;&#92;(y_p(x) = x^2 - 2&#92;)&lt;/span&gt;. The general solution combines this particular solution with the complementary solution &lt;span class=&quot;math inline&quot;&gt;&#92;(y_c(x) = C_1 &#92;cos x + C_2 &#92;sin x&#92;)&lt;/span&gt;, resulting in &lt;span class=&quot;math inline&quot;&gt;&#92;(y(x) = C_1 &#92;cos x + C_2 &#92;sin x + x^2 - 2&#92;)&lt;/span&gt;. This method works efficiently for specific types of &lt;span class=&quot;math inline&quot;&gt;&#92;(g(x)&#92;)&lt;/span&gt;. &lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;method-of-undetermined-coefficients-ii&quot;&gt;5.5: Method of Undetermined Coefficients II&lt;/h3&gt;
&lt;p&gt;The method of undetermined coefficients extends to cases where &lt;span class=&quot;math inline&quot;&gt;&#92;(g(x)&#92;)&lt;/span&gt; involves products of exponentials, sines, and cosines. For &lt;span class=&quot;math inline&quot;&gt;&#92;(y&amp;#39;&amp;#39; + y = e^x &#92;cos x&#92;)&lt;/span&gt;, we guess a particular solution of the form &lt;span class=&quot;math inline&quot;&gt;&#92;(y_p(x) = e^x (A &#92;cos x + B &#92;sin x)&#92;)&lt;/span&gt;, where &lt;span class=&quot;math inline&quot;&gt;&#92;(A&#92;)&lt;/span&gt; and &lt;span class=&quot;math inline&quot;&gt;&#92;(B&#92;)&lt;/span&gt; are undetermined coefficients. Substituting &lt;span class=&quot;math inline&quot;&gt;&#92;(y_p&#92;)&lt;/span&gt;, &lt;span class=&quot;math inline&quot;&gt;&#92;(y_p&amp;#39;&#92;)&lt;/span&gt;, and &lt;span class=&quot;math inline&quot;&gt;&#92;(y_p&amp;#39;&amp;#39;&#92;)&lt;/span&gt; into the equation and equating coefficients of &lt;span class=&quot;math inline&quot;&gt;&#92;(e^x &#92;cos x&#92;)&lt;/span&gt; and &lt;span class=&quot;math inline&quot;&gt;&#92;(e^x &#92;sin x&#92;)&lt;/span&gt;, we solve for &lt;span class=&quot;math inline&quot;&gt;&#92;(A&#92;)&lt;/span&gt; and &lt;span class=&quot;math inline&quot;&gt;&#92;(B&#92;)&lt;/span&gt;. This yields &lt;span class=&quot;math inline&quot;&gt;&#92;(A = &#92;frac{1}{5}&#92;)&lt;/span&gt; and &lt;span class=&quot;math inline&quot;&gt;&#92;(B = &#92;frac{2}{5}&#92;)&lt;/span&gt;, giving the particular solution &lt;span class=&quot;math inline&quot;&gt;&#92;(y_p(x) = &#92;frac{1}{5}e^x (&#92;cos x + 2 &#92;sin x)&#92;)&lt;/span&gt;. The general solution combines this with the complementary solution &lt;span class=&quot;math inline&quot;&gt;&#92;(y_c(x) = C_1 &#92;cos x + C_2 &#92;sin x&#92;)&lt;/span&gt;, resulting in &lt;span class=&quot;math inline&quot;&gt;&#92;(y(x) = C_1 &#92;cos x + C_2 &#92;sin x + &#92;frac{1}{5}e^x (&#92;cos x + 2 &#92;sin x)&#92;)&lt;/span&gt;. This method is effective for handling more complex forms of &lt;span class=&quot;math inline&quot;&gt;&#92;(g(x)&#92;)&lt;/span&gt;. &lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;reduction-of-order&quot;&gt;5.6: Reduction of Order&lt;/h3&gt;
&lt;p&gt;Reduction of order is a method used to find a second linearly independent solution &lt;span class=&quot;math inline&quot;&gt;&#92;(y_2(x)&#92;)&lt;/span&gt; to a second-order linear homogeneous differential equation when one solution &lt;span class=&quot;math inline&quot;&gt;&#92;(y_1(x)&#92;)&lt;/span&gt; is already known. For &lt;span class=&quot;math inline&quot;&gt;&#92;(y&amp;#39;&amp;#39; - 2y&amp;#39; + y = 0&#92;)&lt;/span&gt;, given &lt;span class=&quot;math inline&quot;&gt;&#92;(y_1 = e^x&#92;)&lt;/span&gt;, we assume &lt;span class=&quot;math inline&quot;&gt;&#92;(y_2 = v(x)e^x&#92;)&lt;/span&gt;, where &lt;span class=&quot;math inline&quot;&gt;&#92;(v(x)&#92;)&lt;/span&gt; is an unknown function. Substituting &lt;span class=&quot;math inline&quot;&gt;&#92;(y_2&#92;)&lt;/span&gt;, &lt;span class=&quot;math inline&quot;&gt;&#92;(y_2&amp;#39;&#92;)&lt;/span&gt;, and &lt;span class=&quot;math inline&quot;&gt;&#92;(y_2&amp;#39;&amp;#39;&#92;)&lt;/span&gt; into the equation and simplifying, we find &lt;span class=&quot;math inline&quot;&gt;&#92;(v&amp;#39;&amp;#39;(x) = 0&#92;)&lt;/span&gt;, which implies &lt;span class=&quot;math inline&quot;&gt;&#92;(v(x) = C_1 + C_2 x&#92;)&lt;/span&gt;. Choosing &lt;span class=&quot;math inline&quot;&gt;&#92;(C_1 = 0&#92;)&lt;/span&gt; and &lt;span class=&quot;math inline&quot;&gt;&#92;(C_2 = 1&#92;)&lt;/span&gt; gives the second solution &lt;span class=&quot;math inline&quot;&gt;&#92;(y_2(x) = xe^x&#92;)&lt;/span&gt;. We choose &lt;span class=&quot;math inline&quot;&gt;&#92;(C_1 = 0&#92;)&lt;/span&gt; and &lt;span class=&quot;math inline&quot;&gt;&#92;(C_2 = 1&#92;)&lt;/span&gt; to ensure &lt;span class=&quot;math inline&quot;&gt;&#92;(y_2(x) = v(x)e^x&#92;)&lt;/span&gt; is linearly independent from the known solution &lt;span class=&quot;math inline&quot;&gt;&#92;(y_1(x) = e^x&#92;)&lt;/span&gt;. Setting &lt;span class=&quot;math inline&quot;&gt;&#92;(C_1 = 0&#92;)&lt;/span&gt; avoids redundancy, as including it would introduce a term proportional to &lt;span class=&quot;math inline&quot;&gt;&#92;(y_1(x)&#92;)&lt;/span&gt;. Choosing &lt;span class=&quot;math inline&quot;&gt;&#92;(C_2 = 1&#92;)&lt;/span&gt; simplifies the solution, making &lt;span class=&quot;math inline&quot;&gt;&#92;(y_2(x) = xe^x&#92;)&lt;/span&gt; the simplest linearly independent solution. Together, &lt;span class=&quot;math inline&quot;&gt;&#92;(y_1(x) = e^x&#92;)&lt;/span&gt; and &lt;span class=&quot;math inline&quot;&gt;&#92;(y_2(x) = xe^x&#92;)&lt;/span&gt; form a basis for the general solution &lt;span class=&quot;math inline&quot;&gt;&#92;(y(x) = C_1 e^x + C_2 xe^x&#92;)&lt;/span&gt;. This method reduces the problem to solving a first-order equation for &lt;span class=&quot;math inline&quot;&gt;&#92;(v&amp;#39;(x)&#92;)&lt;/span&gt;. &lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;variation-of-parameters&quot;&gt;5.7: Variation of Parameters&lt;/h3&gt;
&lt;p&gt;Variation of parameters is a method for finding a particular solution to a nonhomogeneous linear differential equation &lt;span class=&quot;math inline&quot;&gt;&#92;(y&amp;#39;&amp;#39; + p(x)y&amp;#39; + q(x)y = g(x)&#92;)&lt;/span&gt;. For &lt;span class=&quot;math inline&quot;&gt;&#92;(y&amp;#39;&amp;#39; + y = &#92;tan x&#92;)&lt;/span&gt;, the complementary solution is &lt;span class=&quot;math inline&quot;&gt;&#92;(y_c(x) = C_1 &#92;cos x + C_2 &#92;sin x&#92;)&lt;/span&gt;. We seek a particular solution of the form &lt;span class=&quot;math inline&quot;&gt;&#92;(y_p(x) = u_1(x) &#92;cos x + u_2(x) &#92;sin x&#92;)&lt;/span&gt;, where &lt;span class=&quot;math inline&quot;&gt;&#92;(u_1(x)&#92;)&lt;/span&gt; and &lt;span class=&quot;math inline&quot;&gt;&#92;(u_2(x)&#92;)&lt;/span&gt; are functions to be determined. For the equation &lt;span class=&quot;math inline&quot;&gt;&#92;(y&amp;#39;&amp;#39; + y = &#92;tan x&#92;)&lt;/span&gt;, the complementary solution is &lt;span class=&quot;math inline&quot;&gt;&#92;(y_c(x) = C_1 &#92;cos x + C_2 &#92;sin x&#92;)&lt;/span&gt;. For first constraint, to simplify the problem, we impose the condition:$ u_1’(x) x + u_2’(x) x = 0.$ This ensures that the derivative of &lt;span class=&quot;math inline&quot;&gt;&#92;(y_p(x)&#92;)&lt;/span&gt; does not include terms involving &lt;span class=&quot;math inline&quot;&gt;&#92;(u_1&amp;#39;(x)&#92;)&lt;/span&gt; and &lt;span class=&quot;math inline&quot;&gt;&#92;(u_2&amp;#39;(x)&#92;)&lt;/span&gt; beyond what is necessary. For second constraint, substitute &lt;span class=&quot;math inline&quot;&gt;&#92;(y_p(x)&#92;)&lt;/span&gt;, &lt;span class=&quot;math inline&quot;&gt;&#92;(y_p&amp;#39;(x)&#92;)&lt;/span&gt;, and &lt;span class=&quot;math inline&quot;&gt;&#92;(y_p&amp;#39;&amp;#39;(x)&#92;)&lt;/span&gt; into the original equation &lt;span class=&quot;math inline&quot;&gt;&#92;(y&amp;#39;&amp;#39; + y = &#92;tan x&#92;)&lt;/span&gt;. After simplification, this yields:$ -u_1’(x) x + u_2’(x) x = x.$ Solving the system &lt;span class=&quot;math inline&quot;&gt;&#92;(u_1&amp;#39;(x) &#92;cos x + u_2&amp;#39;(x) &#92;sin x = 0&#92;)&lt;/span&gt; and &lt;span class=&quot;math inline&quot;&gt;&#92;(-u_1&amp;#39;(x) &#92;sin x + u_2&amp;#39;(x) &#92;cos x = &#92;tan x&#92;)&lt;/span&gt;, we find &lt;span class=&quot;math inline&quot;&gt;&#92;(u_1&amp;#39;(x) = -&#92;sin x &#92;tan x&#92;)&lt;/span&gt; and &lt;span class=&quot;math inline&quot;&gt;&#92;(u_2&amp;#39;(x) = &#92;sin x&#92;)&lt;/span&gt;. Integrating these gives &lt;span class=&quot;math inline&quot;&gt;&#92;(u_1(x) = &#92;ln|&#92;sec x + &#92;tan x| - &#92;sin x&#92;)&lt;/span&gt; and &lt;span class=&quot;math inline&quot;&gt;&#92;(u_2(x) = -&#92;cos x&#92;)&lt;/span&gt;. Thus, the particular solution is &lt;span class=&quot;math inline&quot;&gt;&#92;(y_p(x) = -&#92;cos x &#92;ln|&#92;sec x + &#92;tan x|&#92;)&lt;/span&gt;, and the general solution is &lt;span class=&quot;math inline&quot;&gt;&#92;(y(x) = C_1 &#92;cos x + C_2 &#92;sin x - &#92;cos x &#92;ln|&#92;sec x + &#92;tan x|&#92;)&lt;/span&gt;. This method is more general than undetermined coefficients and works for any continuous &lt;span class=&quot;math inline&quot;&gt;&#92;(g(x)&#92;)&lt;/span&gt;. &lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;series-solutions-near-an-ordinary-point-ii&quot;&gt;7.4: Series Solutions Near an Ordinary Point II&lt;/h3&gt;
&lt;p&gt;Consider this example from William Trench “Elementary Differential Equations &amp;amp; Boundary Value Problems” section &lt;span class=&quot;math inline&quot;&gt;&#92;(7.4&#92;)&lt;/span&gt;. Find the coefficients &lt;span class=&quot;math inline&quot;&gt;&#92;(a_0, &#92;dots, a_7&#92;)&lt;/span&gt; in the series solution &lt;span class=&quot;math inline&quot;&gt;&#92;(y = &#92;sum_{n=0}^&#92;infty a_n x^n&#92;)&lt;/span&gt; of the initial value problem &lt;span class=&quot;math inline&quot;&gt;&#92;((1 + x + 2x^2)y&amp;#39;&amp;#39; + (1 + 7x)y&amp;#39; + 2y = 0, &#92;quad y(0) = -1, &#92;quad y&amp;#39;(0) = -2. &#92;quad (*)&#92;)&lt;/span&gt; Here, the differential operator is &lt;span class=&quot;math inline&quot;&gt;&#92;(Ly = (1 + x + 2x^2)y&amp;#39;&amp;#39; + (1 + 7x)y&amp;#39; + 2y&#92;)&lt;/span&gt;. The zeros of &lt;span class=&quot;math inline&quot;&gt;&#92;(P_0(x) = 1 + x + 2x^2&#92;)&lt;/span&gt;, given by &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;frac{-1 &#92;pm i&#92;sqrt{7}}{4}&#92;)&lt;/span&gt;, have absolute value &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;frac{1}{&#92;sqrt{2}}&#92;)&lt;/span&gt;. Now if &lt;span class=&quot;math inline&quot;&gt;&#92;(P_0(x)&#92;)&lt;/span&gt; has no zeros in the interval &lt;span class=&quot;math inline&quot;&gt;&#92;(|x| &amp;lt; R&#92;)&lt;/span&gt;, then the series solution converges on &lt;span class=&quot;math inline&quot;&gt;&#92;(|x| &amp;lt; R&#92;)&lt;/span&gt;. So the series solution converges on &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;left(-&#92;frac{1}{&#92;sqrt{2}}, &#92;frac{1}{&#92;sqrt{2}}&#92;right)&#92;)&lt;/span&gt;. Substituting &lt;span class=&quot;math inline&quot;&gt;&#92;(y = &#92;sum_{n=0}^&#92;infty a_n x^n&#92;)&lt;/span&gt;, &lt;span class=&quot;math inline&quot;&gt;&#92;(y&amp;#39; = &#92;sum_{n=1}^&#92;infty n a_n x^{n-1}&#92;)&lt;/span&gt;, and &lt;span class=&quot;math inline&quot;&gt;&#92;(y&amp;#39;&amp;#39; = &#92;sum_{n=2}^&#92;infty n(n-1) a_n x^{n-2}&#92;)&lt;/span&gt; into &lt;span class=&quot;math inline&quot;&gt;&#92;(Ly&#92;)&lt;/span&gt;, we obtain &lt;span class=&quot;math inline&quot;&gt;&#92;(Ly = &#92;sum_{n=2}^&#92;infty n(n-1) a_n x^{n-2} + &#92;sum_{n=2}^&#92;infty n(n-1) a_n x^{n-1} + 2&#92;sum_{n=2}^&#92;infty n(n-1) a_n x^n + &#92;sum_{n=1}^&#92;infty n a_n x^{n-1} + 7&#92;sum_{n=1}^&#92;infty n a_n x^n + 2&#92;sum_{n=0}^&#92;infty a_n x^n.&#92;)&lt;/span&gt; 
    Shifting indices so the general term in each series is a constant multiple of 
    &lt;span class=&quot;math inline&quot;&gt;&#92;(x^n&#92;)&lt;/span&gt; yields 
    &lt;span class=&quot;math inline&quot;&gt;&#92;(Ly = &#92;sum_{n=0}^&#92;infty (n+2)(n+1) a_{n+2} x^n + &#92;sum_{n=0}^&#92;infty (n+1)n a_{n+1} x^n + 2&#92;sum_{n=0}^&#92;infty n(n-1) a_n x^n + &#92;)&lt;/span&gt;
    &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;sum_{n=0}^&#92;infty (n+1) a_{n+1} x^n + 7&#92;sum_{n=0}^&#92;infty n a_n x^n + 2&#92;sum_{n=0}^&#92;infty a_n x^n = &#92;sum_{n=0}^&#92;infty b_n x^n,&#92;)&lt;/span&gt; where &lt;span class=&quot;math inline&quot;&gt;&#92;(b_n = (n+2)(n+1) a_{n+2} + (n+1)^2 a_{n+1} + (n+2)(2n+1) a_n.&#92;)&lt;/span&gt; Thus, &lt;span class=&quot;math inline&quot;&gt;&#92;(y = &#92;sum_{n=0}^&#92;infty a_n x^n&#92;)&lt;/span&gt; is a solution of &lt;span class=&quot;math inline&quot;&gt;&#92;(Ly = 0&#92;)&lt;/span&gt; if and only if &lt;span class=&quot;math inline&quot;&gt;&#92;(a_{n+2} = -&#92;frac{n+1}{n+2} a_{n+1} - &#92;frac{2n+1}{n+1} a_n, &#92;quad n &#92;geq 0. &#92;quad (**)&#92;)&lt;/span&gt; From the initial conditions, &lt;span class=&quot;math inline&quot;&gt;&#92;(a_0 = y(0) = -1&#92;)&lt;/span&gt; and &lt;span class=&quot;math inline&quot;&gt;&#92;(a_1 = y&amp;#39;(0) = -2&#92;)&lt;/span&gt;. Setting &lt;span class=&quot;math inline&quot;&gt;&#92;(n = 0&#92;)&lt;/span&gt; in Equation &lt;span class=&quot;math inline&quot;&gt;&#92;((**)&#92;)&lt;/span&gt; yields &lt;span class=&quot;math inline&quot;&gt;&#92;(a_2 = -&#92;frac{1}{2} a_1 - a_0 = -&#92;frac{1}{2}(-2) - (-1) = 2.&#92;)&lt;/span&gt; Setting &lt;span class=&quot;math inline&quot;&gt;&#92;(n = 1&#92;)&lt;/span&gt; in Equation &lt;span class=&quot;math inline&quot;&gt;&#92;((**)&#92;)&lt;/span&gt; yields &lt;span class=&quot;math inline&quot;&gt;&#92;(a_3 = -&#92;frac{2}{3} a_2 - &#92;frac{3}{2} a_1 = -&#92;frac{2}{3}(2) - &#92;frac{3}{2}(-2) = &#92;frac{5}{3}.&#92;)&lt;/span&gt; The coefficients &lt;span class=&quot;math inline&quot;&gt;&#92;(a_4, a_5, a_6, a_7&#92;)&lt;/span&gt; can be computed similarly from Equation &lt;span class=&quot;math inline&quot;&gt;&#92;((**)&#92;)&lt;/span&gt;, yielding the series solution &lt;span class=&quot;math inline&quot;&gt;&#92;(y = -1 - 2x + 2x^2 + &#92;frac{5}{3}x^3 - &#92;frac{55}{12}x^4 + &#92;frac{3}{4}x^5 + &#92;frac{61}{8}x^6 - &#92;frac{443}{56}x^7 + &#92;cdots.&#92;)&lt;/span&gt; The Taylor polynomials &lt;span class=&quot;math inline&quot;&gt;&#92;(T_N(x) = &#92;sum_{n=0}^N a_n x^n&#92;)&lt;/span&gt; converge to the solution of Equation &lt;span class=&quot;math inline&quot;&gt;&#92;((*)&#92;)&lt;/span&gt; on &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;left(-&#92;frac{1}{&#92;sqrt{2}}, &#92;frac{1}{&#92;sqrt{2}}&#92;right)&#92;)&lt;/span&gt;. &lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;introduction-to-the-laplace-transform&quot;&gt;8.1: Introduction to the Laplace Transform&lt;/h3&gt;
&lt;p&gt;The Laplace transform of a function &lt;span class=&quot;math inline&quot;&gt;&#92;(f(t)&#92;)&lt;/span&gt;, defined for &lt;span class=&quot;math inline&quot;&gt;&#92;(t &#92;geq 0&#92;)&lt;/span&gt;, is given by &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;mathcal{L}&#92;{f(t)&#92;} = F(s) = &#92;int_0^&#92;infty e^{-st} f(t) &#92;, dt,&#92;)&lt;/span&gt; where &lt;span class=&quot;math inline&quot;&gt;&#92;(s&#92;)&lt;/span&gt; is a complex variable. It converts functions of time &lt;span class=&quot;math inline&quot;&gt;&#92;(t&#92;)&lt;/span&gt; into functions of the complex variable &lt;span class=&quot;math inline&quot;&gt;&#92;(s&#92;)&lt;/span&gt;. For example, the Laplace transform of &lt;span class=&quot;math inline&quot;&gt;&#92;(e^{at}&#92;)&lt;/span&gt; is &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;mathcal{L}&#92;{e^{at}&#92;} = &#92;frac{1}{s - a}, &#92;quad &#92;text{for } s &amp;gt; a.&#92;)&lt;/span&gt; In practice, Laplace transforms of common functions are often identified using precalculated tables, which provide a quick reference for solving problems without repeatedly computing the integral. &lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;the-inverse-laplace-transform&quot;&gt;8.2: The Inverse Laplace Transform&lt;/h3&gt;
&lt;p&gt;Find &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;mathcal{L}^{-1}&#92;left&#92;{&#92;frac{1}{s^2 + 4}&#92;right&#92;} = &#92;frac{1}{2} &#92;sin 2t&#92;)&lt;/span&gt;. &lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;solution-of-initial-value-problems&quot;&gt;8.3: Solution of Initial Value Problems&lt;/h3&gt;
&lt;p&gt;Solve &lt;span class=&quot;math inline&quot;&gt;&#92;(y&amp;#39;&amp;#39; + y = 0&#92;)&lt;/span&gt;, &lt;span class=&quot;math inline&quot;&gt;&#92;(y(0) = 1&#92;)&lt;/span&gt;, &lt;span class=&quot;math inline&quot;&gt;&#92;(y&amp;#39;(0) = 0&#92;)&lt;/span&gt;. The Laplace transform yields &lt;span class=&quot;math inline&quot;&gt;&#92;(y(t) = &#92;cos t&#92;)&lt;/span&gt;. &lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;the-unit-step-function&quot;&gt;8.4 The Unit Step Function&lt;/h3&gt;
&lt;p&gt;The unit step function &lt;span class=&quot;math inline&quot;&gt;&#92;(u(t - a)&#92;)&lt;/span&gt; is defined as 0 for &lt;span class=&quot;math inline&quot;&gt;&#92;(t &amp;lt; a&#92;)&lt;/span&gt; and 1 for &lt;span class=&quot;math inline&quot;&gt;&#92;(t &#92;geq a&#92;)&lt;/span&gt;. For the equation &lt;span class=&quot;math inline&quot;&gt;&#92;(y&amp;#39;&amp;#39; + y = u(t - &#92;pi)&#92;)&lt;/span&gt; with &lt;span class=&quot;math inline&quot;&gt;&#92;(y(0) = 0&#92;)&lt;/span&gt; and &lt;span class=&quot;math inline&quot;&gt;&#92;(y&amp;#39;(0) = 0&#92;)&lt;/span&gt;, we apply the Laplace transform. The Laplace transform of &lt;span class=&quot;math inline&quot;&gt;&#92;(u(t - &#92;pi)&#92;)&lt;/span&gt; is &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;frac{e^{-&#92;pi s}}{s}&#92;)&lt;/span&gt;. Taking the Laplace transform of the equation gives &lt;span class=&quot;math inline&quot;&gt;&#92;(s^2 Y(s) + Y(s) = &#92;frac{e^{-&#92;pi s}}{s}.&#92;)&lt;/span&gt; Solving for &lt;span class=&quot;math inline&quot;&gt;&#92;(Y(s)&#92;)&lt;/span&gt;, we get &lt;span class=&quot;math inline&quot;&gt;&#92;(Y(s) = &#92;frac{e^{-&#92;pi s}}{s(s^2 + 1)}.&#92;)&lt;/span&gt; Using partial fractions and the inverse Laplace transform, the solution is &lt;span class=&quot;math inline&quot;&gt;&#92;(y(t) = u(t - &#92;pi)(1 - &#92;cos(t - &#92;pi)).&#92;)&lt;/span&gt;
&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;piecewise-continuous-forcing-functions&quot;&gt;8.5 Piecewise Continuous Forcing Functions&lt;/h3&gt;
&lt;p&gt;For &lt;span class=&quot;math inline&quot;&gt;&#92;(y&amp;#39;&amp;#39; + y = f(t)&#92;)&lt;/span&gt;, where &lt;span class=&quot;math inline&quot;&gt;&#92;(f(t) = 1&#92;)&lt;/span&gt; for &lt;span class=&quot;math inline&quot;&gt;&#92;(0 &#92;leq t &amp;lt; &#92;pi&#92;)&lt;/span&gt; and &lt;span class=&quot;math inline&quot;&gt;&#92;(0&#92;)&lt;/span&gt; otherwise, we express &lt;span class=&quot;math inline&quot;&gt;&#92;(f(t)&#92;)&lt;/span&gt; using the unit step function as &lt;span class=&quot;math inline&quot;&gt;&#92;(f(t) = u(t) - u(t - &#92;pi)&#92;)&lt;/span&gt;. The Laplace transform of &lt;span class=&quot;math inline&quot;&gt;&#92;(f(t)&#92;)&lt;/span&gt; is &lt;span class=&quot;math inline&quot;&gt;&#92;(F(s) = &#92;frac{1}{s} - &#92;frac{e^{-&#92;pi s}}{s}.&#92;)&lt;/span&gt; Taking the Laplace transform of the equation &lt;span class=&quot;math inline&quot;&gt;&#92;(y&amp;#39;&amp;#39; + y = f(t)&#92;)&lt;/span&gt; gives &lt;span class=&quot;math inline&quot;&gt;&#92;(s^2 Y(s) + Y(s) = &#92;frac{1}{s} - &#92;frac{e^{-&#92;pi s}}{s}.&#92;)&lt;/span&gt; Solving for &lt;span class=&quot;math inline&quot;&gt;&#92;(Y(s)&#92;)&lt;/span&gt;, we obtain &lt;span class=&quot;math inline&quot;&gt;&#92;(Y(s) = &#92;frac{1}{s(s^2 + 1)} - &#92;frac{e^{-&#92;pi s}}{s(s^2 + 1)}.&#92;)&lt;/span&gt; Using partial fractions and the inverse Laplace transform, the solution is &lt;span class=&quot;math inline&quot;&gt;&#92;(y(t) = (1 - &#92;cos t) - u(t - &#92;pi)(1 - &#92;cos(t - &#92;pi)).&#92;)&lt;/span&gt;
&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;convolution&quot;&gt;8.6 Convolution&lt;/h3&gt;
&lt;p&gt;For &lt;span class=&quot;math inline&quot;&gt;&#92;(y&amp;#39;&amp;#39; + y = &#92;sin t&#92;)&lt;/span&gt; with &lt;span class=&quot;math inline&quot;&gt;&#92;(y(0) = 0&#92;)&lt;/span&gt; and &lt;span class=&quot;math inline&quot;&gt;&#92;(y&amp;#39;(0) = 0&#92;)&lt;/span&gt;, we use the convolution integral. The impulse response of the system is &lt;span class=&quot;math inline&quot;&gt;&#92;(h(t) = &#92;sin t&#92;)&lt;/span&gt;. The solution is given by the convolution of &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;sin t&#92;)&lt;/span&gt; with the input &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;sin t&#92;)&lt;/span&gt;
&lt;span class=&quot;math inline&quot;&gt;&#92;(y(t) = &#92;int_0^t &#92;sin(t - &#92;tau) &#92;sin &#92;tau &#92;, d&#92;tau.&#92;)&lt;/span&gt; Using the trigonometric identity &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;sin A &#92;sin B = &#92;frac{1}{2}[&#92;cos(A - B) - &#92;cos(A + B)]&#92;)&lt;/span&gt;, the integral becomes &lt;span class=&quot;math inline&quot;&gt;&#92;(y(t) = &#92;frac{1}{2} &#92;int_0^t [&#92;cos(t - 2&#92;tau) - &#92;cos t] &#92;, d&#92;tau.&#92;)&lt;/span&gt; Evaluating the integral, we obtain &lt;span class=&quot;math inline&quot;&gt;&#92;(y(t) = &#92;frac{1}{2}(&#92;sin t - t &#92;cos t).&#92;)&lt;/span&gt;
&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;impulse-functions&quot;&gt;8.7 Impulse Functions&lt;/h3&gt;
&lt;p&gt;For &lt;span class=&quot;math inline&quot;&gt;&#92;(y&amp;#39;&amp;#39; + y = &#92;delta(t - &#92;pi)&#92;)&lt;/span&gt; with &lt;span class=&quot;math inline&quot;&gt;&#92;(y(0) = 0&#92;)&lt;/span&gt; and &lt;span class=&quot;math inline&quot;&gt;&#92;(y&amp;#39;(0) = 0&#92;)&lt;/span&gt;, the Laplace transform of &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;delta(t - &#92;pi)&#92;)&lt;/span&gt; is &lt;span class=&quot;math inline&quot;&gt;&#92;(e^{-&#92;pi s}&#92;)&lt;/span&gt;. Taking the Laplace transform of the equation gives &lt;span class=&quot;math inline&quot;&gt;&#92;(s^2 Y(s) + Y(s) = e^{-&#92;pi s}.&#92;)&lt;/span&gt; Solving for &lt;span class=&quot;math inline&quot;&gt;&#92;(Y(s)&#92;)&lt;/span&gt;, we get &lt;span class=&quot;math inline&quot;&gt;&#92;(Y(s) = &#92;frac{e^{-&#92;pi s}}{s^2 + 1}.&#92;)&lt;/span&gt; The inverse Laplace transform yields &lt;span class=&quot;math inline&quot;&gt;&#92;(y(t) = u(t - &#92;pi) &#92;sin(t - &#92;pi).&#92;)&lt;/span&gt;
&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>khovanov homology talk</title>
    <link href="https://ischmidls.github.io/blog/khovanov/" />
    <updated>2024-06-14T00:00:00Z</updated>
    <id>https://ischmidls.github.io/blog/khovanov/</id>
    <content type="html">&lt;script type=&quot;text/x-mathjax-config&quot;&gt;
    MathJax.Hub.Config({
      jax: [&quot;input/TeX&quot;, &quot;output/HTML-CSS&quot;],
      extensions: [&quot;tex2jax.js&quot;],
      &quot;HTML-CSS&quot;: { preferredFont: &quot;TeX&quot;, availableFonts: [&quot;STIX&quot;,&quot;TeX&quot;] },
      tex2jax: { inlineMath: [ [&quot;$&quot;, &quot;$&quot;], [&quot;&#92;&#92;(&quot;,&quot;&#92;&#92;)&quot;] ], displayMath: [ [&quot;$$&quot;,&quot;$$&quot;], [&quot;&#92;&#92;[&quot;, &quot;&#92;&#92;]&quot;] ], processEscapes: true, ignoreClass: &quot;tex2jax_ignore|dno&quot; },
      TeX: { noUndefined: { attributes: { mathcolor: &quot;red&quot;, mathbackground: &quot;#FFEEEE&quot;, mathsize: &quot;90%&quot; } } },
      messageStyle: &quot;none&quot;
    });
    &lt;/script&gt;    
    &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js&quot;&gt;&lt;/script&gt;
&lt;p&gt;This is an 8-minute presentation I gave. It was my final project for an undergraduate &quot;writing intensive&quot; course on knot theory.
&lt;/p&gt;

&lt;picture&gt;&lt;source type=&quot;image/avif&quot; srcset=&quot;https://ischmidls.github.io/blog/khovanov/5JuAy0gpIF-2500.avif 2500w&quot;&gt;&lt;source type=&quot;image/webp&quot; srcset=&quot;https://ischmidls.github.io/blog/khovanov/5JuAy0gpIF-2500.webp 2500w&quot;&gt;&lt;img loading=&quot;lazy&quot; decoding=&quot;async&quot; src=&quot;https://ischmidls.github.io/blog/khovanov/5JuAy0gpIF-2500.png&quot; alt=&quot;poster&quot; width=&quot;2500&quot; height=&quot;1406&quot;&gt;&lt;/picture&gt;

&lt;p&gt;Hi, I’d like to tell you about Khovanov homology with minimal intense
    algebra and end with an informal example of ribbon concordance. My
    inspiration was a theorem: “ribbon concordance induces an injective map
    on Khovanov homology,” based on the work of Levine and Zemke (2019).&lt;/p&gt;
    &lt;p&gt;Homology is about “cycles” or kernels (inputs that map to zero) of
    the differential maps modulo those cycles that are “boundaries” or
    images in sequences of vector spaces. This quotient forms the homology
    as a group.&lt;/p&gt;
    &lt;p&gt;The smoothing states of a link diagram form a sequence of vector
    spaces classes a chain complex (vector space = chain, sequence =
    complex) that also have isomorphic homology. The order of the sequence
    is given by differential maps or boundary maps between the vector
    spaces.&lt;/p&gt;
    &lt;p&gt;The image of each map is the kernel of the next, until the sequence
    reaches the trivial kernel, which is just zero.&lt;/p&gt;
    &lt;p&gt;The homology is the group formed by the quotient of the kernel by
    image. If you don’t know about groups, just think about these for now as
    some vector space without scaling. (If you’re unfamiliar with quotients,
    this is just like quotients with numbers, but instead of saying there
    are 4 things that look like 3 among 12 things, you separate them by
    their vector space properties). You can think of this as saying how much
    of the remaining space looks like the kernel.&lt;/p&gt;
    &lt;p&gt;This also has a geometric view. The kernels are cycles, or closed
    loops, for some base point in the vector space. The image is the
    boundaries in the space. We say boundary in the sense that you can
    imagine the vector space basis as a graph, right, with basis vectors as
    vertices?. A boundary is what remains when you remove part of the graph
    that is one dimension less. For example, removing a line from a triangle
    or a face from a pyramid/simplex.&lt;/p&gt;
    &lt;p&gt;When you take two chain complexes and can find two distinct maps
    between the complexes that pair up their (homology groups) chains/vector
    spaces the same way, this induces what are called homotopies between the
    chains or vector spaces.&lt;/p&gt;
    &lt;p&gt;Recall the Jones and Kauffman polynomials came from defining rules
    for link brackets.&lt;/p&gt;
    &lt;p&gt;In thia picture, let &lt;span class=&quot;math inline&quot;&gt;&#92;(L&#92;)&lt;/span&gt; be the
    link and &lt;span class=&quot;math inline&quot;&gt;&#92;(V&#92;)&lt;/span&gt; be a vector space of
    dimensions &lt;span class=&quot;math inline&quot;&gt;&#92;((q + q^{-1})&#92;)&lt;/span&gt;. The map
    &lt;span class=&quot;math inline&quot;&gt;&#92;(F&#92;)&lt;/span&gt; takes a double complex to a
    single complex by taking direct sums along the diagonals of the double
    complex. The differential map &lt;span class=&quot;math inline&quot;&gt;&#92;(d&#92;)&lt;/span&gt; is
    not yet defined.&lt;/p&gt;
    &lt;p&gt;The bracket is given by a direct sum over the smoothings of &lt;span class=&quot;math inline&quot;&gt;&#92;(L&#92;)&lt;/span&gt; of tensor powers of &lt;span class=&quot;math inline&quot;&gt;&#92;(V&#92;)&lt;/span&gt;, where a factor of the powers of &lt;span class=&quot;math inline&quot;&gt;&#92;(V&#92;)&lt;/span&gt; corresponds to a cycle in a smoothing.
    That is, the space &lt;span class=&quot;math inline&quot;&gt;&#92;(V(k)&#92;)&lt;/span&gt; on each
    vertex &lt;span class=&quot;math inline&quot;&gt;&#92;(k&#92;)&lt;/span&gt; has as many tensor factors
    as there are cycles in the smoothing &lt;span class=&quot;math inline&quot;&gt;&#92;(S(k)&#92;)&lt;/span&gt;. These powers behave like spaces of
    linear combinations of marked smoothings of &lt;span class=&quot;math inline&quot;&gt;&#92;(L&#92;)&lt;/span&gt;, so each cycle in a smoothing of &lt;span class=&quot;math inline&quot;&gt;&#92;(L&#92;)&lt;/span&gt; corresponds to an element of &lt;span class=&quot;math inline&quot;&gt;&#92;(V&#92;)&lt;/span&gt;.&lt;/p&gt;
    &lt;p&gt;Khovanov does this similarly, defining his own bracket, with states
    sums and other definitions similar to Khovanov. For the bracket, he
    exploits the fact the Euler characteristic of each chain or vector space
    is the same as the Euler characteristic of the corresponding homology
    group. Here I must make a slight point, Khovanov homology actually
    describes a cohomology, where instead of boundary maps taking away
    components, the maps between chains or vector spaces add components.
    This Euler characteristic of the Khovanov homology also happens to be
    the Jones polynomial we talked about.&lt;/p&gt;
    &lt;p&gt;He also uses that the boundary maps are given by the vector space
    gradings, or the fact that we can add smoothing states together to form
    smoothings with fewer components, or as we did with Kauffman, we can add
    more smoothings to a state to achieve more components. The Khovanov
    polynomial similarly uses the dimensions of each cohomology for the
    chain complex of the link states for the corresponding term in the sum
    defining the polynomial.&lt;/p&gt;
    &lt;p&gt;A Tensor product in this case is just a way to take any of the basis
    vectors and put them into a list, where the list is a new basis vector
    in the new space, and vice versa, taking lists and breaking them apart.
    You can imagine as the kernel of the vector space shrinks, less of the
    vector space looks like its kernel, and in a sense at the limit of these
    boundary maps, we reach the stalk vector space growing out the kernels
    of the chain complex of vector spaces.&lt;/p&gt;
    &lt;p&gt;Now stepping back from the chain complex, we can see it forms a cube.
    And we know this is a chain complex precisely because this cube
    commutes. That is, taking a boundary map in the first row, then mapping
    to the second row should be the same as mapping to the second row then
    taking a boundary map. This also shows that the definitions of the bases
    or the order of smoothings will not change this chain complex for a
    given knot.&lt;/p&gt;
    &lt;p&gt;To wrap up quickly, let’s look at some examples. We have this
    illustration from (Bar-Natan, 2002) for the trefoil. You can see how
    moving between the states forms different brackets from their sums, and
    these brackets form a complex.&lt;/p&gt;
    &lt;p&gt;You can see boundary maps change the tensor power of the vector space
    and the degree shift. The tensor power does not change the vector space
    dimension, but the degree shift does. While these are integer vector
    spaces, you can think of Euclidean space. If a matrix mapping a vector
    space to another is rectangular, it deletes one of the basis elements,
    and the situation is similar here.&lt;/p&gt;
    &lt;p&gt;Concordance or more broadly cobordism can be seen as a map between
    Khovanov homologies and is clearly a homotopy between two links as the
    manifold provides the path mapping. For example, rolling up a sheet of
    paper into a cylinder and slipping a rubber band around each end
    connects two unknotted rubber bands. In 4 dimensions, the cylinder might
    smooth out, untying any knot.&lt;/p&gt;
    &lt;p&gt;A “path” is a continuous map from an interval to a space. A
    “homotopy” of paths is a “family of maps” from an interval to a space
    with the same endpoints where paths follow another path. Think of it as
    a map from two intervals to the space. A “composition/product path” lets
    you glue two paths together. As we discussed in class, a “loop” is a
    path that ends and begins at the same point (i.e., the “basepoint”).&lt;/p&gt;
    &lt;p&gt;We look at cobordisms or concordance with “movie moves”, looking at
    different 3-dimensional places in the four dimensional manifold where
    there are singularities (max, min saddle).&lt;/p&gt;
    &lt;p&gt;And, we could go both directions, given a concordance between two
    links, we can find their Khovanov homologies are the same, or given
    Khovanov homologies between two links, we can find a cobordism between
    the links.&lt;/p&gt;
    &lt;p&gt;Khovanov homology also gives combinatorial methods for more abstract
    homologies in other fields like Floer homologies (3-manifold, Heegaard,
    Lagrangian).&lt;/p&gt;
    &lt;p&gt;And we will have to end there. Any questions?&lt;/p&gt;

    &lt;hr&gt;
    &lt;p&gt;Further Information for potential questions or extra time:&lt;/p&gt;
    &lt;ul&gt;
        &lt;li&gt;Ribbon concordance between two knots has no local minima.&lt;/li&gt;
        &lt;li&gt;Concordance for two submanifolds &#92;( M&#39; &#92;), &#92;( M&#39;&#39; &#92;) contained in &#92;( N &#92;) is a cobordism between them in &#92;( N &#92;times [0, 1] &#92;), so a manifold with boundary &#92;( W &#92;) contained in &#92;( N &#92;times [0, 1] &#92;) whose boundary is &#92;( M&#39; &#92;times &#92;{0&#92;} &#92;) and &#92;( M&#39;&#39; &#92;times &#92;{1&#92;} &#92;).&lt;/li&gt;
        &lt;li&gt;This is a relative form of cobordism since it all happens in &#92;( N &#92;).&lt;/li&gt;
        &lt;li&gt;&#92;( I = [0, 1] &#92;). It is a 1-dimensional cobordism between the 0-dimensional manifolds &#92;( &#92;{0&#92;} &#92;), &#92;( &#92;{1&#92;} &#92;).&lt;/li&gt;
        &lt;li&gt;Generally, for any closed manifold &#92;( M &#92;), &#92;( (M &#92;times I; M &#92;times &#92;{0&#92;}, M &#92;times &#92;{1&#92;}) &#92;) is a cobordism from &#92;( M &#92;times &#92;{0&#92;} &#92;) to &#92;( M &#92;times &#92;{1&#92;} &#92;).&lt;/li&gt;
        &lt;li&gt;A homotopy between two continuous functions &#92;( f &#92;) and &#92;( g &#92;) from a topological space &#92;( X &#92;) to a topological space &#92;( Y &#92;) is defined to be a continuous function &#92;( H: X &#92;times [0, 1] &#92;to Y &#92;) (so from the product of the space with the unit interval &#92;( X &#92;times [0, 1] &#92;) to &#92;( Y &#92;)) such that &#92;( H(x, 0) = f(x) &#92;) and &#92;( H(x, 1) = g(x) &#92;) for all &#92;( x &#92;in X &#92;).&lt;/li&gt;
        &lt;li&gt;Two links, denoted as &#92;( l&#39; &#92;) within &#92;( m &#92;)-sphere and &#92;( l&#39;&#39; &#92;) within &#92;( n &#92;)-sphere, are considered concordant if there exists an embedding function &#92;( f &#92;) from &#92;( l&#39; &#92;times [0, 1] &#92;) to &#92;( n &#92;)-sphere &#92;( &#92;times [0, 1] &#92;).&lt;/li&gt;
        &lt;li&gt;This function has two conditions:
            &lt;ul&gt;
                &lt;li&gt;The image &#92;( f(l&#39; &#92;times &#92;{0&#92;}) = l&#39; &#92;times &#92;{0&#92;} &#92;).&lt;/li&gt;
                &lt;li&gt;The image &#92;( f(l&#39; &#92;times &#92;{1&#92;}) = l&#39;&#39; &#92;times &#92;{1&#92;} &#92;).&lt;/li&gt;
            &lt;/ul&gt;
        &lt;/li&gt;
        &lt;li&gt;This forms an equivalence relation.&lt;/li&gt;
        &lt;li&gt;It is a weaker condition than isotopy and a stronger condition than homotopy, meaning that:
            &lt;ul&gt;
                &lt;li&gt;Isotopy implies concordance/cobordism (and concordance implies cobordism).&lt;/li&gt;
                &lt;li&gt;Concordance/cobordism implies homotopy.&lt;/li&gt;
            &lt;/ul&gt;
        &lt;/li&gt;
        &lt;li&gt;Slice knot concordant with unknot (3D knot bounds disc in 4D).&lt;/li&gt;
        &lt;li&gt;&#92;( Kh(L) &#92;): “Poincaré Polynomial” formal power series in one indeterminate, say &#92;( t &#92;), where the coefficient of &#92;( t^n &#92;) gives the dimension (or rank) of the substructure of elements homogeneous of degree &#92;( n &#92;).&lt;/li&gt;
    &lt;/ul&gt;
    &lt;picture&gt;&lt;source type=&quot;image/avif&quot; srcset=&quot;https://ischmidls.github.io/blog/khovanov/Fn1C3iL7uA-663.avif 663w&quot;&gt;&lt;source type=&quot;image/webp&quot; srcset=&quot;https://ischmidls.github.io/blog/khovanov/Fn1C3iL7uA-663.webp 663w&quot;&gt;&lt;img loading=&quot;lazy&quot; decoding=&quot;async&quot; src=&quot;https://ischmidls.github.io/blog/khovanov/Fn1C3iL7uA-663.png&quot; alt=&quot;guide&quot; width=&quot;663&quot; height=&quot;1096&quot;&gt;&lt;/picture&gt;
    &lt;p&gt;My professor said this guide was too complicated to put on my poster.&lt;/p&gt;
    &lt;p&gt;Further reference:&lt;/p&gt;
    &lt;ul&gt;
    &lt;li&gt;Bar-Natan, D. (2002). On Khovanov’s categorification of the Jones
    polynomial. Algebraic &amp;amp; Geometric Topology, 2(1), 337–370.&lt;/li&gt;
    &lt;li&gt;Bar-Natan, D. (2005). Khovanov’s homology for tangles and
    cobordisms. Geometry &amp;amp; Topology, 9(3), 1443–1499.&lt;/li&gt;
    &lt;li&gt;Hatcher, A. (2002). Algebraic topology. Cambridge: Cambridge
    University Press.&lt;/li&gt;
    &lt;li&gt;Kauffman, L. H. (2016). An Introduction to Khovanov Homology.
    Contemporary Mathematics - American Mathematical Society, 105–139.&lt;/li&gt;
    &lt;li&gt;Levine, A. &amp;amp; Zemke, I. (2019). Khovanov homology and ribbon
    concordances. Bulletin of the London Mathematical Society, 51(6),
    1099–1103.&lt;/li&gt;
    &lt;li&gt;Ray, A. (2023). Slice knots and knot concordance. Winterbraids XI in
    Dijon. ArXiv.org.&lt;/li&gt;
    &lt;/ul&gt;</content>
  </entry>
  <entry>
    <title>cohomology ring of n-sphere</title>
    <link href="https://ischmidls.github.io/blog/cohomologysphere/" />
    <updated>2024-05-30T00:00:00Z</updated>
    <id>https://ischmidls.github.io/blog/cohomologysphere/</id>
    <content type="html">&lt;script type=&quot;text/x-mathjax-config&quot;&gt;
    MathJax.Hub.Config({
      jax: [&quot;input/TeX&quot;, &quot;output/HTML-CSS&quot;],
      extensions: [&quot;tex2jax.js&quot;],
      &quot;HTML-CSS&quot;: { preferredFont: &quot;TeX&quot;, availableFonts: [&quot;STIX&quot;,&quot;TeX&quot;] },
      tex2jax: { inlineMath: [ [&quot;$&quot;, &quot;$&quot;], [&quot;&#92;&#92;(&quot;,&quot;&#92;&#92;)&quot;] ], displayMath: [ [&quot;$$&quot;,&quot;$$&quot;], [&quot;&#92;&#92;[&quot;, &quot;&#92;&#92;]&quot;] ], processEscapes: true, ignoreClass: &quot;tex2jax_ignore|dno&quot; },
      TeX: { noUndefined: { attributes: { mathcolor: &quot;red&quot;, mathbackground: &quot;#FFEEEE&quot;, mathsize: &quot;90%&quot; } } },
      messageStyle: &quot;none&quot;
    });
    &lt;/script&gt;    
    &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js&quot;&gt;&lt;/script&gt;
    &lt;p&gt;
        Differential forms and holes in a space are related through cohomology, but the direct measure of holes is homology. In simplicial homology, a space is decomposed into simplices, and chain groups &#92;(C_k(X)&#92;) are formal linear combinations of &#92;(k&#92;)-simplices. The boundary operator &#92;(&#92;partial&#92;) maps a simplex to its boundary, an alternating sum of its faces, satisfying &#92;(&#92;partial^2 = 0&#92;) due to sign cancellations. Cycles (elements killed by &#92;(&#92;partial&#92;)) represent loops or higher-dimensional analogs, while boundaries (images of &#92;(&#92;partial&#92;)) are loops that bound filled regions. Homology &#92;(H_k(X)&#92;) measures holes by quotienting cycles by boundaries, capturing loops that aren’t filled in.

Cohomology, on the other hand, dualizes this construction. Instead of chains, cohomology uses cochains &#92;(C^k = &#92;text{Hom}(C_k, &#92;mathbb{Z})&#92;), with a coboundary operator increasing dimension. Intuitively, cohomology measures how forms can detect holes. For instance, a closed form (cocycle) that isn’t exact (coboundary) corresponds to a hole. This duality is formalized in theorems like Poincaré duality, which relates &#92;(k&#92;)-chains to &#92;((n-k)&#92;)-cochains via intersection pairing, and the Universal Coefficient Theorem, which connects homology and cohomology over different coefficient rings.

In de Rham cohomology, differential forms are used as cochains, with closed forms representing cocycles and exact forms representing coboundaries. This theory detects holes similarly to simplicial cohomology but uses smooth structures. For example, the space &#92;(&#92;Omega_n(X)&#92;) of differential &#92;(n&#92;)-forms on &#92;(X&#92;) has that closed forms in &#92;(&#92;Omega_n(X)&#92;) detect holes via Stokes&#39; theorem, which ensures that integrals of closed forms over cycles are invariant under homotopy. If two paths yield different integrals for a closed form, they cannot be deformed into each other, indicating a &quot;hole.&quot; This idea is formalized by the de Rham map, &#92;(&#92;Omega_n(X) &#92;to &#92;text{Hom}(C_n(X), &#92;mathbb{R})&#92;), sending a form &#92;(&#92;omega&#92;) to the functional &#92;(&#92;sigma &#92;mapsto &#92;int_&#92;sigma &#92;omega&#92;). Stokes&#39; theorem ensures this is a chain map, and the de Rham theorem shows it induces an isomorphism between de Rham cohomology and singular cohomology, linking differential forms to the intuitive notion of holes. However, coefficients matter: de Rham cohomology with &#92;(&#92;mathbb{R}&#92;) coefficients misses torsion phenomena, like in &#92;(&#92;mathbb{R}P^2&#92;), where a loop traversed twice bounds a disk, but not once. Thus, while differential forms and holes are linked through cohomology, the choice of coefficients and theory determines what geometric or topological features are visible, giving the need for the Universal Coefficient Theorem.
    &lt;/p&gt;
    &lt;p&gt;The above is based on &lt;a href=&quot;https://math.stackexchange.com/a/3635358/1098426&quot;&gt;this&lt;/a&gt; MSE post&lt;/p&gt;
    
    &lt;p&gt;Every continuous map &#92;(f: X &#92;to Y&#92;) induces a homomorphism from the cohomology ring of &#92;(Y&#92;) to that of &#92;(X&#92;), limiting the possible maps between spaces. Unlike more complex invariants like homotopy groups, singular cohomology is often computable for spaces of interest. The construction begins with the singular chain complex, a sequence of free abelian groups &#92;(C_i&#92;) generated by continuous maps from the standard &#92;(i&#92;)-simplex to &#92;(X&#92;), connected by boundary homomorphisms &#92;(&#92;partial_i&#92;). The singular homology of &#92;(X&#92;) is the homology of this complex. To define cohomology, one fixes an abelian group &#92;(A&#92;) and &quot;dualizes the chain complex, replacing &#92;(C_i&#92;) with &#92;(C_i^* = &#92;text{Hom}(C_i, A)&#92;)&quot;...&lt;/p&gt;
    
    &lt;p&gt;... e.g. consider the chain complex &#92;(C_*&#92;) with &#92;(C_0 = &#92;mathbb{Z}&#92;), &#92;(C_1 = &#92;mathbb{Z}&#92;), and &#92;(C_i = 0&#92;) for &#92;(i &#92;neq 0, 1&#92;), connected by the boundary map &#92;(&#92;partial_1: C_1 &#92;to C_0&#92;) defined by &#92;(&#92;partial_1(n) = 2n&#92;). To dualize this complex, replace each &#92;(C_i&#92;) with &#92;(C_i^* = &#92;text{Hom}(C_i, A)&#92;), where &#92;(A&#92;) is an abelian group, say &#92;(A = &#92;mathbb{Z}&#92;). Here, &#92;(C_0^* = &#92;text{Hom}(&#92;mathbb{Z}, &#92;mathbb{Z}) &#92;simeq &#92;mathbb{Z}&#92;) and &#92;(C_1^* = &#92;text{Hom}(&#92;mathbb{Z}, &#92;mathbb{Z}) &#92;simeq &#92;mathbb{Z}&#92;), with the dual map &#92;(d_0: C_0^* &#92;to C_1^*&#92;) defined by &#92;(d_0(f)(m) = f(&#92;partial_1(m)) = f(2m)&#92;). This dual map &#92;(d_0&#92;) effectively &quot;reverses the arrows&quot; of the original boundary map...&lt;/p&gt;
    
    &lt;p&gt;...and replacing &#92;(&#92;partial_i&#92;) with its dual &#92;(d_{i-1}: C_{i-1}^* &#92;to C_i^*&#92;). This reversal of arrows yields a cochain complex, and the &#92;(i&#92;)-th cohomology group &#92;(H^i(X, A)&#92;) is defined as &#92;(&#92;text{ker}(d_i) / &#92;text{im}(d_{i-1})&#92;). Elements of &#92;(C_i^*&#92;) are called &#92;(i&#92;)-cochains, while those in &#92;(&#92;text{ker}(d_i)&#92;) and &#92;(&#92;text{im}(d_{i-1})&#92;) are cocycles and coboundaries, respectively. The cohomology classes, represented by equivalence classes of cocycles, form the cohomology groups, which vanish for negative &#92;(i&#92;).&lt;/p&gt;



    &lt;p&gt;
        In singular cohomology, the cup product defines a multiplication on the cohomology ring &#92;(H^*(X)&#92;) of a topological space &#92;(X&#92;). It is constructed by defining a product on cochains: if &#92;(&#92;alpha^p&#92;) is a &#92;(p&#92;)-cochain and &#92;(&#92;beta^q&#92;) is a &#92;(q&#92;)-cochain, their cup product &#92;(&#92;alpha^p &#92;smile &#92;beta^q&#92;) is a &#92;((p+q)&#92;)-cochain given by &#92;((&#92;alpha^p &#92;smile &#92;beta^q)(&#92;sigma) = &#92;alpha^p(&#92;sigma &#92;circ &#92;iota_{0,1,...,p}) &#92;cdot &#92;beta^q(&#92;sigma &#92;circ &#92;iota_{p,p+1,...,p+q})&#92;), where &#92;(&#92;sigma&#92;) is a singular &#92;((p+q)&#92;)-simplex and &#92;(&#92;iota_S&#92;) embeds the simplex spanned by &#92;(S&#92;) into the &#92;((p+q)&#92;)-simplex. Informally, &#92;(&#92;sigma &#92;circ &#92;iota_{0,1,...,p}&#92;) represents the front &#92;(p&#92;)-face of &#92;(&#92;sigma&#92;), while &#92;(&#92;sigma &#92;circ &#92;iota_{p,p+1,...,p+q}&#92;) represents the back &#92;(q&#92;)-face. The coboundary of the cup product satisfies &#92;(&#92;delta(&#92;alpha^p &#92;smile &#92;beta^q) = &#92;delta&#92;alpha^p &#92;smile &#92;beta^q + (-1)^p (&#92;alpha^p &#92;smile &#92;delta&#92;beta^q)&#92;). This ensures that the cup product of two cocycles is a cocycle, and the product of a coboundary with a cocycle is a coboundary. The cup product thus induces a bilinear operation on cohomology, &#92;(H^p(X) &#92;times H^q(X) &#92;to H^{p+q}(X)&#92;), making &#92;(H^*(X)&#92;) a graded ring.
    &lt;/p&gt;
    &lt;p&gt;For how the cup product is dual to intersection for oriented minfolds, I recommend &lt;a href=&quot;https://math.berkeley.edu/~hutching/teach/215b-2011/cup.pdf&quot;&gt;this paper&lt;/a&gt; by Michael Hutchings
    &lt;/p&gt;
&lt;p&gt;For the &#92;(n&#92;)-sphere &#92;(S^n&#92;), we know that the only non-zero cohomology groups are &#92;(H^0(S^n, &#92;mathbb{Z}) &#92;simeq &#92;mathbb{Z}&#92;) and &#92;(H^n(S^n, &#92;mathbb{Z}) &#92;simeq &#92;mathbb{Z}&#92;)...&lt;/p&gt;

&lt;p&gt;...For the &#92;(n&#92;)-sphere &#92;(S^n&#92;), the only non-zero cohomology groups are &#92;(H^0(S^n, &#92;mathbb{Z}) &#92;simeq &#92;mathbb{Z}&#92;) and &#92;(H^n(S^n, &#92;mathbb{Z}) &#92;simeq &#92;mathbb{Z}&#92;) because &#92;(S^n&#92;) is a connected (it is NOT the union of two disjoint non-empty open sets), compact (every open cover has a finite subcover), orientable manifold. Now, the $n$-sphere is a closed oriented manifold so that we can use the Poincaré duality saying the $k$-cohomology group is isomorphic to the $n-k$-th homology group: $H^k (&#92;mathbb T^2) &#92;cong H_{n-k} (&#92;mathbb T^2)$. The group &#92;(H^0(S^n, &#92;mathbb{Z})&#92;) corresponds to the constant functions on &#92;(S^n&#92;), reflecting its connectedness as there is only one such function up to scaling,. And &#92;(H^n(S^n, &#92;mathbb{Z})&#92;) captures the top-dimensional cohomology, representing the orientation class of &#92;(S^n&#92;), e.g. (thanks to &lt;a href=&quot;https://math.stackexchange.com/a/1706944/1098426&quot;&gt;this&lt;/a&gt; and &lt;a href=&quot;https://math.stackexchange.com/a/1276703/1098426&quot;&gt;that&lt;/a&gt; MSE) for de Rham $H^n_{dR}(S^n)&#92;simeq &#92;mathbb{R}$ by the map $[&#92;omega]&#92;mapsto &#92;int_{S^n} &#92;omega$ where there is $&#92;eta$ a nowhere zero $n$-form on $S$ and we can say $C = &#92;int_S &#92;eta &#92;in &#92;mathbb R$. So for any $[&#92;omega] &#92;in H^n(S)$, see $D:= &#92;int_S &#92;omega$. This is nonzero. Then $[&#92;frac{D}{C} &#92;eta] = [&#92;omega]$ as 
    
    $$&#92;int_S &#92;frac DC &#92;eta = D = &#92;int_S &#92;omega . $$
    
And $&#92;frac DC &#92;eta$ is nowhere vanishing (thus an orientation). All other cohomology groups vanish because &#92;(S^n&#92;) has no &quot;holes&quot; in intermediate dimensions.

...&lt;/p&gt;

&lt;p&gt; ... The generator of &#92;(H^0&#92;) corresponds to the unit element of the ring, denoted as &#92;(1&#92;), since the cup product with &#92;(H^0&#92;) acts as the identity map on &#92;(H^k(X; &#92;mathbb{Z})&#92;). The generator of &#92;(H^n&#92;) is denoted as &#92;(x&#92;). The cup product structure is determined by the relations &#92;(1 &#92;smile 1 = 1&#92;), &#92;(1 &#92;smile x = x&#92;), &#92;(x &#92;smile 1 = x&#92;), and &#92;(x &#92;smile x = 0&#92;), where the last relation arises because &#92;(H^{2n}(S^n, &#92;mathbb{Z}) = 0&#92;). The cohomology ring &#92;(H^*(S^n; &#92;mathbb{Z})&#92;) is therefore the direct sum &#92;(H^0(S^n, &#92;mathbb{Z}) &#92;oplus H^n(S^n, &#92;mathbb{Z})&#92;), which can be expressed as &#92;(&#92;alpha_1 &#92;cdot 1 &#92;oplus &#92;alpha_2 &#92;cdot x&#92;) for integers &#92;(&#92;alpha_1, &#92;alpha_2&#92;). This ring is abstractly isomorphic to the polynomial ring &#92;(&#92;mathbb{Z}[x]/(x^2)&#92;), where &#92;(x&#92;) represents the generator of &#92;(H^n(S^n, &#92;mathbb{Z})&#92;). A similar analysis applies to the real projective plane &#92;(&#92;mathbb{R} P^2&#92;), whose cohomology ring is &#92;(&#92;mathbb{Z}[x]/(2x, x^2)&#92;), with &#92;(x&#92;) being the generator of &#92;(H^2(&#92;mathbb{R} P^2, &#92;mathbb{Z})&#92;). Here, the relations &#92;(2x = 0&#92;) and &#92;(x^2 = 0&#92;) reflect the torsion in the cohomology groups and the vanishing of the cup product in higher degrees, respectively.&lt;/p&gt;

&lt;p&gt;The above note expands on &lt;a href=&quot;https://math.stackexchange.com/a/38618/1098426&quot;&gt;this&lt;/a&gt; MSE post.&lt;/p&gt;</content>
  </entry>
</feed>